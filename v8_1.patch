commit 5958c3d384daf28b42ac8be91245db3410170e1d
Author: kanghua <jjykh@hotmail.com>
Date:   Sun Nov 11 11:41:09 2018 +0800

    remove simd.js support

diff --git a/BUILD.gn b/BUILD.gn
index 3121dceccf..8848a7f9ce 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -392,7 +392,6 @@ action("js2c_experimental") {
     "src/js/harmony-async-await.js",
     "src/js/harmony-atomics.js",
     "src/js/harmony-sharedarraybuffer.js",
-    "src/js/harmony-simd.js",
     "src/js/harmony-string-padding.js",
     "src/js/promise-extra.js",
   ]
@@ -1404,7 +1403,6 @@ v8_source_set("v8_base") {
     "src/runtime/runtime-proxy.cc",
     "src/runtime/runtime-regexp.cc",
     "src/runtime/runtime-scopes.cc",
-    "src/runtime/runtime-simd.cc",
     "src/runtime/runtime-strings.cc",
     "src/runtime/runtime-symbol.cc",
     "src/runtime/runtime-test.cc",
diff --git a/gypfiles/all.gyp b/gypfiles/all.gyp
index ff1bea4b61..2ef290201b 100644
--- a/gypfiles/all.gyp
+++ b/gypfiles/all.gyp
@@ -38,7 +38,6 @@
             '../test/optimize_for_size.gyp:*',
             '../test/perf.gyp:*',
             '../test/preparser/preparser.gyp:*',
-            '../test/simdjs/simdjs.gyp:*',
             '../test/test262/test262.gyp:*',
             '../test/webkit/webkit.gyp:*',
             '../tools/check-static-initializers.gyp:*',
diff --git a/include/v8-profiler.h b/include/v8-profiler.h
index b2c1dc9818..e9935df339 100644
--- a/include/v8-profiler.h
+++ b/include/v8-profiler.h
@@ -282,8 +282,7 @@ class V8_EXPORT HeapGraphNode {
                          // snapshot items together.
     kConsString = 10,    // Concatenated string. A pair of pointers to strings.
     kSlicedString = 11,  // Sliced string. A fragment of another string.
-    kSymbol = 12,        // A Symbol (ES6).
-    kSimdValue = 13      // A SIMD value stored in the heap (Proposed ES7).
+    kSymbol = 12        // A Symbol (ES6).
   };
 
   /** Returns node type (see HeapGraphNode::Type). */
diff --git a/include/v8-version.h b/include/v8-version.h
index d848017886..3a9883b975 100644
--- a/include/v8-version.h
+++ b/include/v8-version.h
@@ -11,7 +11,7 @@
 #define V8_MAJOR_VERSION 5
 #define V8_MINOR_VERSION 3
 #define V8_BUILD_NUMBER 332
-#define V8_PATCH_LEVEL 47
+#define V8_PATCH_LEVEL 49
 
 // Use 1 for candidates and 0 otherwise.
 // (Boolean macro values are not supported by all preprocessors.)
diff --git a/include/v8.h b/include/v8.h
index c62a1fd0ca..a608472b57 100644
--- a/include/v8.h
+++ b/include/v8.h
@@ -1928,12 +1928,6 @@ class V8_EXPORT Value : public Data {
    */
   bool IsFloat64Array() const;
 
-  /**
-   * Returns true if this value is a SIMD Float32x4.
-   * This is an experimental feature.
-   */
-  bool IsFloat32x4() const;
-
   /**
    * Returns true if this value is a DataView.
    * This is an experimental feature.
@@ -7534,11 +7528,11 @@ class Internals {
   static const int kNodeIsPartiallyDependentShift = 4;
   static const int kNodeIsActiveShift = 4;
 
-  static const int kJSObjectType = 0xb7;
-  static const int kJSApiObjectType = 0xb6;
+  static const int kJSObjectType = 0xb6;
+  static const int kJSApiObjectType = 0xb5;
   static const int kFirstNonstringType = 0x80;
-  static const int kOddballType = 0x83;
-  static const int kForeignType = 0x87;
+  static const int kOddballType = 0x82;
+  static const int kForeignType = 0x86;
 
   static const int kUndefinedOddballKind = 5;
   static const int kNullOddballKind = 3;
diff --git a/src/arm/assembler-arm-inl.h b/src/arm/assembler-arm-inl.h
index 9d1d0e0d0d..52ebe32b36 100644
--- a/src/arm/assembler-arm-inl.h
+++ b/src/arm/assembler-arm-inl.h
@@ -48,7 +48,7 @@ namespace internal {
 
 
 bool CpuFeatures::SupportsCrankshaft() { return IsSupported(VFP3); }
-bool CpuFeatures::SupportsSIMD128InCrankshaft() { return false; }
+
 
 int DoubleRegister::NumRegisters() {
   return CpuFeatures::IsSupported(VFP32DREGS) ? 32 : 16;
diff --git a/src/arm/assembler-arm.h b/src/arm/assembler-arm.h
index d75cf7cf8e..461d5b0aa6 100644
--- a/src/arm/assembler-arm.h
+++ b/src/arm/assembler-arm.h
@@ -284,34 +284,6 @@ struct QwNeonRegister {
     return r;
   }
 
-  static int ToAllocationIndex(QwNeonRegister reg) {
-    DCHECK(reg.code() < kMaxNumRegisters);
-    return reg.code();
-  }
-
-  static const char* AllocationIndexToString(int index) {
-    DCHECK(index >= 0 && index < kMaxNumRegisters);
-    const char* const names[] = {
-      "q0",
-      "q1",
-      "q2",
-      "q3",
-      "q4",
-      "q5",
-      "q6",
-      "q7",
-      "q8",
-      "q9",
-      "q10",
-      "q11",
-      "q12",
-      "q13",
-      "q14",
-      "q15",
-    };
-    return names[index];
-  }
-
   bool is_valid() const {
     return (0 <= reg_code) && (reg_code < kMaxNumRegisters);
   }
@@ -332,7 +304,6 @@ struct QwNeonRegister {
 
 
 typedef QwNeonRegister QuadRegister;
-typedef QwNeonRegister SIMD128Register;
 
 typedef QwNeonRegister Simd128Register;
 
diff --git a/src/arm/code-stubs-arm.cc b/src/arm/code-stubs-arm.cc
index 0ef31d7dfe..afaed13e30 100644
--- a/src/arm/code-stubs-arm.cc
+++ b/src/arm/code-stubs-arm.cc
@@ -206,9 +206,6 @@ static void EmitIdenticalObjectComparison(MacroAssembler* masm, Label* slow,
     // Call runtime on identical symbols since we need to throw a TypeError.
     __ cmp(r4, Operand(SYMBOL_TYPE));
     __ b(eq, slow);
-    // Call runtime on identical SIMD values since we must throw a TypeError.
-    __ cmp(r4, Operand(SIMD128_VALUE_TYPE));
-    __ b(eq, slow);
   } else {
     __ CompareObjectType(r0, r4, r4, HEAP_NUMBER_TYPE);
     __ b(eq, &heap_number);
@@ -219,9 +216,6 @@ static void EmitIdenticalObjectComparison(MacroAssembler* masm, Label* slow,
       // Call runtime on identical symbols since we need to throw a TypeError.
       __ cmp(r4, Operand(SYMBOL_TYPE));
       __ b(eq, slow);
-      // Call runtime on identical SIMD values since we must throw a TypeError.
-      __ cmp(r4, Operand(SIMD128_VALUE_TYPE));
-      __ b(eq, slow);
       // Normally here we fall through to return_equal, but undefined is
       // special: (undefined == undefined) == true, but
       // (undefined <= undefined) == false!  See ECMAScript 11.8.5.
diff --git a/src/arm/deoptimizer-arm.cc b/src/arm/deoptimizer-arm.cc
index 00d102b4c8..c569e6615b 100644
--- a/src/arm/deoptimizer-arm.cc
+++ b/src/arm/deoptimizer-arm.cc
@@ -92,9 +92,8 @@ void Deoptimizer::SetPlatformCompiledStubRegisters(
   output_frame->SetRegister(r1.code(), handler);
 }
 
-void Deoptimizer::CopyDoubleRegisters(FrameDescription* output_frame) {}
 
-void Deoptimizer::CopySIMD128Registers(FrameDescription* output_frame) {
+void Deoptimizer::CopyDoubleRegisters(FrameDescription* output_frame) {
   for (int i = 0; i < DwVfpRegister::kMaxNumRegisters; ++i) {
     double double_value = input_->GetDoubleRegister(i);
     output_frame->SetDoubleRegister(i, double_value);
@@ -186,11 +185,12 @@ void Deoptimizer::TableEntryGenerator::Generate() {
 
   // Copy VFP registers to
   // double_registers_[DoubleRegister::kMaxNumAllocatableRegisters]
-  int double_regs_offset = FrameDescription::simd128_registers_offset();
+  int double_regs_offset = FrameDescription::double_registers_offset();
   const RegisterConfiguration* config = RegisterConfiguration::Crankshaft();
-  for (int i = 0; i < DwVfpRegister::kMaxNumRegisters; ++i) {
-    int dst_offset = i * kDoubleSize + double_regs_offset;
-    int src_offset = i * kDoubleSize + kNumberOfRegisters * kPointerSize;
+  for (int i = 0; i < config->num_allocatable_double_registers(); ++i) {
+    int code = config->GetAllocatableDoubleCode(i);
+    int dst_offset = code * kDoubleSize + double_regs_offset;
+    int src_offset = code * kDoubleSize + kNumberOfRegisters * kPointerSize;
     __ vldr(d0, sp, src_offset);
     __ vstr(d0, r1, dst_offset);
   }
@@ -366,33 +366,6 @@ void FrameDescription::SetCallerConstantPool(unsigned offset, intptr_t value) {
   SetFrameSlot(offset, value);
 }
 
-double RegisterValues::GetDoubleRegister(unsigned n) const {
-  DCHECK(n < 2 * arraysize(simd128_registers_));
-  return simd128_registers_[n / 2].d[n % 2];
-}
-
-void RegisterValues::SetDoubleRegister(unsigned n, double value) {
-  DCHECK(n < 2 * arraysize(simd128_registers_));
-  simd128_registers_[n / 2].d[n % 2] = value;
-}
-
-simd128_value_t RegisterValues::GetSIMD128Register(unsigned n) const {
-  DCHECK(n < arraysize(simd128_registers_));
-  return simd128_registers_[n];
-}
-
-void RegisterValues::SetSIMD128Register(unsigned n, simd128_value_t value) {
-  DCHECK(n < arraysize(simd128_registers_));
-  simd128_registers_[n] = value;
-}
-
-int FrameDescription::double_registers_offset() {
-  return OFFSET_OF(FrameDescription, register_values_.simd128_registers_);
-}
-
-int FrameDescription::simd128_registers_offset() {
-  return OFFSET_OF(FrameDescription, register_values_.simd128_registers_);
-}
 
 #undef __
 
diff --git a/src/arm/interface-descriptors-arm.cc b/src/arm/interface-descriptors-arm.cc
index fa0c040f3d..62b648c232 100644
--- a/src/arm/interface-descriptors-arm.cc
+++ b/src/arm/interface-descriptors-arm.cc
@@ -240,13 +240,6 @@ void AllocateHeapNumberDescriptor::InitializePlatformSpecific(
   data->InitializePlatformSpecific(0, nullptr, nullptr);
 }
 
-#define SIMD128_ALLOC_DESC(TYPE, Type, type, lane_count, lane_type) \
-  void Allocate##Type##Descriptor::InitializePlatformSpecific(      \
-      CallInterfaceDescriptorData* data) {                          \
-    data->InitializePlatformSpecific(0, nullptr, nullptr);          \
-  }
-SIMD128_TYPES(SIMD128_ALLOC_DESC)
-#undef SIMD128_ALLOC_DESC
 
 void ArrayNoArgumentConstructorDescriptor::InitializePlatformSpecific(
     CallInterfaceDescriptorData* data) {
diff --git a/src/arm64/assembler-arm64-inl.h b/src/arm64/assembler-arm64-inl.h
index 4121485799..8e467713c0 100644
--- a/src/arm64/assembler-arm64-inl.h
+++ b/src/arm64/assembler-arm64-inl.h
@@ -15,7 +15,7 @@ namespace internal {
 
 
 bool CpuFeatures::SupportsCrankshaft() { return true; }
-bool CpuFeatures::SupportsSIMD128InCrankshaft() { return false; }
+
 
 void RelocInfo::apply(intptr_t delta) {
   // On arm64 only internal references need extra work.
diff --git a/src/arm64/assembler-arm64.h b/src/arm64/assembler-arm64.h
index 423bfd05f9..cc26278c97 100644
--- a/src/arm64/assembler-arm64.h
+++ b/src/arm64/assembler-arm64.h
@@ -252,30 +252,6 @@ struct FPRegister : public CPURegister {
   // End of V8 compatibility section -----------------------
 };
 
-struct SIMD128Register {
-  static const int kMaxNumRegisters = 0;
-
-  static int ToAllocationIndex(SIMD128Register reg) {
-    UNIMPLEMENTED();
-    return -1;
-  }
-
-  static const char* AllocationIndexToString(int index) {
-    UNIMPLEMENTED();
-    return NULL;
-  }
-
-  static SIMD128Register from_code(int code) {
-    UNIMPLEMENTED();
-    SIMD128Register result = {-1};
-    return result;
-  }
-  int code() const {
-    UNIMPLEMENTED();
-    return -1;
-  }
-  int code_;
-};
 
 STATIC_ASSERT(sizeof(CPURegister) == sizeof(Register));
 STATIC_ASSERT(sizeof(CPURegister) == sizeof(FPRegister));
diff --git a/src/arm64/code-stubs-arm64.cc b/src/arm64/code-stubs-arm64.cc
index 6b0306845c..4380c93b46 100644
--- a/src/arm64/code-stubs-arm64.cc
+++ b/src/arm64/code-stubs-arm64.cc
@@ -174,9 +174,6 @@ static void EmitIdenticalObjectComparison(MacroAssembler* masm, Register left,
     // Call runtime on identical symbols since we need to throw a TypeError.
     __ Cmp(right_type, SYMBOL_TYPE);
     __ B(eq, slow);
-    // Call runtime on identical SIMD values since we must throw a TypeError.
-    __ Cmp(right_type, SIMD128_VALUE_TYPE);
-    __ B(eq, slow);
   } else if (cond == eq) {
     __ JumpIfHeapNumber(right, &heap_number);
   } else {
@@ -188,9 +185,6 @@ static void EmitIdenticalObjectComparison(MacroAssembler* masm, Register left,
     // Call runtime on identical symbols since we need to throw a TypeError.
     __ Cmp(right_type, SYMBOL_TYPE);
     __ B(eq, slow);
-    // Call runtime on identical SIMD values since we must throw a TypeError.
-    __ Cmp(right_type, SIMD128_VALUE_TYPE);
-    __ B(eq, slow);
     // Normally here we fall through to return_equal, but undefined is
     // special: (undefined == undefined) == true, but
     // (undefined <= undefined) == false!  See ECMAScript 11.8.5.
diff --git a/src/arm64/deoptimizer-arm64.cc b/src/arm64/deoptimizer-arm64.cc
index 7332db13e7..c1d04ac3fb 100644
--- a/src/arm64/deoptimizer-arm64.cc
+++ b/src/arm64/deoptimizer-arm64.cc
@@ -83,7 +83,7 @@ void Deoptimizer::CopyDoubleRegisters(FrameDescription* output_frame) {
   }
 }
 
-void Deoptimizer::CopySIMD128Registers(FrameDescription* output_frame) {}
+
 
 #define __ masm()->
 
@@ -341,34 +341,6 @@ void FrameDescription::SetCallerConstantPool(unsigned offset, intptr_t value) {
   UNREACHABLE();
 }
 
-double RegisterValues::GetDoubleRegister(unsigned n) const {
-  DCHECK(n < arraysize(double_registers_));
-  return double_registers_[n];
-}
-
-void RegisterValues::SetDoubleRegister(unsigned n, double value) {
-  DCHECK(n < arraysize(double_registers_));
-  double_registers_[n] = value;
-}
-
-simd128_value_t RegisterValues::GetSIMD128Register(unsigned n) const {
-  UNREACHABLE();
-  simd128_value_t value;
-  return value;
-}
-
-void RegisterValues::SetSIMD128Register(unsigned n, simd128_value_t value) {
-  UNREACHABLE();
-}
-
-int FrameDescription::double_registers_offset() {
-  return OFFSET_OF(FrameDescription, register_values_.double_registers_);
-}
-
-int FrameDescription::simd128_registers_offset() {
-  UNREACHABLE();
-  return -1;
-}
 
 #undef __
 
diff --git a/src/arm64/interface-descriptors-arm64.cc b/src/arm64/interface-descriptors-arm64.cc
index 573d89e25b..b0ffb03bd1 100644
--- a/src/arm64/interface-descriptors-arm64.cc
+++ b/src/arm64/interface-descriptors-arm64.cc
@@ -265,13 +265,6 @@ void AllocateHeapNumberDescriptor::InitializePlatformSpecific(
   data->InitializePlatformSpecific(0, nullptr, nullptr);
 }
 
-#define SIMD128_ALLOC_DESC(TYPE, Type, type, lane_count, lane_type) \
-  void Allocate##Type##Descriptor::InitializePlatformSpecific(      \
-      CallInterfaceDescriptorData* data) {                          \
-    data->InitializePlatformSpecific(0, nullptr, nullptr);          \
-  }
-SIMD128_TYPES(SIMD128_ALLOC_DESC)
-#undef SIMD128_ALLOC_DESC
 
 void ArrayNoArgumentConstructorDescriptor::InitializePlatformSpecific(
     CallInterfaceDescriptorData* data) {
diff --git a/src/assembler.h b/src/assembler.h
index 9f6a79c340..0c2b7e8e21 100644
--- a/src/assembler.h
+++ b/src/assembler.h
@@ -224,7 +224,6 @@ class CpuFeatures : public AllStatic {
   }
 
   static inline bool SupportsCrankshaft();
-  static inline bool SupportsSIMD128InCrankshaft();
 
   static inline unsigned icache_line_size() {
     DCHECK(icache_line_size_ != 0);
diff --git a/src/ast/scopes.cc b/src/ast/scopes.cc
index bf85c46674..77c5d628f7 100644
--- a/src/ast/scopes.cc
+++ b/src/ast/scopes.cc
@@ -1134,7 +1134,7 @@ bool Scope::ResolveVariable(ParseInfo* info, VariableProxy* proxy,
   Variable* var = LookupRecursive(proxy, &binding_kind, factory);
 
 #ifdef DEBUG
-  if (info->script_is_native() && var != 0x0) {
+  if (info->script_is_native()) {
     // To avoid polluting the global object in native scripts
     //  - Variables must not be allocated to the global scope.
     CHECK_NOT_NULL(outer_scope());
diff --git a/src/bootstrapper.cc b/src/bootstrapper.cc
index 23a4445ba6..82936d38cb 100644
--- a/src/bootstrapper.cc
+++ b/src/bootstrapper.cc
@@ -224,7 +224,6 @@ class Genesis BASE_EMBEDDED {
   bool InstallDebuggerNatives();
   void InstallBuiltinFunctionIds();
   void InstallExperimentalBuiltinFunctionIds();
-  void InstallExperimentalSIMDBuiltinFunctionIds();
   void InitializeNormalizedMapCaches();
 
   enum ExtensionTraversalState {
@@ -2737,37 +2736,6 @@ void Genesis::InitializeGlobal_harmony_sharedarraybuffer() {
 }
 
 
-void Genesis::InitializeGlobal_harmony_simd() {
-  if (!FLAG_harmony_simd) return;
-
-  Handle<JSGlobalObject> global(
-      JSGlobalObject::cast(native_context()->global_object()));
-  Isolate* isolate = global->GetIsolate();
-  Factory* factory = isolate->factory();
-
-  Handle<String> name = factory->InternalizeUtf8String("SIMD");
-  Handle<JSFunction> cons = factory->NewFunction(name);
-  JSFunction::SetInstancePrototype(
-      cons,
-      Handle<Object>(native_context()->initial_object_prototype(), isolate));
-  cons->shared()->set_instance_class_name(*name);
-  Handle<JSObject> simd_object = factory->NewJSObject(cons, TENURED);
-  DCHECK(simd_object->IsJSObject());
-  JSObject::AddProperty(global, name, simd_object, DONT_ENUM);
-
-// Install SIMD type functions. Set the instance class names since
-// InstallFunction only does this when we install on the JSGlobalObject.
-#define SIMD128_INSTALL_FUNCTION(TYPE, Type, type, lane_count, lane_type) \
-  Handle<JSFunction> type##_function = InstallFunction(                   \
-      simd_object, #Type, JS_VALUE_TYPE, JSValue::kSize,                  \
-      isolate->initial_object_prototype(), Builtins::kIllegal);           \
-  native_context()->set_##type##_function(*type##_function);              \
-  type##_function->shared()->set_instance_class_name(*factory->Type##_string());
-  SIMD128_TYPES(SIMD128_INSTALL_FUNCTION)
-#undef SIMD128_INSTALL_FUNCTION
-}
-
-
 void Genesis::InitializeGlobal_harmony_object_values_entries() {
   if (!FLAG_harmony_object_values_entries) return;
 
@@ -3247,8 +3215,6 @@ bool Genesis::InstallExperimentalNatives() {
   static const char* harmony_tailcalls_natives[] = {nullptr};
   static const char* harmony_sharedarraybuffer_natives[] = {
       "native harmony-sharedarraybuffer.js", "native harmony-atomics.js", NULL};
-  static const char* harmony_simd_natives[] = {"native harmony-simd.js",
-                                               nullptr};
   static const char* harmony_do_expressions_natives[] = {nullptr};
   static const char* harmony_for_in_natives[] = {nullptr};
   static const char* harmony_regexp_lookbehind_natives[] = {nullptr};
@@ -3285,9 +3251,6 @@ bool Genesis::InstallExperimentalNatives() {
         if (!Bootstrapper::CompileExperimentalBuiltin(isolate(), i)) {        \
           return false;                                                       \
         }                                                                     \
-        if (id##_natives[j] == "native harmony-simd.js") {                    \
-          InstallExperimentalSIMDBuiltinFunctionIds();                        \
-        }                                                                     \
       }                                                                       \
     }                                                                         \
   }
@@ -3340,32 +3303,6 @@ bool Genesis::InstallDebuggerNatives() {
   return CallUtilsFunction(isolate(), "PostDebug");
 }
 
-static Handle<JSObject> ResolveBuiltinSIMDIdHolder(
-    Handle<Context> native_context, const char* holder_expr) {
-  Isolate* isolate = native_context->GetIsolate();
-  Factory* factory = isolate->factory();
-  Handle<JSGlobalObject> global(native_context->global_object());
-  Handle<Object> holder = global;
-  char* name = const_cast<char*>(holder_expr);
-  char* period_pos = strchr(name, '.');
-  while (period_pos != NULL) {
-    Vector<const char> property(name, static_cast<int>(period_pos - name));
-    Handle<String> property_string = factory->InternalizeUtf8String(property);
-    DCHECK(!property_string.is_null());
-    holder = Object::GetProperty(holder, property_string).ToHandleChecked();
-    if (strcmp(".prototype", period_pos) == 0) {
-      Handle<JSFunction> function = Handle<JSFunction>::cast(holder);
-      return Handle<JSObject>(JSObject::cast(function->prototype()));
-    } else {
-      name = period_pos + 1;
-      period_pos = strchr(name, '.');
-    }
-  }
-
-  return Handle<JSObject>::cast(
-      Object::GetPropertyOrElement(holder, factory->InternalizeUtf8String(name))
-          .ToHandleChecked());
-}
 
 static void InstallBuiltinFunctionId(Handle<JSObject> holder,
                                      const char* function_name,
@@ -3424,44 +3361,6 @@ void Genesis::InstallExperimentalBuiltinFunctionIds() {
 
 #undef INSTALL_BUILTIN_ID
 
-void Genesis::InstallExperimentalSIMDBuiltinFunctionIds() {
-  HandleScope scope(isolate());
-#define INSTALL_BUILTIN_ID(holder_expr, fun_name, name)             \
-  {                                                                 \
-    Handle<JSObject> holder =                                       \
-        ResolveBuiltinSIMDIdHolder(native_context(), #holder_expr); \
-    BuiltinFunctionId id = k##name;                                 \
-    InstallBuiltinFunctionId(holder, #fun_name, id);                \
-  }
-  TYPED_ARRAYS_SIMD_LOAD_OPERATIONS(INSTALL_BUILTIN_ID)
-  TYPED_ARRAYS_SIMD_STORE_OPERATIONS(INSTALL_BUILTIN_ID)
-#define INSTALL_SIMD_UNARY_FUNCTION_ID(p1, p2, p3, p4, p5) \
-  INSTALL_BUILTIN_ID(p1, p2, p3)
-  SIMD_UNARY_OPERATIONS(INSTALL_SIMD_UNARY_FUNCTION_ID)
-#undef INSTALL_SIMD_UNARY_FUNCTION_ID
-#define INSTALL_SIMD_BINARY_FUNCTION_ID(p1, p2, p3, p4, p5, p6) \
-  INSTALL_BUILTIN_ID(p1, p2, p3)
-  SIMD_BINARY_OPERATIONS(INSTALL_SIMD_BINARY_FUNCTION_ID)
-#undef INSTALL_SIMD_BINARY_FUNCTION_ID
-#define INSTALL_SIMD_TERNARY_FUNCTION_ID(p1, p2, p3, p4, p5, p6, p7) \
-  INSTALL_BUILTIN_ID(p1, p2, p3)
-  SIMD_TERNARY_OPERATIONS(INSTALL_SIMD_TERNARY_FUNCTION_ID)
-#undef INSTALL_SIMD_TERNARY_FUNCTION_ID
-#define INSTALL_SIMD_QUARTERNARY_FUNCTION_ID(p1, p2, p3, p4, p5, p6, p7, p8) \
-  INSTALL_BUILTIN_ID(p1, p2, p3)
-  SIMD_QUARTERNARY_OPERATIONS(INSTALL_SIMD_QUARTERNARY_FUNCTION_ID)
-#undef INSTALL_SIMD_QUARTERNARY_FUNCTION_ID
-#define INSTALL_SIMD_QUINARY_FUNCTION_ID(p1, p2, p3, p4, p5, p6, p7, p8, p9) \
-  INSTALL_BUILTIN_ID(p1, p2, p3)
-  SIMD_QUINARY_OPERATIONS(INSTALL_SIMD_QUINARY_FUNCTION_ID)
-#undef INSTALL_SIMD_QUINARY_FUNCTION_ID
-#define INSTALL_SIMD_SENARY_FUNCTION_ID(p1, p2, p3, p4, p5, p6, p7, p8, p9, \
-                                        p10)                                \
-  INSTALL_BUILTIN_ID(p1, p2, p3)
-  SIMD_SENARY_OPERATIONS(INSTALL_SIMD_SENARY_FUNCTION_ID)
-#undef INSTALL_SIMD_SENARY_FUNCTION_ID
-#undef INSTALL_BUILTIN_ID
-}
 
 void Genesis::InitializeNormalizedMapCaches() {
   Handle<NormalizedMapCache> cache = NormalizedMapCache::New(isolate());
diff --git a/src/code-factory.cc b/src/code-factory.cc
index 944f780c04..d0c57d2905 100644
--- a/src/code-factory.cc
+++ b/src/code-factory.cc
@@ -505,14 +505,6 @@ Callable CodeFactory::AllocateHeapNumber(Isolate* isolate) {
   return Callable(stub.GetCode(), stub.GetCallInterfaceDescriptor());
 }
 
-#define SIMD128_ALLOC(TYPE, Type, type, lane_count, lane_type)          \
-  Callable CodeFactory::Allocate##Type(Isolate* isolate) {              \
-    Allocate##Type##Stub stub(isolate);                                 \
-    return Callable(stub.GetCode(), stub.GetCallInterfaceDescriptor()); \
-  }
-SIMD128_TYPES(SIMD128_ALLOC)
-#undef SIMD128_ALLOC
-
 // static
 Callable CodeFactory::ArgumentAdaptor(Isolate* isolate) {
   return Callable(isolate->builtins()->ArgumentsAdaptorTrampoline(),
diff --git a/src/code-factory.h b/src/code-factory.h
index 7fb7bc531f..cbb75dd3a5 100644
--- a/src/code-factory.h
+++ b/src/code-factory.h
@@ -131,10 +131,6 @@ class CodeFactory final {
                                          bool skip_stub_frame = false);
 
   static Callable AllocateHeapNumber(Isolate* isolate);
-#define SIMD128_ALLOC(TYPE, Type, type, lane_count, lane_type) \
-  static Callable Allocate##Type(Isolate* isolate);
-  SIMD128_TYPES(SIMD128_ALLOC)
-#undef SIMD128_ALLOC
 
   static Callable ArgumentAdaptor(Isolate* isolate);
   static Callable Call(Isolate* isolate,
diff --git a/src/code-stubs-hydrogen.cc b/src/code-stubs-hydrogen.cc
index 650e5389a5..b9cf370bee 100644
--- a/src/code-stubs-hydrogen.cc
+++ b/src/code-stubs-hydrogen.cc
@@ -356,15 +356,6 @@ HValue* CodeStubGraphBuilder<TypeofStub>::BuildCodeStub() {
             { Push(Add<HConstant>(factory->function_string())); }
             is_function.Else();
             {
-#define SIMD128_BUILDER_OPEN(TYPE, Type, type, lane_count, lane_type) \
-  IfBuilder is_##type(this);                                          \
-  is_##type.If<HCompareObjectEqAndBranch>(                            \
-      map, Add<HConstant>(factory->type##_map()));                    \
-  is_##type.Then();                                                   \
-  { Push(Add<HConstant>(factory->type##_string())); }                 \
-  is_##type.Else(); {
-              SIMD128_TYPES(SIMD128_BUILDER_OPEN)
-#undef SIMD128_BUILDER_OPEN
               // Is it an undetectable object?
               IfBuilder is_undetectable(this);
               is_undetectable.If<HCompareNumericAndBranch>(
@@ -380,9 +371,6 @@ HValue* CodeStubGraphBuilder<TypeofStub>::BuildCodeStub() {
                 // host objects gives that it is okay to return "object".
                 Push(object_string);
               }
-#define SIMD128_BUILDER_CLOSE(TYPE, Type, type, lane_count, lane_type) }
-              SIMD128_TYPES(SIMD128_BUILDER_CLOSE)
-#undef SIMD128_BUILDER_CLOSE
             }
             is_function.End();
           }
diff --git a/src/code-stubs.cc b/src/code-stubs.cc
index ae3adb7b6f..3966c3eb27 100644
--- a/src/code-stubs.cc
+++ b/src/code-stubs.cc
@@ -477,22 +477,6 @@ void AllocateHeapNumberStub::GenerateAssembly(
   assembler->Return(result);
 }
 
-#define SIMD128_GEN_ASM(TYPE, Type, type, lane_count, lane_type)            \
-  void Allocate##Type##Stub::GenerateAssembly(CodeStubAssembler* assembler) \
-      const {                                                               \
-    compiler::Node* result =                                                \
-        assembler->Allocate(Simd128Value::kSize, CodeStubAssembler::kNone); \
-    compiler::Node* map_offset =                                            \
-        assembler->IntPtrConstant(HeapObject::kMapOffset - kHeapObjectTag); \
-    compiler::Node* map = assembler->IntPtrAdd(result, map_offset);         \
-    assembler->StoreNoWriteBarrier(                                         \
-        MachineRepresentation::kTagged, map,                                \
-        assembler->HeapConstant(isolate()->factory()->type##_map()));       \
-    assembler->Return(result);                                              \
-  }
-SIMD128_TYPES(SIMD128_GEN_ASM)
-#undef SIMD128_GEN_ASM
-
 void StringLengthStub::GenerateAssembly(CodeStubAssembler* assembler) const {
   compiler::Node* value = assembler->Parameter(0);
   compiler::Node* string =
@@ -2299,83 +2283,6 @@ void GenerateEqual_Same(CodeStubAssembler* assembler, compiler::Node* value,
   assembler->Goto(if_equal);
 }
 
-void GenerateEqual_Simd128Value_HeapObject(
-    CodeStubAssembler* assembler, compiler::Node* lhs, compiler::Node* lhs_map,
-    compiler::Node* rhs, compiler::Node* rhs_map,
-    CodeStubAssembler::Label* if_equal, CodeStubAssembler::Label* if_notequal) {
-  typedef CodeStubAssembler::Label Label;
-  typedef compiler::Node Node;
-
-  // Check if {lhs} and {rhs} have the same map.
-  Label if_mapsame(assembler), if_mapnotsame(assembler);
-  assembler->Branch(assembler->WordEqual(lhs_map, rhs_map), &if_mapsame,
-                    &if_mapnotsame);
-
-  assembler->Bind(&if_mapsame);
-  {
-    // Both {lhs} and {rhs} are Simd128Values with the same map, need special
-    // handling for Float32x4 because of NaN comparisons.
-    Label if_float32x4(assembler), if_notfloat32x4(assembler);
-    Node* float32x4_map =
-        assembler->HeapConstant(assembler->factory()->float32x4_map());
-    assembler->Branch(assembler->WordEqual(lhs_map, float32x4_map),
-                      &if_float32x4, &if_notfloat32x4);
-
-    assembler->Bind(&if_float32x4);
-    {
-      // Both {lhs} and {rhs} are Float32x4, compare the lanes individually
-      // using a floating point comparison.
-      for (int offset = Float32x4::kValueOffset - kHeapObjectTag;
-           offset < Float32x4::kSize - kHeapObjectTag;
-           offset += sizeof(float)) {
-        // Load the floating point values for {lhs} and {rhs}.
-        Node* lhs_value = assembler->Load(MachineType::Float32(), lhs,
-                                          assembler->IntPtrConstant(offset));
-        Node* rhs_value = assembler->Load(MachineType::Float32(), rhs,
-                                          assembler->IntPtrConstant(offset));
-
-        // Perform a floating point comparison.
-        Label if_valueequal(assembler), if_valuenotequal(assembler);
-        assembler->Branch(assembler->Float32Equal(lhs_value, rhs_value),
-                          &if_valueequal, &if_valuenotequal);
-        assembler->Bind(&if_valuenotequal);
-        assembler->Goto(if_notequal);
-        assembler->Bind(&if_valueequal);
-      }
-
-      // All 4 lanes match, {lhs} and {rhs} considered equal.
-      assembler->Goto(if_equal);
-    }
-
-    assembler->Bind(&if_notfloat32x4);
-    {
-      // For other Simd128Values we just perform a bitwise comparison.
-      for (int offset = Simd128Value::kValueOffset - kHeapObjectTag;
-           offset < Simd128Value::kSize - kHeapObjectTag;
-           offset += kPointerSize) {
-        // Load the word values for {lhs} and {rhs}.
-        Node* lhs_value = assembler->Load(MachineType::Pointer(), lhs,
-                                          assembler->IntPtrConstant(offset));
-        Node* rhs_value = assembler->Load(MachineType::Pointer(), rhs,
-                                          assembler->IntPtrConstant(offset));
-
-        // Perform a bitwise word-comparison.
-        Label if_valueequal(assembler), if_valuenotequal(assembler);
-        assembler->Branch(assembler->WordEqual(lhs_value, rhs_value),
-                          &if_valueequal, &if_valuenotequal);
-        assembler->Bind(&if_valuenotequal);
-        assembler->Goto(if_notequal);
-        assembler->Bind(&if_valueequal);
-      }
-
-      // Bitwise comparison succeeded, {lhs} and {rhs} considered equal.
-      assembler->Goto(if_equal);
-    }
-  }
-
-  assembler->Bind(&if_mapnotsame);
-  assembler->Goto(if_notequal);
-}
 
 // ES6 section 7.2.12 Abstract Equality Comparison
 compiler::Node* GenerateEqual(CodeStubAssembler* assembler, ResultMode mode,
@@ -2550,7 +2457,7 @@ compiler::Node* GenerateEqual(CodeStubAssembler* assembler, ResultMode mode,
         assembler->Bind(&if_rhsisnotsmi);
         {
           Label if_lhsisstring(assembler), if_lhsisnumber(assembler),
-              if_lhsissymbol(assembler), if_lhsissimd128value(assembler),
+              if_lhsissymbol(assembler),
               if_lhsisoddball(assembler), if_lhsisreceiver(assembler);
 
           // Both {lhs} and {rhs} are HeapObjects, load their maps
@@ -2563,7 +2470,7 @@ compiler::Node* GenerateEqual(CodeStubAssembler* assembler, ResultMode mode,
           Node* rhs_instance_type = assembler->LoadMapInstanceType(rhs_map);
 
           // Dispatch based on the instance type of {lhs}.
-          size_t const kNumCases = FIRST_NONSTRING_TYPE + 4;
+          size_t const kNumCases = FIRST_NONSTRING_TYPE + 3;
           Label* case_labels[kNumCases];
           int32_t case_values[kNumCases];
           for (int32_t i = 0; i < FIRST_NONSTRING_TYPE; ++i) {
@@ -2574,10 +2481,8 @@ compiler::Node* GenerateEqual(CodeStubAssembler* assembler, ResultMode mode,
           case_values[FIRST_NONSTRING_TYPE + 0] = HEAP_NUMBER_TYPE;
           case_labels[FIRST_NONSTRING_TYPE + 1] = &if_lhsissymbol;
           case_values[FIRST_NONSTRING_TYPE + 1] = SYMBOL_TYPE;
-          case_labels[FIRST_NONSTRING_TYPE + 2] = &if_lhsissimd128value;
-          case_values[FIRST_NONSTRING_TYPE + 2] = SIMD128_VALUE_TYPE;
-          case_labels[FIRST_NONSTRING_TYPE + 3] = &if_lhsisoddball;
-          case_values[FIRST_NONSTRING_TYPE + 3] = ODDBALL_TYPE;
+          case_labels[FIRST_NONSTRING_TYPE + 2] = &if_lhsisoddball;
+          case_values[FIRST_NONSTRING_TYPE + 2] = ODDBALL_TYPE;
           assembler->Switch(lhs_instance_type, &if_lhsisreceiver, case_values,
                             case_labels, arraysize(case_values));
           for (int32_t i = 0; i < FIRST_NONSTRING_TYPE; ++i) {
@@ -2778,53 +2683,6 @@ compiler::Node* GenerateEqual(CodeStubAssembler* assembler, ResultMode mode,
             }
           }
 
-          assembler->Bind(&if_lhsissimd128value);
-          {
-            // Check if the {rhs} is also a Simd128Value.
-            Label if_rhsissimd128value(assembler),
-                if_rhsisnotsimd128value(assembler);
-            assembler->Branch(
-                assembler->Word32Equal(lhs_instance_type, rhs_instance_type),
-                &if_rhsissimd128value, &if_rhsisnotsimd128value);
-
-            assembler->Bind(&if_rhsissimd128value);
-            {
-              // Both {lhs} and {rhs} is a Simd128Value.
-              GenerateEqual_Simd128Value_HeapObject(assembler, lhs, lhs_map,
-                                                    rhs, rhs_map, &if_equal,
-                                                    &if_notequal);
-            }
-
-            assembler->Bind(&if_rhsisnotsimd128value);
-            {
-              // Check if the {rhs} is a JSReceiver.
-              Label if_rhsisreceiver(assembler), if_rhsisnotreceiver(assembler);
-              STATIC_ASSERT(LAST_TYPE == LAST_JS_RECEIVER_TYPE);
-              assembler->Branch(
-                  assembler->Int32LessThanOrEqual(
-                      assembler->Int32Constant(FIRST_JS_RECEIVER_TYPE),
-                      rhs_instance_type),
-                  &if_rhsisreceiver, &if_rhsisnotreceiver);
-
-              assembler->Bind(&if_rhsisreceiver);
-              {
-                // The {lhs} is a Primitive and the {rhs} is a JSReceiver.
-                // Swapping {lhs} and {rhs} is not observable and doesn't
-                // matter for the result, so we can just swap them and use
-                // the JSReceiver handling below (for {lhs} being a JSReceiver).
-                var_lhs.Bind(rhs);
-                var_rhs.Bind(lhs);
-                assembler->Goto(&loop);
-              }
-
-              assembler->Bind(&if_rhsisnotreceiver);
-              {
-                // The {rhs} is some other Primitive.
-                assembler->Goto(&if_notequal);
-              }
-            }
-          }
-
           assembler->Bind(&if_lhsisreceiver);
           {
             // Check if the {rhs} is also a JSReceiver.
@@ -3103,26 +2961,6 @@ compiler::Node* GenerateStrictEqual(CodeStubAssembler* assembler,
 
           assembler->Bind(&if_lhsisnotstring);
           {
-            // Check if {lhs} is a Simd128Value.
-            Label if_lhsissimd128value(assembler),
-                if_lhsisnotsimd128value(assembler);
-            assembler->Branch(assembler->Word32Equal(
-                                  lhs_instance_type,
-                                  assembler->Int32Constant(SIMD128_VALUE_TYPE)),
-                              &if_lhsissimd128value, &if_lhsisnotsimd128value);
-
-            assembler->Bind(&if_lhsissimd128value);
-            {
-              // Load the map of {rhs}.
-              Node* rhs_map = assembler->LoadMap(rhs);
-
-              // Check if {rhs} is also a Simd128Value that is equal to {lhs}.
-              GenerateEqual_Simd128Value_HeapObject(assembler, lhs, lhs_map,
-                                                    rhs, rhs_map, &if_equal,
-                                                    &if_notequal);
-            }
-
-            assembler->Bind(&if_lhsisnotsimd128value);
             assembler->Goto(&if_notequal);
           }
         }
@@ -4245,15 +4083,6 @@ void AllocateHeapNumberStub::InitializeDescriptor(
 }
 
 
-#define SIMD128_INIT_DESC(TYPE, Type, type, lane_count, lane_type) \
-  void Allocate##Type##Stub::InitializeDescriptor(                 \
-      CodeStubDescriptor* descriptor) {                            \
-    descriptor->Initialize(                                        \
-        Runtime::FunctionForId(Runtime::kCreate##Type)->entry);    \
-  }
-SIMD128_TYPES(SIMD128_INIT_DESC)
-#undef SIMD128_INIT_DESC
-
 void ToBooleanICStub::InitializeDescriptor(CodeStubDescriptor* descriptor) {
   descriptor->Initialize(FUNCTION_ADDR(Runtime_ToBooleanIC_Miss));
   descriptor->SetMissHandler(ExternalReference(
@@ -4503,7 +4332,6 @@ std::ostream& operator<<(std::ostream& os, const ToBooleanICStub::Types& s) {
   if (s.Contains(ToBooleanICStub::STRING)) p.Add("String");
   if (s.Contains(ToBooleanICStub::SYMBOL)) p.Add("Symbol");
   if (s.Contains(ToBooleanICStub::HEAP_NUMBER)) p.Add("HeapNumber");
-  if (s.Contains(ToBooleanICStub::SIMD_VALUE)) p.Add("SimdValue");
   return os << ")";
 }
 
@@ -4536,9 +4364,6 @@ bool ToBooleanICStub::Types::UpdateStatus(Isolate* isolate,
     Add(HEAP_NUMBER);
     double value = HeapNumber::cast(*object)->value();
     return value != 0 && !std::isnan(value);
-  } else if (object->IsSimd128Value()) {
-    Add(SIMD_VALUE);
-    return true;
   } else {
     // We should never see an internal object at runtime here!
     UNREACHABLE();
@@ -4550,8 +4375,7 @@ bool ToBooleanICStub::Types::NeedsMap() const {
   return Contains(ToBooleanICStub::SPEC_OBJECT) ||
          Contains(ToBooleanICStub::STRING) ||
          Contains(ToBooleanICStub::SYMBOL) ||
-         Contains(ToBooleanICStub::HEAP_NUMBER) ||
-         Contains(ToBooleanICStub::SIMD_VALUE);
+         Contains(ToBooleanICStub::HEAP_NUMBER);
 }
 
 
diff --git a/src/code-stubs.h b/src/code-stubs.h
index 85b0883db8..d04462f2d2 100644
--- a/src/code-stubs.h
+++ b/src/code-stubs.h
@@ -88,16 +88,6 @@ namespace internal {
   V(LoadGlobalIC)                           \
   /* TurboFanCodeStubs */                   \
   V(AllocateHeapNumber)                     \
-  V(AllocateFloat32x4)                      \
-  V(AllocateInt32x4)                        \
-  V(AllocateUint32x4)                       \
-  V(AllocateBool32x4)                       \
-  V(AllocateInt16x8)                        \
-  V(AllocateUint16x8)                       \
-  V(AllocateBool16x8)                       \
-  V(AllocateInt8x16)                        \
-  V(AllocateUint8x16)                       \
-  V(AllocateBool8x16)                       \
   V(ArrayNoArgumentConstructor)             \
   V(ArraySingleArgumentConstructor)         \
   V(ArrayNArgumentsConstructor)             \
@@ -2744,20 +2734,6 @@ class AllocateHeapNumberStub : public TurboFanCodeStub {
   DEFINE_CODE_STUB(AllocateHeapNumber, TurboFanCodeStub);
 };
 
-#define SIMD128_ALLOC_STUB(TYPE, Type, type, lane_count, lane_type)     \
-  class Allocate##Type##Stub : public TurboFanCodeStub {                \
-   public:                                                              \
-    explicit Allocate##Type##Stub(Isolate* isolate)                     \
-        : TurboFanCodeStub(isolate) {}                                  \
-                                                                        \
-    void InitializeDescriptor(CodeStubDescriptor* descriptor) override; \
-    void GenerateAssembly(CodeStubAssembler* assembler) const override; \
-                                                                        \
-    DEFINE_CALL_INTERFACE_DESCRIPTOR(Allocate##Type);                   \
-    DEFINE_CODE_STUB(Allocate##Type, TurboFanCodeStub);                 \
-  };
-SIMD128_TYPES(SIMD128_ALLOC_STUB)
-#undef SIMD128_ALLOC_STUB
 
 class CommonArrayConstructorStub : public TurboFanCodeStub {
  protected:
@@ -2919,7 +2895,6 @@ class ToBooleanICStub : public HydrogenCodeStub {
     STRING,
     SYMBOL,
     HEAP_NUMBER,
-    SIMD_VALUE,
     NUMBER_OF_TYPES
   };
 
diff --git a/src/compiler.cc b/src/compiler.cc
index 2a0eda0a55..f23ab3f986 100644
--- a/src/compiler.cc
+++ b/src/compiler.cc
@@ -473,9 +473,6 @@ bool GenerateUnoptimizedCode(CompilationInfo* info) {
   if (FLAG_validate_asm && info->scope()->asm_module()) {
     AsmTyper typer(info->isolate(), info->zone(), *(info->script()),
                    info->literal());
-    if (FLAG_enable_simd_asmjs) {
-      typer.set_allow_simd(true);
-    }
     if (!typer.Validate()) {
       DCHECK(!info->isolate()->has_pending_exception());
       PrintF("Validation of asm.js module failed: %s", typer.error_message());
diff --git a/src/compiler/js-typed-lowering.cc b/src/compiler/js-typed-lowering.cc
index fcfe1345a1..f23461a3ae 100644
--- a/src/compiler/js-typed-lowering.cc
+++ b/src/compiler/js-typed-lowering.cc
@@ -737,7 +737,7 @@ Reduction JSTypedLowering::ReduceJSStrictEqual(Node* node, bool invert) {
       return Replace(replacement);
     }
   }
-  if (r.OneInputCannotBe(Type::NumberOrSimdOrString())) {
+  if (r.OneInputCannotBe(Type::NumberOrString())) {
     // For values with canonical representation (i.e. neither String, nor
     // Simd128Value nor Number) an empty type intersection means the values
     // cannot be strictly equal.
diff --git a/src/compiler/linkage.cc b/src/compiler/linkage.cc
index 99cfd9ee60..c3b68d656d 100644
--- a/src/compiler/linkage.cc
+++ b/src/compiler/linkage.cc
@@ -45,11 +45,6 @@ MachineType reptyp(Representation representation) {
     case Representation::kNone:
     case Representation::kNumRepresentations:
       break;
-    case Representation::kFloat32x4:
-    case Representation::kInt32x4:
-    case Representation::kBool32x4:
-      // TODO(nhu): fix this in TF implementation.
-      break;
   }
   UNREACHABLE();
   return MachineType::None();
diff --git a/src/compiler/machine-operator.cc b/src/compiler/machine-operator.cc
index 3662d0ab59..0e98606e57 100644
--- a/src/compiler/machine-operator.cc
+++ b/src/compiler/machine-operator.cc
@@ -188,178 +188,6 @@ MachineRepresentation AtomicStoreRepresentationOf(Operator const* op) {
   V(Word32PairShl, Operator::kNoProperties, 3, 0, 2)                          \
   V(Word32PairShr, Operator::kNoProperties, 3, 0, 2)                          \
   V(Word32PairSar, Operator::kNoProperties, 3, 0, 2)                          \
-  V(CreateFloat32x4, Operator::kNoProperties, 4, 0, 1)                        \
-  V(Float32x4ExtractLane, Operator::kNoProperties, 2, 0, 1)                   \
-  V(Float32x4ReplaceLane, Operator::kNoProperties, 3, 0, 1)                   \
-  V(Float32x4Abs, Operator::kNoProperties, 1, 0, 1)                           \
-  V(Float32x4Neg, Operator::kNoProperties, 1, 0, 1)                           \
-  V(Float32x4Sqrt, Operator::kNoProperties, 1, 0, 1)                          \
-  V(Float32x4RecipApprox, Operator::kNoProperties, 1, 0, 1)                   \
-  V(Float32x4RecipSqrtApprox, Operator::kNoProperties, 1, 0, 1)               \
-  V(Float32x4Add, Operator::kCommutative, 2, 0, 1)                            \
-  V(Float32x4Sub, Operator::kNoProperties, 2, 0, 1)                           \
-  V(Float32x4Mul, Operator::kCommutative, 2, 0, 1)                            \
-  V(Float32x4Div, Operator::kNoProperties, 2, 0, 1)                           \
-  V(Float32x4Min, Operator::kCommutative, 2, 0, 1)                            \
-  V(Float32x4Max, Operator::kCommutative, 2, 0, 1)                            \
-  V(Float32x4MinNum, Operator::kCommutative, 2, 0, 1)                         \
-  V(Float32x4MaxNum, Operator::kCommutative, 2, 0, 1)                         \
-  V(Float32x4Equal, Operator::kCommutative, 2, 0, 1)                          \
-  V(Float32x4NotEqual, Operator::kCommutative, 2, 0, 1)                       \
-  V(Float32x4LessThan, Operator::kNoProperties, 2, 0, 1)                      \
-  V(Float32x4LessThanOrEqual, Operator::kNoProperties, 2, 0, 1)               \
-  V(Float32x4GreaterThan, Operator::kNoProperties, 2, 0, 1)                   \
-  V(Float32x4GreaterThanOrEqual, Operator::kNoProperties, 2, 0, 1)            \
-  V(Float32x4Select, Operator::kNoProperties, 3, 0, 1)                        \
-  V(Float32x4Swizzle, Operator::kNoProperties, 5, 0, 1)                       \
-  V(Float32x4Shuffle, Operator::kNoProperties, 6, 0, 1)                       \
-  V(Float32x4FromInt32x4, Operator::kNoProperties, 1, 0, 1)                   \
-  V(Float32x4FromUint32x4, Operator::kNoProperties, 1, 0, 1)                  \
-  V(CreateInt32x4, Operator::kNoProperties, 4, 0, 1)                          \
-  V(Int32x4ExtractLane, Operator::kNoProperties, 2, 0, 1)                     \
-  V(Int32x4ReplaceLane, Operator::kNoProperties, 3, 0, 1)                     \
-  V(Int32x4Neg, Operator::kNoProperties, 1, 0, 1)                             \
-  V(Int32x4Add, Operator::kCommutative, 2, 0, 1)                              \
-  V(Int32x4Sub, Operator::kNoProperties, 2, 0, 1)                             \
-  V(Int32x4Mul, Operator::kCommutative, 2, 0, 1)                              \
-  V(Int32x4Min, Operator::kCommutative, 2, 0, 1)                              \
-  V(Int32x4Max, Operator::kCommutative, 2, 0, 1)                              \
-  V(Int32x4ShiftLeftByScalar, Operator::kNoProperties, 2, 0, 1)               \
-  V(Int32x4ShiftRightByScalar, Operator::kNoProperties, 2, 0, 1)              \
-  V(Int32x4Equal, Operator::kCommutative, 2, 0, 1)                            \
-  V(Int32x4NotEqual, Operator::kCommutative, 2, 0, 1)                         \
-  V(Int32x4LessThan, Operator::kNoProperties, 2, 0, 1)                        \
-  V(Int32x4LessThanOrEqual, Operator::kNoProperties, 2, 0, 1)                 \
-  V(Int32x4GreaterThan, Operator::kNoProperties, 2, 0, 1)                     \
-  V(Int32x4GreaterThanOrEqual, Operator::kNoProperties, 2, 0, 1)              \
-  V(Int32x4Select, Operator::kNoProperties, 3, 0, 1)                          \
-  V(Int32x4Swizzle, Operator::kNoProperties, 5, 0, 1)                         \
-  V(Int32x4Shuffle, Operator::kNoProperties, 6, 0, 1)                         \
-  V(Int32x4FromFloat32x4, Operator::kNoProperties, 1, 0, 1)                   \
-  V(Uint32x4Min, Operator::kCommutative, 2, 0, 1)                             \
-  V(Uint32x4Max, Operator::kCommutative, 2, 0, 1)                             \
-  V(Uint32x4ShiftLeftByScalar, Operator::kNoProperties, 2, 0, 1)              \
-  V(Uint32x4ShiftRightByScalar, Operator::kNoProperties, 2, 0, 1)             \
-  V(Uint32x4LessThan, Operator::kNoProperties, 2, 0, 1)                       \
-  V(Uint32x4LessThanOrEqual, Operator::kNoProperties, 2, 0, 1)                \
-  V(Uint32x4GreaterThan, Operator::kNoProperties, 2, 0, 1)                    \
-  V(Uint32x4GreaterThanOrEqual, Operator::kNoProperties, 2, 0, 1)             \
-  V(Uint32x4FromFloat32x4, Operator::kNoProperties, 1, 0, 1)                  \
-  V(CreateBool32x4, Operator::kNoProperties, 4, 0, 1)                         \
-  V(Bool32x4ExtractLane, Operator::kNoProperties, 2, 0, 1)                    \
-  V(Bool32x4ReplaceLane, Operator::kNoProperties, 3, 0, 1)                    \
-  V(Bool32x4And, Operator::kAssociative | Operator::kCommutative, 2, 0, 1)    \
-  V(Bool32x4Or, Operator::kAssociative | Operator::kCommutative, 2, 0, 1)     \
-  V(Bool32x4Xor, Operator::kAssociative | Operator::kCommutative, 2, 0, 1)    \
-  V(Bool32x4Not, Operator::kNoProperties, 1, 0, 1)                            \
-  V(Bool32x4AnyTrue, Operator::kNoProperties, 1, 0, 1)                        \
-  V(Bool32x4AllTrue, Operator::kNoProperties, 1, 0, 1)                        \
-  V(Bool32x4Swizzle, Operator::kNoProperties, 5, 0, 1)                        \
-  V(Bool32x4Shuffle, Operator::kNoProperties, 6, 0, 1)                        \
-  V(Bool32x4Equal, Operator::kCommutative, 2, 0, 1)                           \
-  V(Bool32x4NotEqual, Operator::kCommutative, 2, 0, 1)                        \
-  V(CreateInt16x8, Operator::kNoProperties, 8, 0, 1)                          \
-  V(Int16x8ExtractLane, Operator::kNoProperties, 2, 0, 1)                     \
-  V(Int16x8ReplaceLane, Operator::kNoProperties, 3, 0, 1)                     \
-  V(Int16x8Neg, Operator::kNoProperties, 1, 0, 1)                             \
-  V(Int16x8Add, Operator::kCommutative, 2, 0, 1)                              \
-  V(Int16x8AddSaturate, Operator::kCommutative, 2, 0, 1)                      \
-  V(Int16x8Sub, Operator::kNoProperties, 2, 0, 1)                             \
-  V(Int16x8SubSaturate, Operator::kNoProperties, 2, 0, 1)                     \
-  V(Int16x8Mul, Operator::kCommutative, 2, 0, 1)                              \
-  V(Int16x8Min, Operator::kCommutative, 2, 0, 1)                              \
-  V(Int16x8Max, Operator::kCommutative, 2, 0, 1)                              \
-  V(Int16x8ShiftLeftByScalar, Operator::kNoProperties, 2, 0, 1)               \
-  V(Int16x8ShiftRightByScalar, Operator::kNoProperties, 2, 0, 1)              \
-  V(Int16x8Equal, Operator::kCommutative, 2, 0, 1)                            \
-  V(Int16x8NotEqual, Operator::kCommutative, 2, 0, 1)                         \
-  V(Int16x8LessThan, Operator::kNoProperties, 2, 0, 1)                        \
-  V(Int16x8LessThanOrEqual, Operator::kNoProperties, 2, 0, 1)                 \
-  V(Int16x8GreaterThan, Operator::kNoProperties, 2, 0, 1)                     \
-  V(Int16x8GreaterThanOrEqual, Operator::kNoProperties, 2, 0, 1)              \
-  V(Int16x8Select, Operator::kNoProperties, 3, 0, 1)                          \
-  V(Int16x8Swizzle, Operator::kNoProperties, 9, 0, 1)                         \
-  V(Int16x8Shuffle, Operator::kNoProperties, 10, 0, 1)                        \
-  V(Uint16x8AddSaturate, Operator::kCommutative, 2, 0, 1)                     \
-  V(Uint16x8SubSaturate, Operator::kNoProperties, 2, 0, 1)                    \
-  V(Uint16x8Min, Operator::kCommutative, 2, 0, 1)                             \
-  V(Uint16x8Max, Operator::kCommutative, 2, 0, 1)                             \
-  V(Uint16x8ShiftLeftByScalar, Operator::kNoProperties, 2, 0, 1)              \
-  V(Uint16x8ShiftRightByScalar, Operator::kNoProperties, 2, 0, 1)             \
-  V(Uint16x8LessThan, Operator::kNoProperties, 2, 0, 1)                       \
-  V(Uint16x8LessThanOrEqual, Operator::kNoProperties, 2, 0, 1)                \
-  V(Uint16x8GreaterThan, Operator::kNoProperties, 2, 0, 1)                    \
-  V(Uint16x8GreaterThanOrEqual, Operator::kNoProperties, 2, 0, 1)             \
-  V(CreateBool16x8, Operator::kNoProperties, 8, 0, 1)                         \
-  V(Bool16x8ExtractLane, Operator::kNoProperties, 2, 0, 1)                    \
-  V(Bool16x8ReplaceLane, Operator::kNoProperties, 3, 0, 1)                    \
-  V(Bool16x8And, Operator::kAssociative | Operator::kCommutative, 2, 0, 1)    \
-  V(Bool16x8Or, Operator::kAssociative | Operator::kCommutative, 2, 0, 1)     \
-  V(Bool16x8Xor, Operator::kAssociative | Operator::kCommutative, 2, 0, 1)    \
-  V(Bool16x8Not, Operator::kNoProperties, 1, 0, 1)                            \
-  V(Bool16x8AnyTrue, Operator::kNoProperties, 1, 0, 1)                        \
-  V(Bool16x8AllTrue, Operator::kNoProperties, 1, 0, 1)                        \
-  V(Bool16x8Swizzle, Operator::kNoProperties, 9, 0, 1)                        \
-  V(Bool16x8Shuffle, Operator::kNoProperties, 10, 0, 1)                       \
-  V(Bool16x8Equal, Operator::kCommutative, 2, 0, 1)                           \
-  V(Bool16x8NotEqual, Operator::kCommutative, 2, 0, 1)                        \
-  V(CreateInt8x16, Operator::kNoProperties, 16, 0, 1)                         \
-  V(Int8x16ExtractLane, Operator::kNoProperties, 2, 0, 1)                     \
-  V(Int8x16ReplaceLane, Operator::kNoProperties, 3, 0, 1)                     \
-  V(Int8x16Neg, Operator::kNoProperties, 1, 0, 1)                             \
-  V(Int8x16Add, Operator::kCommutative, 2, 0, 1)                              \
-  V(Int8x16AddSaturate, Operator::kCommutative, 2, 0, 1)                      \
-  V(Int8x16Sub, Operator::kNoProperties, 2, 0, 1)                             \
-  V(Int8x16SubSaturate, Operator::kNoProperties, 2, 0, 1)                     \
-  V(Int8x16Mul, Operator::kCommutative, 2, 0, 1)                              \
-  V(Int8x16Min, Operator::kCommutative, 2, 0, 1)                              \
-  V(Int8x16Max, Operator::kCommutative, 2, 0, 1)                              \
-  V(Int8x16ShiftLeftByScalar, Operator::kNoProperties, 2, 0, 1)               \
-  V(Int8x16ShiftRightByScalar, Operator::kNoProperties, 2, 0, 1)              \
-  V(Int8x16Equal, Operator::kCommutative, 2, 0, 1)                            \
-  V(Int8x16NotEqual, Operator::kCommutative, 2, 0, 1)                         \
-  V(Int8x16LessThan, Operator::kNoProperties, 2, 0, 1)                        \
-  V(Int8x16LessThanOrEqual, Operator::kNoProperties, 2, 0, 1)                 \
-  V(Int8x16GreaterThan, Operator::kNoProperties, 2, 0, 1)                     \
-  V(Int8x16GreaterThanOrEqual, Operator::kNoProperties, 2, 0, 1)              \
-  V(Int8x16Select, Operator::kNoProperties, 3, 0, 1)                          \
-  V(Int8x16Swizzle, Operator::kNoProperties, 17, 0, 1)                        \
-  V(Int8x16Shuffle, Operator::kNoProperties, 18, 0, 1)                        \
-  V(Uint8x16AddSaturate, Operator::kCommutative, 2, 0, 1)                     \
-  V(Uint8x16SubSaturate, Operator::kNoProperties, 2, 0, 1)                    \
-  V(Uint8x16Min, Operator::kCommutative, 2, 0, 1)                             \
-  V(Uint8x16Max, Operator::kCommutative, 2, 0, 1)                             \
-  V(Uint8x16ShiftLeftByScalar, Operator::kNoProperties, 2, 0, 1)              \
-  V(Uint8x16ShiftRightByScalar, Operator::kNoProperties, 2, 0, 1)             \
-  V(Uint8x16LessThan, Operator::kNoProperties, 2, 0, 1)                       \
-  V(Uint8x16LessThanOrEqual, Operator::kNoProperties, 2, 0, 1)                \
-  V(Uint8x16GreaterThan, Operator::kNoProperties, 2, 0, 1)                    \
-  V(Uint8x16GreaterThanOrEqual, Operator::kNoProperties, 2, 0, 1)             \
-  V(CreateBool8x16, Operator::kNoProperties, 16, 0, 1)                        \
-  V(Bool8x16ExtractLane, Operator::kNoProperties, 2, 0, 1)                    \
-  V(Bool8x16ReplaceLane, Operator::kNoProperties, 3, 0, 1)                    \
-  V(Bool8x16And, Operator::kAssociative | Operator::kCommutative, 2, 0, 1)    \
-  V(Bool8x16Or, Operator::kAssociative | Operator::kCommutative, 2, 0, 1)     \
-  V(Bool8x16Xor, Operator::kAssociative | Operator::kCommutative, 2, 0, 1)    \
-  V(Bool8x16Not, Operator::kNoProperties, 1, 0, 1)                            \
-  V(Bool8x16AnyTrue, Operator::kNoProperties, 1, 0, 1)                        \
-  V(Bool8x16AllTrue, Operator::kNoProperties, 1, 0, 1)                        \
-  V(Bool8x16Swizzle, Operator::kNoProperties, 17, 0, 1)                       \
-  V(Bool8x16Shuffle, Operator::kNoProperties, 18, 0, 1)                       \
-  V(Bool8x16Equal, Operator::kCommutative, 2, 0, 1)                           \
-  V(Bool8x16NotEqual, Operator::kCommutative, 2, 0, 1)                        \
-  V(Simd128Load, Operator::kNoProperties, 2, 0, 1)                            \
-  V(Simd128Load1, Operator::kNoProperties, 2, 0, 1)                           \
-  V(Simd128Load2, Operator::kNoProperties, 2, 0, 1)                           \
-  V(Simd128Load3, Operator::kNoProperties, 2, 0, 1)                           \
-  V(Simd128Store, Operator::kNoProperties, 3, 0, 1)                           \
-  V(Simd128Store1, Operator::kNoProperties, 3, 0, 1)                          \
-  V(Simd128Store2, Operator::kNoProperties, 3, 0, 1)                          \
-  V(Simd128Store3, Operator::kNoProperties, 3, 0, 1)                          \
-  V(Simd128And, Operator::kAssociative | Operator::kCommutative, 2, 0, 1)     \
-  V(Simd128Or, Operator::kAssociative | Operator::kCommutative, 2, 0, 1)      \
-  V(Simd128Xor, Operator::kAssociative | Operator::kCommutative, 2, 0, 1)     \
-  V(Simd128Not, Operator::kNoProperties, 1, 0, 1)
 
 #define PURE_OPTIONAL_OP_LIST(V)                            \
   V(Word32Ctz, Operator::kNoProperties, 1, 0, 1)            \
@@ -393,7 +221,6 @@ MachineRepresentation AtomicStoreRepresentationOf(Operator const* op) {
 #define MACHINE_TYPE_LIST(V) \
   V(Float32)                 \
   V(Float64)                 \
-  V(Simd128)                 \
   V(Int8)                    \
   V(Uint8)                   \
   V(Int16)                   \
@@ -408,7 +235,6 @@ MachineRepresentation AtomicStoreRepresentationOf(Operator const* op) {
 #define MACHINE_REPRESENTATION_LIST(V) \
   V(kFloat32)                          \
   V(kFloat64)                          \
-  V(kSimd128)                          \
   V(kWord8)                            \
   V(kWord16)                           \
   V(kWord32)                           \
diff --git a/src/compiler/machine-operator.h b/src/compiler/machine-operator.h
index 7c443f44c7..78feaa2a24 100644
--- a/src/compiler/machine-operator.h
+++ b/src/compiler/machine-operator.h
@@ -400,190 +400,6 @@ class MachineOperatorBuilder final : public ZoneObject {
   // Identity for any input that is not signalling NaN.
   const Operator* Float64SilenceNaN();
 
-  // SIMD operators.
-  const Operator* CreateFloat32x4();
-  const Operator* Float32x4ExtractLane();
-  const Operator* Float32x4ReplaceLane();
-  const Operator* Float32x4Abs();
-  const Operator* Float32x4Neg();
-  const Operator* Float32x4Sqrt();
-  const Operator* Float32x4RecipApprox();
-  const Operator* Float32x4RecipSqrtApprox();
-  const Operator* Float32x4Add();
-  const Operator* Float32x4Sub();
-  const Operator* Float32x4Mul();
-  const Operator* Float32x4Div();
-  const Operator* Float32x4Min();
-  const Operator* Float32x4Max();
-  const Operator* Float32x4MinNum();
-  const Operator* Float32x4MaxNum();
-  const Operator* Float32x4Equal();
-  const Operator* Float32x4NotEqual();
-  const Operator* Float32x4LessThan();
-  const Operator* Float32x4LessThanOrEqual();
-  const Operator* Float32x4GreaterThan();
-  const Operator* Float32x4GreaterThanOrEqual();
-  const Operator* Float32x4Select();
-  const Operator* Float32x4Swizzle();
-  const Operator* Float32x4Shuffle();
-  const Operator* Float32x4FromInt32x4();
-  const Operator* Float32x4FromUint32x4();
-
-  const Operator* CreateInt32x4();
-  const Operator* Int32x4ExtractLane();
-  const Operator* Int32x4ReplaceLane();
-  const Operator* Int32x4Neg();
-  const Operator* Int32x4Add();
-  const Operator* Int32x4Sub();
-  const Operator* Int32x4Mul();
-  const Operator* Int32x4Min();
-  const Operator* Int32x4Max();
-  const Operator* Int32x4ShiftLeftByScalar();
-  const Operator* Int32x4ShiftRightByScalar();
-  const Operator* Int32x4Equal();
-  const Operator* Int32x4NotEqual();
-  const Operator* Int32x4LessThan();
-  const Operator* Int32x4LessThanOrEqual();
-  const Operator* Int32x4GreaterThan();
-  const Operator* Int32x4GreaterThanOrEqual();
-  const Operator* Int32x4Select();
-  const Operator* Int32x4Swizzle();
-  const Operator* Int32x4Shuffle();
-  const Operator* Int32x4FromFloat32x4();
-
-  const Operator* Uint32x4Min();
-  const Operator* Uint32x4Max();
-  const Operator* Uint32x4ShiftLeftByScalar();
-  const Operator* Uint32x4ShiftRightByScalar();
-  const Operator* Uint32x4LessThan();
-  const Operator* Uint32x4LessThanOrEqual();
-  const Operator* Uint32x4GreaterThan();
-  const Operator* Uint32x4GreaterThanOrEqual();
-  const Operator* Uint32x4FromFloat32x4();
-
-  const Operator* CreateBool32x4();
-  const Operator* Bool32x4ExtractLane();
-  const Operator* Bool32x4ReplaceLane();
-  const Operator* Bool32x4And();
-  const Operator* Bool32x4Or();
-  const Operator* Bool32x4Xor();
-  const Operator* Bool32x4Not();
-  const Operator* Bool32x4AnyTrue();
-  const Operator* Bool32x4AllTrue();
-  const Operator* Bool32x4Swizzle();
-  const Operator* Bool32x4Shuffle();
-  const Operator* Bool32x4Equal();
-  const Operator* Bool32x4NotEqual();
-
-  const Operator* CreateInt16x8();
-  const Operator* Int16x8ExtractLane();
-  const Operator* Int16x8ReplaceLane();
-  const Operator* Int16x8Neg();
-  const Operator* Int16x8Add();
-  const Operator* Int16x8AddSaturate();
-  const Operator* Int16x8Sub();
-  const Operator* Int16x8SubSaturate();
-  const Operator* Int16x8Mul();
-  const Operator* Int16x8Min();
-  const Operator* Int16x8Max();
-  const Operator* Int16x8ShiftLeftByScalar();
-  const Operator* Int16x8ShiftRightByScalar();
-  const Operator* Int16x8Equal();
-  const Operator* Int16x8NotEqual();
-  const Operator* Int16x8LessThan();
-  const Operator* Int16x8LessThanOrEqual();
-  const Operator* Int16x8GreaterThan();
-  const Operator* Int16x8GreaterThanOrEqual();
-  const Operator* Int16x8Select();
-  const Operator* Int16x8Swizzle();
-  const Operator* Int16x8Shuffle();
-
-  const Operator* Uint16x8AddSaturate();
-  const Operator* Uint16x8SubSaturate();
-  const Operator* Uint16x8Min();
-  const Operator* Uint16x8Max();
-  const Operator* Uint16x8ShiftLeftByScalar();
-  const Operator* Uint16x8ShiftRightByScalar();
-  const Operator* Uint16x8LessThan();
-  const Operator* Uint16x8LessThanOrEqual();
-  const Operator* Uint16x8GreaterThan();
-  const Operator* Uint16x8GreaterThanOrEqual();
-
-  const Operator* CreateBool16x8();
-  const Operator* Bool16x8ExtractLane();
-  const Operator* Bool16x8ReplaceLane();
-  const Operator* Bool16x8And();
-  const Operator* Bool16x8Or();
-  const Operator* Bool16x8Xor();
-  const Operator* Bool16x8Not();
-  const Operator* Bool16x8AnyTrue();
-  const Operator* Bool16x8AllTrue();
-  const Operator* Bool16x8Swizzle();
-  const Operator* Bool16x8Shuffle();
-  const Operator* Bool16x8Equal();
-  const Operator* Bool16x8NotEqual();
-
-  const Operator* CreateInt8x16();
-  const Operator* Int8x16ExtractLane();
-  const Operator* Int8x16ReplaceLane();
-  const Operator* Int8x16Neg();
-  const Operator* Int8x16Add();
-  const Operator* Int8x16AddSaturate();
-  const Operator* Int8x16Sub();
-  const Operator* Int8x16SubSaturate();
-  const Operator* Int8x16Mul();
-  const Operator* Int8x16Min();
-  const Operator* Int8x16Max();
-  const Operator* Int8x16ShiftLeftByScalar();
-  const Operator* Int8x16ShiftRightByScalar();
-  const Operator* Int8x16Equal();
-  const Operator* Int8x16NotEqual();
-  const Operator* Int8x16LessThan();
-  const Operator* Int8x16LessThanOrEqual();
-  const Operator* Int8x16GreaterThan();
-  const Operator* Int8x16GreaterThanOrEqual();
-  const Operator* Int8x16Select();
-  const Operator* Int8x16Swizzle();
-  const Operator* Int8x16Shuffle();
-
-  const Operator* Uint8x16AddSaturate();
-  const Operator* Uint8x16SubSaturate();
-  const Operator* Uint8x16Min();
-  const Operator* Uint8x16Max();
-  const Operator* Uint8x16ShiftLeftByScalar();
-  const Operator* Uint8x16ShiftRightByScalar();
-  const Operator* Uint8x16LessThan();
-  const Operator* Uint8x16LessThanOrEqual();
-  const Operator* Uint8x16GreaterThan();
-  const Operator* Uint8x16GreaterThanOrEqual();
-
-  const Operator* CreateBool8x16();
-  const Operator* Bool8x16ExtractLane();
-  const Operator* Bool8x16ReplaceLane();
-  const Operator* Bool8x16And();
-  const Operator* Bool8x16Or();
-  const Operator* Bool8x16Xor();
-  const Operator* Bool8x16Not();
-  const Operator* Bool8x16AnyTrue();
-  const Operator* Bool8x16AllTrue();
-  const Operator* Bool8x16Swizzle();
-  const Operator* Bool8x16Shuffle();
-  const Operator* Bool8x16Equal();
-  const Operator* Bool8x16NotEqual();
-
-  const Operator* Simd128Load();
-  const Operator* Simd128Load1();
-  const Operator* Simd128Load2();
-  const Operator* Simd128Load3();
-  const Operator* Simd128Store();
-  const Operator* Simd128Store1();
-  const Operator* Simd128Store2();
-  const Operator* Simd128Store3();
-  const Operator* Simd128And();
-  const Operator* Simd128Or();
-  const Operator* Simd128Xor();
-  const Operator* Simd128Not();
-
   // load [base + index]
   const Operator* Load(LoadRepresentation rep);
 
diff --git a/src/compiler/opcodes.h b/src/compiler/opcodes.h
index c823afbbf2..7eb2ebbf6c 100644
--- a/src/compiler/opcodes.h
+++ b/src/compiler/opcodes.h
@@ -423,197 +423,11 @@
   V(AtomicLoad)                 \
   V(AtomicStore)
 
-#define MACHINE_SIMD_RETURN_SIMD_OP_LIST(V) \
-  V(CreateFloat32x4)                        \
-  V(Float32x4ReplaceLane)                   \
-  V(Float32x4Abs)                           \
-  V(Float32x4Neg)                           \
-  V(Float32x4Sqrt)                          \
-  V(Float32x4RecipApprox)                   \
-  V(Float32x4RecipSqrtApprox)               \
-  V(Float32x4Add)                           \
-  V(Float32x4Sub)                           \
-  V(Float32x4Mul)                           \
-  V(Float32x4Div)                           \
-  V(Float32x4Min)                           \
-  V(Float32x4Max)                           \
-  V(Float32x4MinNum)                        \
-  V(Float32x4MaxNum)                        \
-  V(Float32x4Equal)                         \
-  V(Float32x4NotEqual)                      \
-  V(Float32x4LessThan)                      \
-  V(Float32x4LessThanOrEqual)               \
-  V(Float32x4GreaterThan)                   \
-  V(Float32x4GreaterThanOrEqual)            \
-  V(Float32x4Select)                        \
-  V(Float32x4Swizzle)                       \
-  V(Float32x4Shuffle)                       \
-  V(Float32x4FromInt32x4)                   \
-  V(Float32x4FromUint32x4)                  \
-  V(CreateInt32x4)                          \
-  V(Int32x4ReplaceLane)                     \
-  V(Int32x4Neg)                             \
-  V(Int32x4Add)                             \
-  V(Int32x4Sub)                             \
-  V(Int32x4Mul)                             \
-  V(Int32x4Min)                             \
-  V(Int32x4Max)                             \
-  V(Int32x4ShiftLeftByScalar)               \
-  V(Int32x4ShiftRightByScalar)              \
-  V(Int32x4Equal)                           \
-  V(Int32x4NotEqual)                        \
-  V(Int32x4LessThan)                        \
-  V(Int32x4LessThanOrEqual)                 \
-  V(Int32x4GreaterThan)                     \
-  V(Int32x4GreaterThanOrEqual)              \
-  V(Int32x4Select)                          \
-  V(Int32x4Swizzle)                         \
-  V(Int32x4Shuffle)                         \
-  V(Int32x4FromFloat32x4)                   \
-  V(Uint32x4Min)                            \
-  V(Uint32x4Max)                            \
-  V(Uint32x4ShiftLeftByScalar)              \
-  V(Uint32x4ShiftRightByScalar)             \
-  V(Uint32x4LessThan)                       \
-  V(Uint32x4LessThanOrEqual)                \
-  V(Uint32x4GreaterThan)                    \
-  V(Uint32x4GreaterThanOrEqual)             \
-  V(Uint32x4FromFloat32x4)                  \
-  V(CreateBool32x4)                         \
-  V(Bool32x4ReplaceLane)                    \
-  V(Bool32x4And)                            \
-  V(Bool32x4Or)                             \
-  V(Bool32x4Xor)                            \
-  V(Bool32x4Not)                            \
-  V(Bool32x4Swizzle)                        \
-  V(Bool32x4Shuffle)                        \
-  V(Bool32x4Equal)                          \
-  V(Bool32x4NotEqual)                       \
-  V(CreateInt16x8)                          \
-  V(Int16x8ReplaceLane)                     \
-  V(Int16x8Neg)                             \
-  V(Int16x8Add)                             \
-  V(Int16x8AddSaturate)                     \
-  V(Int16x8Sub)                             \
-  V(Int16x8SubSaturate)                     \
-  V(Int16x8Mul)                             \
-  V(Int16x8Min)                             \
-  V(Int16x8Max)                             \
-  V(Int16x8ShiftLeftByScalar)               \
-  V(Int16x8ShiftRightByScalar)              \
-  V(Int16x8Equal)                           \
-  V(Int16x8NotEqual)                        \
-  V(Int16x8LessThan)                        \
-  V(Int16x8LessThanOrEqual)                 \
-  V(Int16x8GreaterThan)                     \
-  V(Int16x8GreaterThanOrEqual)              \
-  V(Int16x8Select)                          \
-  V(Int16x8Swizzle)                         \
-  V(Int16x8Shuffle)                         \
-  V(Uint16x8AddSaturate)                    \
-  V(Uint16x8SubSaturate)                    \
-  V(Uint16x8Min)                            \
-  V(Uint16x8Max)                            \
-  V(Uint16x8ShiftLeftByScalar)              \
-  V(Uint16x8ShiftRightByScalar)             \
-  V(Uint16x8LessThan)                       \
-  V(Uint16x8LessThanOrEqual)                \
-  V(Uint16x8GreaterThan)                    \
-  V(Uint16x8GreaterThanOrEqual)             \
-  V(CreateBool16x8)                         \
-  V(Bool16x8ReplaceLane)                    \
-  V(Bool16x8And)                            \
-  V(Bool16x8Or)                             \
-  V(Bool16x8Xor)                            \
-  V(Bool16x8Not)                            \
-  V(Bool16x8Swizzle)                        \
-  V(Bool16x8Shuffle)                        \
-  V(Bool16x8Equal)                          \
-  V(Bool16x8NotEqual)                       \
-  V(CreateInt8x16)                          \
-  V(Int8x16ReplaceLane)                     \
-  V(Int8x16Neg)                             \
-  V(Int8x16Add)                             \
-  V(Int8x16AddSaturate)                     \
-  V(Int8x16Sub)                             \
-  V(Int8x16SubSaturate)                     \
-  V(Int8x16Mul)                             \
-  V(Int8x16Min)                             \
-  V(Int8x16Max)                             \
-  V(Int8x16ShiftLeftByScalar)               \
-  V(Int8x16ShiftRightByScalar)              \
-  V(Int8x16Equal)                           \
-  V(Int8x16NotEqual)                        \
-  V(Int8x16LessThan)                        \
-  V(Int8x16LessThanOrEqual)                 \
-  V(Int8x16GreaterThan)                     \
-  V(Int8x16GreaterThanOrEqual)              \
-  V(Int8x16Select)                          \
-  V(Int8x16Swizzle)                         \
-  V(Int8x16Shuffle)                         \
-  V(Uint8x16AddSaturate)                    \
-  V(Uint8x16SubSaturate)                    \
-  V(Uint8x16Min)                            \
-  V(Uint8x16Max)                            \
-  V(Uint8x16ShiftLeftByScalar)              \
-  V(Uint8x16ShiftRightByScalar)             \
-  V(Uint8x16LessThan)                       \
-  V(Uint8x16LessThanOrEqual)                \
-  V(Uint8x16GreaterThan)                    \
-  V(Uint8x16GreaterThanOrEqual)             \
-  V(CreateBool8x16)                         \
-  V(Bool8x16ReplaceLane)                    \
-  V(Bool8x16And)                            \
-  V(Bool8x16Or)                             \
-  V(Bool8x16Xor)                            \
-  V(Bool8x16Not)                            \
-  V(Bool8x16Swizzle)                        \
-  V(Bool8x16Shuffle)                        \
-  V(Bool8x16Equal)                          \
-  V(Bool8x16NotEqual)
-
-#define MACHINE_SIMD_RETURN_NUM_OP_LIST(V) \
-  V(Float32x4ExtractLane)                  \
-  V(Int32x4ExtractLane)                    \
-  V(Int16x8ExtractLane)                    \
-  V(Int8x16ExtractLane)
-
-#define MACHINE_SIMD_RETURN_BOOL_OP_LIST(V) \
-  V(Bool32x4ExtractLane)                    \
-  V(Bool32x4AnyTrue)                        \
-  V(Bool32x4AllTrue)                        \
-  V(Bool16x8ExtractLane)                    \
-  V(Bool16x8AnyTrue)                        \
-  V(Bool16x8AllTrue)                        \
-  V(Bool8x16ExtractLane)                    \
-  V(Bool8x16AnyTrue)                        \
-  V(Bool8x16AllTrue)
-
-#define MACHINE_SIMD_GENERIC_OP_LIST(V) \
-  V(Simd128Load)                        \
-  V(Simd128Load1)                       \
-  V(Simd128Load2)                       \
-  V(Simd128Load3)                       \
-  V(Simd128Store)                       \
-  V(Simd128Store1)                      \
-  V(Simd128Store2)                      \
-  V(Simd128Store3)                      \
-  V(Simd128And)                         \
-  V(Simd128Or)                          \
-  V(Simd128Xor)                         \
-  V(Simd128Not)
-
-#define MACHINE_SIMD_OP_LIST(V)       \
-  MACHINE_SIMD_RETURN_SIMD_OP_LIST(V) \
-  MACHINE_SIMD_RETURN_NUM_OP_LIST(V)  \
-  MACHINE_SIMD_RETURN_BOOL_OP_LIST(V) \
-  MACHINE_SIMD_GENERIC_OP_LIST(V)
 
 #define VALUE_OP_LIST(V)  \
   COMMON_OP_LIST(V)       \
   SIMPLIFIED_OP_LIST(V)   \
   MACHINE_OP_LIST(V)      \
-  MACHINE_SIMD_OP_LIST(V) \
   JS_OP_LIST(V)
 
 // The combination of all operators at all levels and the common operators.
diff --git a/src/compiler/type-hint-analyzer.cc b/src/compiler/type-hint-analyzer.cc
index 791aa9debe..30b4173d71 100644
--- a/src/compiler/type-hint-analyzer.cc
+++ b/src/compiler/type-hint-analyzer.cc
@@ -104,7 +104,6 @@ bool TypeHintAnalysis::GetToBooleanHints(TypeFeedbackId id,
   ASSERT_COMPATIBLE(STRING, String);
   ASSERT_COMPATIBLE(SYMBOL, Symbol);
   ASSERT_COMPATIBLE(HEAP_NUMBER, HeapNumber);
-  ASSERT_COMPATIBLE(SIMD_VALUE, SimdValue);
 #undef ASSERT_COMPATIBLE
   *hints = ToBooleanHints(stub.types().ToIntegral());
   return true;
diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc
index 2bc0bb333f..77e8596622 100644
--- a/src/compiler/typer.cc
+++ b/src/compiler/typer.cc
@@ -99,7 +99,6 @@ class Typer::Visitor : public Reducer {
       COMMON_OP_LIST(DECLARE_CASE)
       SIMPLIFIED_OP_LIST(DECLARE_CASE)
       MACHINE_OP_LIST(DECLARE_CASE)
-      MACHINE_SIMD_OP_LIST(DECLARE_CASE)
       JS_SIMPLE_UNOP_LIST(DECLARE_CASE)
       JS_OBJECT_OP_LIST(DECLARE_CASE)
       JS_CONTEXT_OP_LIST(DECLARE_CASE)
@@ -146,7 +145,6 @@ class Typer::Visitor : public Reducer {
       COMMON_OP_LIST(DECLARE_CASE)
       SIMPLIFIED_OP_LIST(DECLARE_CASE)
       MACHINE_OP_LIST(DECLARE_CASE)
-      MACHINE_SIMD_OP_LIST(DECLARE_CASE)
       JS_SIMPLE_UNOP_LIST(DECLARE_CASE)
       JS_OBJECT_OP_LIST(DECLARE_CASE)
       JS_CONTEXT_OP_LIST(DECLARE_CASE)
@@ -2589,24 +2587,6 @@ Type* Typer::Visitor::TypeWord32PairShr(Node* node) { return Type::Internal(); }
 
 Type* Typer::Visitor::TypeWord32PairSar(Node* node) { return Type::Internal(); }
 
-// SIMD type methods.
-
-#define SIMD_RETURN_SIMD(Name) \
-  Type* Typer::Visitor::Type##Name(Node* node) { return Type::Simd(); }
-MACHINE_SIMD_RETURN_SIMD_OP_LIST(SIMD_RETURN_SIMD)
-MACHINE_SIMD_GENERIC_OP_LIST(SIMD_RETURN_SIMD)
-#undef SIMD_RETURN_SIMD
-
-#define SIMD_RETURN_NUM(Name) \
-  Type* Typer::Visitor::Type##Name(Node* node) { return Type::Number(); }
-MACHINE_SIMD_RETURN_NUM_OP_LIST(SIMD_RETURN_NUM)
-#undef SIMD_RETURN_NUM
-
-#define SIMD_RETURN_BOOL(Name) \
-  Type* Typer::Visitor::Type##Name(Node* node) { return Type::Boolean(); }
-MACHINE_SIMD_RETURN_BOOL_OP_LIST(SIMD_RETURN_BOOL)
-#undef SIMD_RETURN_BOOL
-
 // Heap constants.
 
 Type* Typer::Visitor::TypeConstant(Handle<Object> value) {
diff --git a/src/compiler/verifier.cc b/src/compiler/verifier.cc
index 365f0758b7..988d03e286 100644
--- a/src/compiler/verifier.cc
+++ b/src/compiler/verifier.cc
@@ -1162,10 +1162,6 @@ void Verifier::Visitor::Check(Node* node) {
     case IrOpcode::kAtomicLoad:
     case IrOpcode::kAtomicStore:
 
-#define SIMD_MACHINE_OP_CASE(Name) case IrOpcode::k##Name:
-      MACHINE_SIMD_OP_LIST(SIMD_MACHINE_OP_CASE)
-#undef SIMD_MACHINE_OP_CASE
-
       // TODO(rossberg): Check.
       break;
   }
diff --git a/src/crankshaft/arm/lithium-arm.cc b/src/crankshaft/arm/lithium-arm.cc
index fe8d8544b7..538b3092b3 100644
--- a/src/crankshaft/arm/lithium-arm.cc
+++ b/src/crankshaft/arm/lithium-arm.cc
@@ -1173,46 +1173,6 @@ LInstruction* LChunkBuilder::DoMathPowHalf(HUnaryMathOperation* instr) {
   return DefineAsRegister(result);
 }
 
-LInstruction* LChunkBuilder::DoNullarySIMDOperation(
-    HNullarySIMDOperation* instr) {
-  UNIMPLEMENTED();
-  return NULL;
-}
-
-LInstruction* LChunkBuilder::DoUnarySIMDOperation(HUnarySIMDOperation* instr) {
-  UNIMPLEMENTED();
-  return NULL;
-}
-
-LInstruction* LChunkBuilder::DoBinarySIMDOperation(
-    HBinarySIMDOperation* instr) {
-  UNIMPLEMENTED();
-  return NULL;
-}
-
-LInstruction* LChunkBuilder::DoTernarySIMDOperation(
-    HTernarySIMDOperation* instr) {
-  UNIMPLEMENTED();
-  return NULL;
-}
-
-LInstruction* LChunkBuilder::DoQuarternarySIMDOperation(
-    HQuarternarySIMDOperation* instr) {
-  UNIMPLEMENTED();
-  return NULL;
-}
-
-LInstruction* LChunkBuilder::DoQuinarySIMDOperation(
-    HQuinarySIMDOperation* instr) {
-  UNIMPLEMENTED();
-  return NULL;
-}
-
-LInstruction* LChunkBuilder::DoSenarySIMDOperation(
-    HSenarySIMDOperation* instr) {
-  UNIMPLEMENTED();
-  return NULL;
-}
 
 LInstruction* LChunkBuilder::DoCallNewArray(HCallNewArray* instr) {
   LOperand* context = UseFixed(instr->context(), cp);
diff --git a/src/crankshaft/arm/lithium-codegen-arm.cc b/src/crankshaft/arm/lithium-codegen-arm.cc
index e9d3f46773..834a32a822 100644
--- a/src/crankshaft/arm/lithium-codegen-arm.cc
+++ b/src/crankshaft/arm/lithium-codegen-arm.cc
@@ -2131,12 +2131,6 @@ void LCodeGen::DoBranch(LBranch* instr) {
         __ b(eq, instr->TrueLabel(chunk_));
       }
 
-      if (expected.Contains(ToBooleanICStub::SIMD_VALUE)) {
-        // SIMD value -> true.
-        __ CompareInstanceType(map, ip, SIMD128_VALUE_TYPE);
-        __ b(eq, instr->TrueLabel(chunk_));
-      }
-
       if (expected.Contains(ToBooleanICStub::HEAP_NUMBER)) {
         // heap number -> false iff +0, -0, or NaN.
         DwVfpRegister dbl_scratch = double_scratch0();
@@ -5280,17 +5274,6 @@ Condition LCodeGen::EmitTypeofIs(Label* true_label,
            Operand((1 << Map::kIsCallable) | (1 << Map::kIsUndetectable)));
     final_branch_condition = eq;
 
-// clang-format off
-#define SIMD128_TYPE(TYPE, Type, type, lane_count, lane_type)        \
-  } else if (String::Equals(type_name, factory->type##_string())) {  \
-    __ JumpIfSmi(input, false_label);                                \
-    __ ldr(scratch, FieldMemOperand(input, HeapObject::kMapOffset)); \
-    __ CompareRoot(scratch, Heap::k##Type##MapRootIndex);            \
-    final_branch_condition = eq;
-  SIMD128_TYPES(SIMD128_TYPE)
-#undef SIMD128_TYPE
-    // clang-format on
-
   } else {
     __ b(false_label);
   }
diff --git a/src/crankshaft/arm64/lithium-arm64.cc b/src/crankshaft/arm64/lithium-arm64.cc
index 6e7dfe3e5e..9a0a7c4730 100644
--- a/src/crankshaft/arm64/lithium-arm64.cc
+++ b/src/crankshaft/arm64/lithium-arm64.cc
@@ -2596,46 +2596,6 @@ LInstruction* LChunkBuilder::DoWrapReceiver(HWrapReceiver* instr) {
   LWrapReceiver* result = new(zone()) LWrapReceiver(receiver, function);
   return AssignEnvironment(DefineAsRegister(result));
 }
-LInstruction* LChunkBuilder::DoNullarySIMDOperation(
-    HNullarySIMDOperation* instr) {
-  UNIMPLEMENTED();
-  return NULL;
-}
-
-LInstruction* LChunkBuilder::DoUnarySIMDOperation(HUnarySIMDOperation* instr) {
-  UNIMPLEMENTED();
-  return NULL;
-}
-
-LInstruction* LChunkBuilder::DoBinarySIMDOperation(
-    HBinarySIMDOperation* instr) {
-  UNIMPLEMENTED();
-  return NULL;
-}
-
-LInstruction* LChunkBuilder::DoTernarySIMDOperation(
-    HTernarySIMDOperation* instr) {
-  UNIMPLEMENTED();
-  return NULL;
-}
-
-LInstruction* LChunkBuilder::DoQuarternarySIMDOperation(
-    HQuarternarySIMDOperation* instr) {
-  UNIMPLEMENTED();
-  return NULL;
-}
-
-LInstruction* LChunkBuilder::DoQuinarySIMDOperation(
-    HQuinarySIMDOperation* instr) {
-  UNIMPLEMENTED();
-  return NULL;
-}
-
-LInstruction* LChunkBuilder::DoSenarySIMDOperation(
-    HSenarySIMDOperation* instr) {
-  UNIMPLEMENTED();
-  return NULL;
-}
 
 }  // namespace internal
 }  // namespace v8
diff --git a/src/crankshaft/hydrogen-instructions.cc b/src/crankshaft/hydrogen-instructions.cc
index 1d85594b73..e26d95c471 100644
--- a/src/crankshaft/hydrogen-instructions.cc
+++ b/src/crankshaft/hydrogen-instructions.cc
@@ -823,7 +823,6 @@ bool HInstruction::CanDeoptimize() {
     case HValue::kTypeofIsAndBranch:
     case HValue::kUnknownOSRValue:
     case HValue::kUseConst:
-    case HValue::kNullarySIMDOperation:
       return false;
 
     case HValue::kAdd:
@@ -876,12 +875,6 @@ bool HInstruction::CanDeoptimize() {
     case HValue::kTypeof:
     case HValue::kUnaryMathOperation:
     case HValue::kWrapReceiver:
-    case HValue::kUnarySIMDOperation:
-    case HValue::kBinarySIMDOperation:
-    case HValue::kTernarySIMDOperation:
-    case HValue::kQuarternarySIMDOperation:
-    case HValue::kQuinarySIMDOperation:
-    case HValue::kSenarySIMDOperation:
       return true;
   }
   UNREACHABLE();
@@ -1058,8 +1051,7 @@ Representation HBranch::observed_input_representation(int index) {
   if (expected_input_types_.Contains(ToBooleanICStub::NULL_TYPE) ||
       expected_input_types_.Contains(ToBooleanICStub::SPEC_OBJECT) ||
       expected_input_types_.Contains(ToBooleanICStub::STRING) ||
-      expected_input_types_.Contains(ToBooleanICStub::SYMBOL) ||
-      expected_input_types_.Contains(ToBooleanICStub::SIMD_VALUE)) {
+      expected_input_types_.Contains(ToBooleanICStub::SYMBOL)) {
     return Representation::Tagged();
   }
   if (expected_input_types_.Contains(ToBooleanICStub::UNDEFINED)) {
@@ -1229,17 +1221,6 @@ String* TypeOfString(HConstant* constant, Isolate* isolate) {
     }
     case SYMBOL_TYPE:
       return heap->symbol_string();
-    case SIMD128_VALUE_TYPE: {
-      Unique<Map> map = constant->ObjectMap();
-#define SIMD128_TYPE(TYPE, Type, type, lane_count, lane_type) \
-  if (map.IsKnownGlobal(heap->type##_map())) {                \
-    return heap->type##_string();                             \
-  }
-      SIMD128_TYPES(SIMD128_TYPE)
-#undef SIMD128_TYPE
-      UNREACHABLE();
-      return nullptr;
-    }
     default:
       if (constant->IsUndetectable()) return heap->undefined_string();
       if (constant->IsCallable()) return heap->function_string();
@@ -1262,23 +1243,7 @@ bool HTypeofIsAndBranch::KnownSuccessorBlock(HBasicBlock** block) {
         type_literal_.IsKnownGlobal(isolate()->heap()->number_string());
     *block = number_type ? FirstSuccessor() : SecondSuccessor();
     return true;
-  } else if (value()->representation().IsFloat32x4()) {
-    bool float32x4_type =
-        type_literal_.IsKnownGlobal(isolate()->heap()->float32x4_string());
-    *block = float32x4_type ? FirstSuccessor() : SecondSuccessor();
-    return true;
-  } else if (value()->representation().IsBool32x4()) {
-    bool bool32x4_type =
-        type_literal_.IsKnownGlobal(isolate()->heap()->bool32x4_string());
-    *block = bool32x4_type ? FirstSuccessor() : SecondSuccessor();
-    return true;
-  } else if (value()->representation().IsInt32x4()) {
-    bool int32x4_type =
-        type_literal_.IsKnownGlobal(isolate()->heap()->int32x4_string());
-    *block = int32x4_type ? FirstSuccessor() : SecondSuccessor();
-    return true;
   }
-
   *block = NULL;
   return false;
 }
@@ -2017,8 +1982,7 @@ void HPhi::InitRealUses(int phi_id) {
       Representation rep = value->observed_input_representation(it.index());
       representation_from_non_phi_uses_ =
           representation_from_non_phi_uses().generalize(rep);
-      if (rep.IsSmi() || rep.IsInteger32() || rep.IsDouble() ||
-          rep.IsFloat32x4() || rep.IsInt32x4()) {
+      if (rep.IsSmi() || rep.IsInteger32() || rep.IsDouble()) {
         has_type_feedback_from_uses_ = true;
       }
 
@@ -4070,181 +4034,5 @@ std::ostream& operator<<(std::ostream& os, const HObjectAccess& access) {
   return os << "@" << access.offset();
 }
 
-HInstruction* HNullarySIMDOperation::New(Isolate* isolate, Zone* zone,
-                                         HValue* context,
-                                         BuiltinFunctionId op) {
-  return new (zone) HNullarySIMDOperation(context, op);
-}
-
-HInstruction* HUnarySIMDOperation::New(Isolate* isolate, Zone* zone,
-                                       HValue* context, HValue* value,
-                                       BuiltinFunctionId op,
-                                       Representation to) {
-  return new (zone) HUnarySIMDOperation(context, value, op, to);
-}
-
-HInstruction* HBinarySIMDOperation::New(Isolate* isolate, Zone* zone,
-                                        HValue* context, HValue* left,
-                                        HValue* right, BuiltinFunctionId op) {
-  return new (zone) HBinarySIMDOperation(context, left, right, op);
-}
-
-HInstruction* HTernarySIMDOperation::New(Isolate* isolate, Zone* zone,
-                                         HValue* context, HValue* mask,
-                                         HValue* left, HValue* right,
-                                         BuiltinFunctionId op) {
-  return new (zone) HTernarySIMDOperation(context, mask, left, right, op);
-}
-
-HInstruction* HQuarternarySIMDOperation::New(Isolate* isolate, Zone* zone,
-                                             HValue* context, HValue* x,
-                                             HValue* y, HValue* z, HValue* w,
-                                             BuiltinFunctionId op) {
-  return new (zone) HQuarternarySIMDOperation(context, x, y, z, w, op);
-}
-
-HInstruction* HQuinarySIMDOperation::New(Isolate* isolate, Zone* zone,
-                                         HValue* context, HValue* a0,
-                                         HValue* a1, HValue* a2, HValue* a3,
-                                         HValue* a4, BuiltinFunctionId op) {
-  return new (zone) HQuinarySIMDOperation(context, a0, a1, a2, a3, a4, op);
-}
-
-HInstruction* HSenarySIMDOperation::New(Isolate* isolate, Zone* zone,
-                                        HValue* context, HValue* a0, HValue* a1,
-                                        HValue* a2, HValue* a3, HValue* a4,
-                                        HValue* a5, BuiltinFunctionId op) {
-  return new (zone) HSenarySIMDOperation(context, a0, a1, a2, a3, a4, a5, op);
-}
-
-const char* HNullarySIMDOperation::OpName() const {
-  switch (op()) {
-#define SIMD_NULLARY_OPERATION_CASE_ITEM(module, function, name, p4) \
-  case k##name:                                                      \
-    return #module "." #function;
-    SIMD_NULLARY_OPERATIONS(SIMD_NULLARY_OPERATION_CASE_ITEM)
-#undef SIMD_NULLARY_OPERATION_CASE_ITEM
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-std::ostream& HNullarySIMDOperation::PrintDataTo(std::ostream& os) const {
-  return os << OpName();
-}
-
-const char* HUnarySIMDOperation::OpName() const {
-  switch (op()) {
-#define SIMD_UNARY_OPERATION_CASE_ITEM(module, function, name, p4, p5) \
-  case k##name:                                                        \
-    return #module "." #function;
-    SIMD_UNARY_OPERATIONS(SIMD_UNARY_OPERATION_CASE_ITEM)
-    SIMD_UNARY_OPERATIONS_FOR_PROPERTY_ACCESS(SIMD_UNARY_OPERATION_CASE_ITEM)
-#undef SIMD_UNARY_OPERATION_CASE_ITEM
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-std::ostream& HUnarySIMDOperation::PrintDataTo(std::ostream& os) const {
-  return os << OpName() << " " << NameOf(value());
-}
-
-const char* HBinarySIMDOperation::OpName() const {
-  switch (op()) {
-#define SIMD_BINARY_OPERATION_CASE_ITEM(module, function, name, p4, p5, p6) \
-  case k##name:                                                             \
-    return #module "." #function;
-    SIMD_BINARY_OPERATIONS(SIMD_BINARY_OPERATION_CASE_ITEM)
-#undef SIMD_BINARY_OPERATION_CASE_ITEM
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-std::ostream& HBinarySIMDOperation::PrintDataTo(std::ostream& os) const {
-  return os << OpName() << " " << NameOf(left()) << " " << NameOf(right());
-}
-
-const char* HTernarySIMDOperation::OpName() const {
-  switch (op()) {
-#define SIMD_TERNARY_OPERATION_CASE_ITEM(module, function, name, p4, p5, p6, \
-                                         p7)                                 \
-  case k##name:                                                              \
-    return #module "." #function;
-    SIMD_TERNARY_OPERATIONS(SIMD_TERNARY_OPERATION_CASE_ITEM)
-#undef SIMD_TERNARY_OPERATION_CASE_ITEM
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-std::ostream& HTernarySIMDOperation::PrintDataTo(std::ostream& os) const {
-  return os << OpName() << " " << NameOf(first()) << " " << NameOf(second())
-            << " " << NameOf(third());
-}
-
-const char* HQuarternarySIMDOperation::OpName() const {
-  switch (op()) {
-#define SIMD_QUARTERNARY_OPERATION_CASE_ITEM(module, function, name, p4, p5, \
-                                             p6, p7, p8)                     \
-  case k##name:                                                              \
-    return #module "." #function;
-    SIMD_QUARTERNARY_OPERATIONS(SIMD_QUARTERNARY_OPERATION_CASE_ITEM)
-#undef SIMD_QUARTERNARY_OPERATION_CASE_ITEM
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-std::ostream& HQuarternarySIMDOperation::PrintDataTo(std::ostream& os) const {
-  return os << OpName() << " " << NameOf(x()) << " " << NameOf(y()) << " "
-            << NameOf(z()) << " " << NameOf(w());
-}
-
-const char* HQuinarySIMDOperation::OpName() const {
-  switch (op()) {
-#define SIMD_QUINARY_OPERATION_CASE_ITEM(module, function, name, p4, p5, p6, \
-                                         p7, p8, p9)                         \
-  case k##name:                                                              \
-    return #module "." #function;
-    SIMD_QUINARY_OPERATIONS(SIMD_QUINARY_OPERATION_CASE_ITEM)
-#undef SIMD_QUINARY_OPERATION_CASE_ITEM
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-std::ostream& HQuinarySIMDOperation::PrintDataTo(std::ostream& os) const {
-  return os << OpName() << " " << NameOf(a0()) << " " << NameOf(a1()) << " "
-            << NameOf(a2()) << " " << NameOf(a3()) << " " << NameOf(a4());
-}
-
-const char* HSenarySIMDOperation::OpName() const {
-  switch (op()) {
-#define SIMD_SENARY_OPERATION_CASE_ITEM(module, function, name, p4, p5, p6, \
-                                        p7, p8, p9, p10)                    \
-  case k##name:                                                             \
-    return #module "." #function;
-    SIMD_SENARY_OPERATIONS(SIMD_SENARY_OPERATION_CASE_ITEM)
-#undef SIMD_SENARY_OPERATION_CASE_ITEM
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-std::ostream& HSenarySIMDOperation::PrintDataTo(std::ostream& os) const {
-  return os << OpName() << " " << NameOf(a0()) << " " << NameOf(a1()) << " "
-            << NameOf(a2()) << " " << NameOf(a3()) << " " << NameOf(a4()) << " "
-            << NameOf(a5());
-}
-
 }  // namespace internal
 }  // namespace v8
diff --git a/src/crankshaft/hydrogen-instructions.h b/src/crankshaft/hydrogen-instructions.h
index 545171a346..9a757c8851 100644
--- a/src/crankshaft/hydrogen-instructions.h
+++ b/src/crankshaft/hydrogen-instructions.h
@@ -43,6 +43,7 @@ class LChunkBuilder;
   V(ControlInstruction)                       \
   V(Instruction)
 
+
 #define HYDROGEN_CONCRETE_INSTRUCTION_LIST(V) \
   V(AbnormalExit)                             \
   V(AccessArgumentsAt)                        \
@@ -144,13 +145,6 @@ class LChunkBuilder;
   V(Typeof)                                   \
   V(TypeofIsAndBranch)                        \
   V(UnaryMathOperation)                       \
-  V(NullarySIMDOperation)                     \
-  V(UnarySIMDOperation)                       \
-  V(BinarySIMDOperation)                      \
-  V(TernarySIMDOperation)                     \
-  V(QuarternarySIMDOperation)                 \
-  V(QuinarySIMDOperation)                     \
-  V(SenarySIMDOperation)                      \
   V(UnknownOSRValue)                          \
   V(UseConst)                                 \
   V(WrapReceiver)
@@ -531,9 +525,6 @@ class HValue : public ZoneObject {
       HType t = type();
       if (t.IsSmi()) return Representation::Smi();
       if (t.IsHeapNumber()) return Representation::Double();
-      if (t.IsFloat32x4()) return Representation::Float32x4();
-      if (t.IsBool32x4()) return Representation::Bool32x4();
-      if (t.IsInt32x4()) return Representation::Int32x4();
       if (t.IsHeapObject()) return r;
       return Representation::None();
     }
@@ -542,9 +533,7 @@ class HValue : public ZoneObject {
 
   HType type() const { return type_; }
   void set_type(HType new_type) {
-    // TODO(ningxin): for SIMD ops, the initial type is None which
-    // hit the following ASSERT.
-    // DCHECK(new_type.IsSubtypeOf(type_));
+    DCHECK(new_type.IsSubtypeOf(type_));
     type_ = new_type;
   }
 
@@ -923,12 +912,6 @@ std::ostream& operator<<(std::ostream& os, const ChangesOf& v);
     return new (zone) I(p1, p2, p3, p4, p5, p6, p7);                         \
   }
 
-#define DECLARE_INSTRUCTION_FACTORY_P8(I, P1, P2, P3, P4, P5, P6, P7, P8)    \
-  static I* New(Isolate* isolate, Zone* zone, HValue* context, P1 p1, P2 p2, \
-                P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) {                  \
-    return new (zone) I(p1, p2, p3, p4, p5, p6, p7, p8);                     \
-  }
-
 #define DECLARE_INSTRUCTION_WITH_CONTEXT_FACTORY_P0(I)           \
   static I* New(Isolate* isolate, Zone* zone, HValue* context) { \
     return new (zone) I(context);                                \
@@ -1614,15 +1597,7 @@ class HChange final : public HUnaryOperation {
     if (value->representation().IsSmi() || value->type().IsSmi()) {
       set_type(HType::Smi());
     } else {
-      if (to.IsFloat32x4()) {
-        set_type(HType::Float32x4());
-      } else if (to.IsInt32x4()) {
-        set_type(HType::Int32x4());
-      } else if (to.IsBool32x4()) {
-        set_type(HType::Bool32x4());
-      } else {
-        set_type(HType::TaggedNumber());
-      }
+      set_type(HType::TaggedNumber());
       if (to.IsTagged()) SetChangesFlag(kNewSpacePromotion);
     }
   }
@@ -3704,8 +3679,6 @@ class HAccessArgumentsAt final : public HTemplateInstruction<3> {
 class HBoundsCheck final : public HTemplateInstruction<2> {
  public:
   DECLARE_INSTRUCTION_FACTORY_P2(HBoundsCheck, HValue*, HValue*);
-  DECLARE_INSTRUCTION_FACTORY_P4(HBoundsCheck, HValue*, HValue*,
-                                 BuiltinFunctionId, ElementsKind);
 
   bool skip_check() const { return skip_check_; }
   void set_skip_check() { skip_check_ = true; }
@@ -3725,8 +3698,6 @@ class HBoundsCheck final : public HTemplateInstruction<2> {
   HValue* length() const { return OperandAt(1); }
   bool allow_equality() const { return allow_equality_; }
   void set_allow_equality(bool v) { allow_equality_ = v; }
-  BuiltinFunctionId op() const { return op_; }
-  ElementsKind element_kind() const { return element_kind_; }
 
   int RedefinedOperandIndex() override { return 0; }
   bool IsPurelyInformativeDefinition() override { return skip_check(); }
@@ -3742,24 +3713,16 @@ class HBoundsCheck final : public HTemplateInstruction<2> {
   int offset_;
   int scale_;
   bool allow_equality_;
-  BuiltinFunctionId op_;
-  ElementsKind element_kind_;
 
  private:
   // Normally HBoundsCheck should be created using the
   // HGraphBuilder::AddBoundsCheck() helper.
   // However when building stubs, where we know that the arguments are Int32,
   // it makes sense to invoke this constructor directly.
-  HBoundsCheck(HValue* index, HValue* length,
-               BuiltinFunctionId op = kNumberOfBuiltinFunction,
-               ElementsKind element_kind = INT8_ELEMENTS)
-      : skip_check_(false),
-        base_(NULL),
-        offset_(0),
-        scale_(0),
-        allow_equality_(false),
-        op_(op),
-        element_kind_(element_kind) {
+  HBoundsCheck(HValue* index, HValue* length)
+    : skip_check_(false),
+      base_(NULL), offset_(0), scale_(0),
+      allow_equality_(false) {
     SetOperandAt(0, index);
     SetOperandAt(1, length);
     SetFlag(kFlexibleRepresentation);
@@ -5378,15 +5341,6 @@ class HObjectAccess final {
     return HObjectAccess(kInobject, Oddball::kTypeOfOffset,
                          Representation::HeapObject());
   }
-  static HObjectAccess ForSIMD128Double0() {
-    return HObjectAccess(kDouble, Float32x4::kValueOffset,
-                         Representation::Double());
-  }
-
-  static HObjectAccess ForSIMD128Double1() {
-    return HObjectAccess(kDouble, Float32x4::kValueOffset + kDoubleSize,
-                         Representation::Double());
-  }
 
   static HObjectAccess ForElementsPointer() {
     return HObjectAccess(kElementsPointer, JSObject::kElementsOffset);
@@ -5557,10 +5511,6 @@ class HObjectAccess final {
                          Representation::UInteger16());
   }
 
-  static HObjectAccess ForMapPrototype() {
-    return HObjectAccess(kInobject, Map::kPrototypeOffset);
-  }
-
   static HObjectAccess ForPropertyCellValue() {
     return HObjectAccess(kInobject, PropertyCell::kValueOffset);
   }
@@ -6028,9 +5978,6 @@ class HLoadKeyed final : public HTemplateInstruction<4>,
                                  ElementsKind, LoadKeyedHoleMode);
   DECLARE_INSTRUCTION_FACTORY_P7(HLoadKeyed, HValue*, HValue*, HValue*, HValue*,
                                  ElementsKind, LoadKeyedHoleMode, int);
-  DECLARE_INSTRUCTION_FACTORY_P8(HLoadKeyed, HValue*, HValue*, HValue*, HValue*,
-                                 ElementsKind, LoadKeyedHoleMode, int,
-                                 BuiltinFunctionId);
 
   bool is_fixed_typed_array() const {
     return IsFixedTypedArrayElementsKind(elements_kind());
@@ -6049,7 +5996,6 @@ class HLoadKeyed final : public HTemplateInstruction<4>,
   bool HasBackingStoreOwner() const { return OperandAt(0) != OperandAt(3); }
   uint32_t base_offset() const { return BaseOffsetField::decode(bit_field_); }
   bool TryIncreaseBaseOffset(uint32_t increase_by_value) override;
-  BuiltinFunctionId op() { return op_; }
   HValue* GetKey() override { return key(); }
   void SetKey(HValue* key) override { SetOperandAt(1, key); }
   bool IsDehoisted() const override {
@@ -6113,9 +6059,8 @@ class HLoadKeyed final : public HTemplateInstruction<4>,
   HLoadKeyed(HValue* obj, HValue* key, HValue* dependency,
              HValue* backing_store_owner, ElementsKind elements_kind,
              LoadKeyedHoleMode mode = NEVER_RETURN_HOLE,
-             int offset = kDefaultKeyedHeaderOffsetSentinel,
-             BuiltinFunctionId op = kNumberOfBuiltinFunction)
-      : bit_field_(0), op_(op) {
+             int offset = kDefaultKeyedHeaderOffsetSentinel)
+      : bit_field_(0) {
     offset = offset == kDefaultKeyedHeaderOffsetSentinel
         ? GetDefaultHeaderSizeForElementsKind(elements_kind)
         : offset;
@@ -6155,31 +6100,8 @@ class HLoadKeyed final : public HTemplateInstruction<4>,
         SetDependsOnFlag(kDoubleArrayElements);
       }
     } else {
-      if (op_ == kFloat32ArrayGetFloat32x4XYZW ||
-          op_ == kFloat32ArrayGetFloat32x4X ||
-          op_ == kFloat32ArrayGetFloat32x4XY ||
-          op_ == kFloat32ArrayGetFloat32x4XYZ ||
-          op_ == kInt8ArrayGetFloat32x4XYZW || op_ == kInt8ArrayGetFloat32x4X ||
-          op_ == kInt8ArrayGetFloat32x4XY || op_ == kInt8ArrayGetFloat32x4XYZ ||
-          op_ == kUint8ArrayGetFloat32x4XYZW ||
-          op_ == kUint8ArrayGetFloat32x4X || op_ == kUint8ArrayGetFloat32x4XY ||
-          op_ == kUint8ArrayGetFloat32x4XYZ) {
-        set_representation(Representation::Float32x4());
-      } else if (op_ == kInt32ArrayGetInt32x4XYZW ||
-                 op_ == kInt32ArrayGetInt32x4X ||
-                 op_ == kInt32ArrayGetInt32x4XY ||
-                 op_ == kInt32ArrayGetInt32x4XYZ ||
-                 op_ == kInt8ArrayGetInt32x4XYZW ||
-                 op_ == kInt8ArrayGetInt32x4X ||
-                 op_ == kInt8ArrayGetInt32x4XY ||
-                 op_ == kInt8ArrayGetInt32x4XYZ ||
-                 op_ == kUint8ArrayGetInt32x4XYZW ||
-                 op_ == kUint8ArrayGetInt32x4X ||
-                 op_ == kUint8ArrayGetInt32x4XY ||
-                 op_ == kUint8ArrayGetInt32x4XYZ) {
-        set_representation(Representation::Int32x4());
-      } else if (elements_kind == FLOAT32_ELEMENTS ||
-                 elements_kind == FLOAT64_ELEMENTS) {
+      if (elements_kind == FLOAT32_ELEMENTS ||
+          elements_kind == FLOAT64_ELEMENTS) {
         set_representation(Representation::Double());
       } else {
         set_representation(Representation::Integer32());
@@ -6229,7 +6151,6 @@ class HLoadKeyed final : public HTemplateInstruction<4>,
     public BitField<bool, kStartIsDehoisted, kBitsForIsDehoisted>
     {};  // NOLINT
   uint32_t bit_field_;
-  BuiltinFunctionId op_;
 };
 
 
@@ -6488,9 +6409,6 @@ class HStoreKeyed final : public HTemplateInstruction<4>,
   DECLARE_INSTRUCTION_FACTORY_P7(HStoreKeyed, HValue*, HValue*, HValue*,
                                  HValue*, ElementsKind, StoreFieldOrKeyedMode,
                                  int);
-  DECLARE_INSTRUCTION_FACTORY_P8(HStoreKeyed, HValue*, HValue*, HValue*,
-                                 HValue*, ElementsKind, StoreFieldOrKeyedMode,
-                                 int, BuiltinFunctionId);
 
   Representation RequiredInputRepresentation(int index) override {
     // kind_fast:               tagged[int32] = tagged
@@ -6505,30 +6423,6 @@ class HStoreKeyed final : public HTemplateInstruction<4>,
       return ArrayInstructionInterface::KeyedAccessIndexRequirement(
           OperandAt(1)->representation());
     } else if (index == 2) {
-      if (op_ == kFloat32ArraySetFloat32x4XYZW ||
-          op_ == kFloat32ArraySetFloat32x4X ||
-          op_ == kFloat32ArraySetFloat32x4XY ||
-          op_ == kFloat32ArraySetFloat32x4XYZ ||
-          op_ == kInt8ArraySetFloat32x4XYZW || op_ == kInt8ArraySetFloat32x4X ||
-          op_ == kInt8ArraySetFloat32x4XY || op_ == kInt8ArraySetFloat32x4XYZ ||
-          op_ == kUint8ArraySetFloat32x4XYZW ||
-          op_ == kUint8ArraySetFloat32x4X || op_ == kUint8ArraySetFloat32x4XY ||
-          op_ == kUint8ArraySetFloat32x4XYZ) {
-        return Representation::Float32x4();
-      } else if (op_ == kInt32ArraySetInt32x4XYZW ||
-                 op_ == kInt32ArraySetInt32x4X ||
-                 op_ == kInt32ArraySetInt32x4XY ||
-                 op_ == kInt32ArraySetInt32x4XYZ ||
-                 op_ == kInt8ArraySetInt32x4XYZW ||
-                 op_ == kInt8ArraySetInt32x4X ||
-                 op_ == kInt8ArraySetInt32x4XY ||
-                 op_ == kInt8ArraySetInt32x4XYZ ||
-                 op_ == kUint8ArraySetInt32x4XYZW ||
-                 op_ == kUint8ArraySetInt32x4X ||
-                 op_ == kUint8ArraySetInt32x4XY ||
-                 op_ == kUint8ArraySetInt32x4XYZ) {
-        return Representation::Int32x4();
-      }
       return RequiredValueRepresentation(elements_kind(), store_mode());
     }
 
@@ -6567,28 +6461,6 @@ class HStoreKeyed final : public HTemplateInstruction<4>,
     if (IsUninitialized()) {
       return Representation::None();
     }
-    if (op_ == kFloat32ArraySetFloat32x4XYZW ||
-        op_ == kFloat32ArraySetFloat32x4X ||
-        op_ == kFloat32ArraySetFloat32x4XY ||
-        op_ == kFloat32ArraySetFloat32x4XYZ ||
-        op_ == kInt8ArraySetFloat32x4XYZW || op_ == kInt8ArraySetFloat32x4X ||
-        op_ == kInt8ArraySetFloat32x4XY || op_ == kInt8ArraySetFloat32x4XYZ ||
-        op_ == kUint8ArraySetFloat32x4XYZW || op_ == kUint8ArraySetFloat32x4X ||
-        op_ == kUint8ArraySetFloat32x4XY || op_ == kUint8ArraySetFloat32x4XYZ) {
-      return Representation::Float32x4();
-    } else if (op_ == kInt32ArraySetInt32x4XYZW ||
-               op_ == kInt32ArraySetInt32x4X ||
-               op_ == kInt32ArraySetInt32x4XY ||
-               op_ == kInt32ArraySetInt32x4XYZ ||
-               op_ == kInt8ArraySetInt32x4XYZW ||
-               op_ == kInt8ArraySetInt32x4X || op_ == kInt8ArraySetInt32x4XY ||
-               op_ == kInt8ArraySetInt32x4XYZ ||
-               op_ == kUint8ArraySetInt32x4XYZW ||
-               op_ == kUint8ArraySetInt32x4X ||
-               op_ == kUint8ArraySetInt32x4XY ||
-               op_ == kUint8ArraySetInt32x4XYZ) {
-      return Representation::Int32x4();
-    }
     Representation r =
         RequiredValueRepresentation(elements_kind(), store_mode());
     // For fast object elements kinds, don't assume anything.
@@ -6596,7 +6468,6 @@ class HStoreKeyed final : public HTemplateInstruction<4>,
     return r;
   }
 
-  BuiltinFunctionId op() const { return op_; }
   HValue* elements() const { return OperandAt(0); }
   HValue* key() const { return OperandAt(1); }
   HValue* value() const { return OperandAt(2); }
@@ -6663,8 +6534,7 @@ class HStoreKeyed final : public HTemplateInstruction<4>,
   HStoreKeyed(HValue* obj, HValue* key, HValue* val,
               HValue* backing_store_owner, ElementsKind elements_kind,
               StoreFieldOrKeyedMode store_mode = INITIALIZING_STORE,
-              int offset = kDefaultKeyedHeaderOffsetSentinel,
-              BuiltinFunctionId op = kNumberOfBuiltinFunction)
+              int offset = kDefaultKeyedHeaderOffsetSentinel)
       : base_offset_(offset == kDefaultKeyedHeaderOffsetSentinel
                          ? GetDefaultHeaderSizeForElementsKind(elements_kind)
                          : offset),
@@ -6672,8 +6542,7 @@ class HStoreKeyed final : public HTemplateInstruction<4>,
                    IsUninitializedField::encode(false) |
                    StoreModeField::encode(store_mode) |
                    ElementsKindField::encode(elements_kind)),
-        dominator_(NULL),
-        op_(op) {
+        dominator_(NULL) {
     SetOperandAt(0, obj);
     SetOperandAt(1, key);
     SetOperandAt(2, val);
@@ -6710,7 +6579,6 @@ class HStoreKeyed final : public HTemplateInstruction<4>,
   uint32_t base_offset_;
   uint32_t bit_field_;
   HValue* dominator_;
-  BuiltinFunctionId op_;
 };
 
 class HStoreKeyedGeneric final : public HTemplateInstruction<4> {
@@ -7286,584 +7154,6 @@ class HLoadFieldByIndex final : public HTemplateInstruction<2> {
   bool IsDeletable() const override { return true; }
 };
 
-class HNullarySIMDOperation final : public HTemplateInstruction<1> {
- public:
-  static HInstruction* New(Isolate* isolate, Zone* zone, HValue* context,
-                           BuiltinFunctionId op);
-
-  HValue* context() { return OperandAt(0); }
-
-  std::ostream& PrintDataTo(std::ostream& os) const override;
-
-  Representation observed_input_representation(int index) override {
-    return RequiredInputRepresentation(index);
-  }
-  Representation RequiredInputRepresentation(int index) override {
-    return Representation::Tagged();
-  }
-
-  BuiltinFunctionId op() const { return op_; }
-  const char* OpName() const;
-
-  DECLARE_CONCRETE_INSTRUCTION(NullarySIMDOperation)
-
- protected:
-  bool DataEquals(HValue* other) override {
-    HNullarySIMDOperation* b = HNullarySIMDOperation::cast(other);
-    return op_ == b->op();
-  }
-
- private:
-  HNullarySIMDOperation(HValue* context, BuiltinFunctionId op)
-      : HTemplateInstruction<1>(HType::None()), op_(op) {
-    SetOperandAt(0, context);
-    switch (op) {
-#define SIMD_NULLARY_OPERATION_CASE_ITEM(p1, p2, name, representation) \
-  case k##name:                                                        \
-    set_representation(Representation::representation());              \
-    set_type(HType::FromRepresentation(representation_));              \
-    break;
-      SIMD_NULLARY_OPERATIONS(SIMD_NULLARY_OPERATION_CASE_ITEM)
-#undef SIMD_NULLARY_OPERATION_CASE_ITEM
-      default:
-        UNREACHABLE();
-    }
-    SetFlag(kUseGVN);
-  }
-
-  bool IsDeletable() const override { return true; }
-
-  BuiltinFunctionId op_;
-};
-
-class HUnarySIMDOperation final : public HTemplateInstruction<2> {
- public:
-  static HInstruction* New(Isolate* isolate, Zone* zone, HValue* context,
-                           HValue* value, BuiltinFunctionId op,
-                           Representation to = Representation::Float32x4());
-
-  HValue* context() { return OperandAt(0); }
-  HValue* value() const { return OperandAt(1); }
-
-  std::ostream& PrintDataTo(std::ostream& os) const override;
-
-  Representation observed_input_representation(int index) override {
-    return RequiredInputRepresentation(index);
-  }
-  Representation RequiredInputRepresentation(int index) override {
-    if (index == 0) {
-      return Representation::Tagged();
-    } else if (op_ == kSIMD128Change) {
-      return value()->representation();
-    } else {
-      switch (op_) {
-#define SIMD_UNARY_OPERATION_CASE_ITEM(p1, p2, name, p4, representation) \
-  case k##name:                                                          \
-    return Representation::representation();
-        SIMD_UNARY_OPERATIONS(SIMD_UNARY_OPERATION_CASE_ITEM)
-        SIMD_UNARY_OPERATIONS_FOR_PROPERTY_ACCESS(
-            SIMD_UNARY_OPERATION_CASE_ITEM)
-#undef SIMD_UNARY_OPERATION_CASE_ITEM
-        default:
-          UNREACHABLE();
-          return Representation::None();
-      }
-    }
-  }
-
-  BuiltinFunctionId op() const { return op_; }
-  const char* OpName() const;
-
-  DECLARE_CONCRETE_INSTRUCTION(UnarySIMDOperation)
-
- protected:
-  bool DataEquals(HValue* other) override {
-    HUnarySIMDOperation* b = HUnarySIMDOperation::cast(other);
-    return op_ == b->op();
-  }
-
- private:
-  HUnarySIMDOperation(HValue* context, HValue* value, BuiltinFunctionId op,
-                      Representation to = Representation::Float32x4())
-      : HTemplateInstruction<2>(HType::None()), op_(op) {
-    SetOperandAt(0, context);
-    SetOperandAt(1, value);
-    switch (op) {
-      case kSIMD128Change:
-        set_representation(to);
-        set_type(HType::FromRepresentation(to));
-        break;
-#define SIMD_UNARY_OPERATION_CASE_ITEM(p1, p2, name, representation, p5) \
-  case k##name:                                                          \
-    set_representation(Representation::representation());                \
-    set_type(HType::FromRepresentation(representation_));                \
-    if (Representation::p5().IsInteger32()) {                            \
-      SetFlag(kTruncatingToInt32);                                       \
-    }                                                                    \
-    break;
-        SIMD_UNARY_OPERATIONS(SIMD_UNARY_OPERATION_CASE_ITEM)
-        SIMD_UNARY_OPERATIONS_FOR_PROPERTY_ACCESS(
-            SIMD_UNARY_OPERATION_CASE_ITEM)
-#undef SIMD_UNARY_OPERATION_CASE_ITEM
-      default:
-        UNREACHABLE();
-    }
-    SetFlag(kUseGVN);
-  }
-
-  bool IsDeletable() const override { return true; }
-
-  BuiltinFunctionId op_;
-};
-
-class HBinarySIMDOperation final : public HTemplateInstruction<3> {
- public:
-  static HInstruction* New(Isolate* isolate, Zone* zone, HValue* context,
-                           HValue* left, HValue* right, BuiltinFunctionId op);
-
-  HValue* context() { return OperandAt(0); }
-  HValue* left() const { return OperandAt(1); }
-  HValue* right() const { return OperandAt(2); }
-
-  std::ostream& PrintDataTo(std::ostream& os) const override;
-
-  Representation observed_input_representation(int index) override {
-    return RequiredInputRepresentation(index);
-  }
-  Representation RequiredInputRepresentation(int index) override {
-    if (index == 0) {
-      return Representation::Tagged();
-    } else {
-      switch (op_) {
-#define SIMD_BINARY_OPERATION_CASE_ITEM(p1, p2, name, p4, left_representation, \
-                                        right_representation)                  \
-  case k##name:                                                                \
-    return index == 1 ? Representation::left_representation()                  \
-                      : Representation::right_representation();                \
-    break;
-        SIMD_BINARY_OPERATIONS(SIMD_BINARY_OPERATION_CASE_ITEM)
-#undef SIMD_BINARY_OPERATION_CASE_ITEM
-        default:
-          UNREACHABLE();
-          return Representation::None();
-      }
-    }
-  }
-
-  BuiltinFunctionId op() const { return op_; }
-  const char* OpName() const;
-
-  DECLARE_CONCRETE_INSTRUCTION(BinarySIMDOperation)
-
- protected:
-  bool DataEquals(HValue* other) override {
-    HBinarySIMDOperation* b = HBinarySIMDOperation::cast(other);
-    return op_ == b->op();
-  }
-
- private:
-  HBinarySIMDOperation(HValue* context, HValue* left, HValue* right,
-                       BuiltinFunctionId op)
-      : HTemplateInstruction<3>(HType::None()), op_(op) {
-    SetOperandAt(0, context);
-    SetOperandAt(1, left);
-    SetOperandAt(2, right);
-    switch (op) {
-#define SIMD_BINARY_OPERATION_CASE_ITEM(p1, p2, name, representation, p5, p6) \
-  case k##name:                                                               \
-    set_representation(Representation::representation());                     \
-    set_type(HType::FromRepresentation(representation_));                     \
-    if (Representation::p5().IsInteger32() ||                                 \
-        Representation::p6().IsInteger32()) {                                 \
-      SetFlag(kTruncatingToInt32);                                            \
-    }                                                                         \
-    break;
-      SIMD_BINARY_OPERATIONS(SIMD_BINARY_OPERATION_CASE_ITEM)
-#undef SIMD_BINARY_OPERATION_CASE_ITEM
-      default:
-        UNREACHABLE();
-    }
-    SetFlag(kUseGVN);
-  }
-
-  bool IsDeletable() const override { return true; }
-
-  BuiltinFunctionId op_;
-};
-
-class HTernarySIMDOperation final : public HTemplateInstruction<4> {
- public:
-  static HInstruction* New(Isolate* isolate, Zone* zone, HValue* context,
-                           HValue* first, HValue* second, HValue* third,
-                           BuiltinFunctionId op);
-
-  HValue* context() { return OperandAt(0); }
-  HValue* first() const { return OperandAt(1); }
-  HValue* second() const { return OperandAt(2); }
-  HValue* third() const { return OperandAt(3); }
-
-  std::ostream& PrintDataTo(std::ostream& os) const override;
-
-  Representation observed_input_representation(int index) override {
-    return RequiredInputRepresentation(index);
-  }
-  Representation RequiredInputRepresentation(int index) override {
-    if (index == 0) {
-      return Representation::Tagged();
-    } else {
-      switch (op_) {
-#define SIMD_TERNARY_OPERATION_CASE_ITEM(p1, p2, name, p4,      \
-                                         first_representation,  \
-                                         second_representation, \
-                                         third_representation)  \
-  case k##name:                                                 \
-    switch (index) {                                            \
-      case 1:                                                   \
-        return Representation::first_representation();          \
-      case 2:                                                   \
-        return Representation::second_representation();         \
-      case 3:                                                   \
-        return Representation::third_representation();          \
-      default:                                                  \
-        UNREACHABLE();                                          \
-        return Representation::None();                          \
-    }
-        SIMD_TERNARY_OPERATIONS(SIMD_TERNARY_OPERATION_CASE_ITEM)
-#undef SIMD_TERNARY_OPERATION_CASE_ITEM
-        default:
-          UNREACHABLE();
-          return Representation::None();
-      }
-    }
-  }
-
-  BuiltinFunctionId op() const { return op_; }
-  const char* OpName() const;
-
-  DECLARE_CONCRETE_INSTRUCTION(TernarySIMDOperation)
-
- protected:
-  bool DataEquals(HValue* other) override {
-    HTernarySIMDOperation* b = HTernarySIMDOperation::cast(other);
-    return op_ == b->op();
-  }
-
- private:
-  HTernarySIMDOperation(HValue* context, HValue* first, HValue* second,
-                        HValue* third, BuiltinFunctionId op)
-      : HTemplateInstruction<4>(HType::None()), op_(op) {
-    SetOperandAt(0, context);
-    SetOperandAt(1, first);
-    SetOperandAt(2, second);
-    SetOperandAt(3, third);
-    switch (op) {
-#define SIMD_TERNARY_OPERATION_CASE_ITEM(p1, p2, name, representation, p5, p6, \
-                                         p7)                                   \
-  case k##name:                                                                \
-    set_representation(Representation::representation());                      \
-    set_type(HType::FromRepresentation(representation_));                      \
-    if (Representation::p5().IsInteger32() ||                                  \
-        Representation::p6().IsInteger32() ||                                  \
-        Representation::p7().IsInteger32()) {                                  \
-      SetFlag(kTruncatingToInt32);                                             \
-    }                                                                          \
-    break;
-      SIMD_TERNARY_OPERATIONS(SIMD_TERNARY_OPERATION_CASE_ITEM)
-#undef SIMD_TERNARY_OPERATION_CASE_ITEM
-      default:
-        UNREACHABLE();
-    }
-    SetFlag(kUseGVN);
-  }
-
-  bool IsDeletable() const override { return true; }
-
-  BuiltinFunctionId op_;
-};
-
-class HQuarternarySIMDOperation final : public HTemplateInstruction<5> {
- public:
-  static HInstruction* New(Isolate* isolate, Zone* zone, HValue* context,
-                           HValue* x, HValue* y, HValue* z, HValue* w,
-                           BuiltinFunctionId op);
-
-  HValue* context() { return OperandAt(0); }
-  HValue* x() const { return OperandAt(1); }
-  HValue* y() const { return OperandAt(2); }
-  HValue* z() const { return OperandAt(3); }
-  HValue* w() const { return OperandAt(4); }
-
-  std::ostream& PrintDataTo(std::ostream& os) const override;
-
-  Representation observed_input_representation(int index) override {
-    return RequiredInputRepresentation(index);
-  }
-  Representation RequiredInputRepresentation(int index) override {
-    if (index == 0) {
-      return Representation::Tagged();
-    } else {
-      switch (op_) {
-#define SIMD_QUARTERNARY_OPERATION_CASE_ITEM(                      \
-    p1, p2, name, p4, first_representation, second_representation, \
-    third_representation, fourth_representation)                   \
-  case k##name:                                                    \
-    switch (index) {                                               \
-      case 1:                                                      \
-        return Representation::first_representation();             \
-      case 2:                                                      \
-        return Representation::second_representation();            \
-      case 3:                                                      \
-        return Representation::third_representation();             \
-      case 4:                                                      \
-        return Representation::fourth_representation();            \
-      default:                                                     \
-        UNREACHABLE();                                             \
-        return Representation::None();                             \
-    }
-        SIMD_QUARTERNARY_OPERATIONS(SIMD_QUARTERNARY_OPERATION_CASE_ITEM)
-#undef SIMD_QUARTERNARY_OPERATION_CASE_ITEM
-        default:
-          UNREACHABLE();
-          return Representation::None();
-      }
-    }
-  }
-
-  BuiltinFunctionId op() const { return op_; }
-  const char* OpName() const;
-
-  DECLARE_CONCRETE_INSTRUCTION(QuarternarySIMDOperation)
-
- protected:
-  bool DataEquals(HValue* other) override {
-    HQuarternarySIMDOperation* b = HQuarternarySIMDOperation::cast(other);
-    return op_ == b->op();
-  }
-
- private:
-  HQuarternarySIMDOperation(HValue* context, HValue* x, HValue* y, HValue* z,
-                            HValue* w, BuiltinFunctionId op)
-      : HTemplateInstruction<5>(HType::None()), op_(op) {
-    SetOperandAt(0, context);
-    SetOperandAt(1, x);
-    SetOperandAt(2, y);
-    SetOperandAt(3, z);
-    SetOperandAt(4, w);
-    switch (op) {
-#define SIMD_QUARTERNARY_OPERATION_CASE_ITEM(p1, p2, name, representation, p5, \
-                                             p6, p7, p8)                       \
-  case k##name:                                                                \
-    set_representation(Representation::representation());                      \
-    set_type(HType::FromRepresentation(representation_));                      \
-    if (Representation::p5().IsInteger32() ||                                  \
-        Representation::p6().IsInteger32() ||                                  \
-        Representation::p7().IsInteger32() ||                                  \
-        Representation::p8().IsInteger32()) {                                  \
-      SetFlag(kTruncatingToInt32);                                             \
-    }                                                                          \
-    break;
-      SIMD_QUARTERNARY_OPERATIONS(SIMD_QUARTERNARY_OPERATION_CASE_ITEM)
-#undef SIMD_QUARTERNARY_OPERATION_CASE_ITEM
-      default:
-        UNREACHABLE();
-    }
-    SetFlag(kUseGVN);
-  }
-
-  bool IsDeletable() const override { return true; }
-
-  BuiltinFunctionId op_;
-};
-
-class HQuinarySIMDOperation final : public HTemplateInstruction<6> {
- public:
-  static HInstruction* New(Isolate* isolate, Zone* zone, HValue* context,
-                           HValue* a0, HValue* a1, HValue* a2, HValue* a3,
-                           HValue* a4, BuiltinFunctionId op);
-
-  HValue* context() { return OperandAt(0); }
-  HValue* a0() const { return OperandAt(1); }
-  HValue* a1() const { return OperandAt(2); }
-  HValue* a2() const { return OperandAt(3); }
-  HValue* a3() const { return OperandAt(4); }
-  HValue* a4() const { return OperandAt(5); }
-
-  std::ostream& PrintDataTo(std::ostream& os) const override;
-
-  Representation observed_input_representation(int index) override {
-    return RequiredInputRepresentation(index);
-  }
-  Representation RequiredInputRepresentation(int index) override {
-    if (index == 0) {
-      return Representation::Tagged();
-    } else {
-      switch (op_) {
-#define SIMD_QUINARY_OPERATION_CASE_ITEM(                              \
-    p1, p2, name, p4, first_representation, second_representation,     \
-    third_representation, fourth_representation, fifth_representation) \
-  case k##name:                                                        \
-    switch (index) {                                                   \
-      case 1:                                                          \
-        return Representation::first_representation();                 \
-      case 2:                                                          \
-        return Representation::second_representation();                \
-      case 3:                                                          \
-        return Representation::third_representation();                 \
-      case 4:                                                          \
-        return Representation::fourth_representation();                \
-      case 5:                                                          \
-        return Representation::fifth_representation();                 \
-      default:                                                         \
-        UNREACHABLE();                                                 \
-        return Representation::None();                                 \
-    }
-        SIMD_QUINARY_OPERATIONS(SIMD_QUINARY_OPERATION_CASE_ITEM)
-#undef SIMD_QUINARY_OPERATION_CASE_ITEM
-        default:
-          UNREACHABLE();
-          return Representation::None();
-      }
-    }
-  }
-
-  BuiltinFunctionId op() const { return op_; }
-  const char* OpName() const;
-
-  DECLARE_CONCRETE_INSTRUCTION(QuinarySIMDOperation)
-
- protected:
-  bool DataEquals(HValue* other) override {
-    HQuinarySIMDOperation* b = HQuinarySIMDOperation::cast(other);
-    return op_ == b->op();
-  }
-
- private:
-  HQuinarySIMDOperation(HValue* context, HValue* a0, HValue* a1, HValue* a2,
-                        HValue* a3, HValue* a4, BuiltinFunctionId op)
-      : HTemplateInstruction<6>(HType::None()), op_(op) {
-    SetOperandAt(0, context);
-    SetOperandAt(1, a0);
-    SetOperandAt(2, a1);
-    SetOperandAt(3, a2);
-    SetOperandAt(4, a3);
-    SetOperandAt(5, a4);
-    switch (op) {
-#define SIMD_QUINARY_OPERATION_CASE_ITEM(p1, p2, name, representation, p5, p6, \
-                                         p7, p8, p9)                           \
-  case k##name:                                                                \
-    set_representation(Representation::representation());                      \
-    set_type(HType::FromRepresentation(representation_));                      \
-    break;
-      SIMD_QUINARY_OPERATIONS(SIMD_QUINARY_OPERATION_CASE_ITEM)
-#undef SIMD_QUINARY_OPERATION_CASE_ITEM
-      default:
-        UNREACHABLE();
-    }
-    SetFlag(kUseGVN);
-  }
-
-  bool IsDeletable() const override { return true; }
-
-  BuiltinFunctionId op_;
-};
-
-class HSenarySIMDOperation final : public HTemplateInstruction<7> {
- public:
-  static HInstruction* New(Isolate* isolate, Zone* zone, HValue* context,
-                           HValue* a0, HValue* a1, HValue* a2, HValue* a3,
-                           HValue* a4, HValue* a5, BuiltinFunctionId op);
-
-  HValue* context() { return OperandAt(0); }
-  HValue* a0() const { return OperandAt(1); }
-  HValue* a1() const { return OperandAt(2); }
-  HValue* a2() const { return OperandAt(3); }
-  HValue* a3() const { return OperandAt(4); }
-  HValue* a4() const { return OperandAt(5); }
-  HValue* a5() const { return OperandAt(6); }
-
-  std::ostream& PrintDataTo(std::ostream& os) const override;
-
-  Representation observed_input_representation(int index) override {
-    return RequiredInputRepresentation(index);
-  }
-  Representation RequiredInputRepresentation(int index) override {
-    if (index == 0) {
-      return Representation::Tagged();
-    } else {
-      switch (op_) {
-#define SIMD_SENARY_OPERATION_CASE_ITEM(                               \
-    p1, p2, name, p4, first_representation, second_representation,     \
-    third_representation, fourth_representation, fifth_representation, \
-    sixth_representation)                                              \
-  case k##name:                                                        \
-    switch (index) {                                                   \
-      case 1:                                                          \
-        return Representation::first_representation();                 \
-      case 2:                                                          \
-        return Representation::second_representation();                \
-      case 3:                                                          \
-        return Representation::third_representation();                 \
-      case 4:                                                          \
-        return Representation::fourth_representation();                \
-      case 5:                                                          \
-        return Representation::fifth_representation();                 \
-      case 6:                                                          \
-        return Representation::sixth_representation();                 \
-      default:                                                         \
-        UNREACHABLE();                                                 \
-        return Representation::None();                                 \
-    }
-        SIMD_SENARY_OPERATIONS(SIMD_SENARY_OPERATION_CASE_ITEM)
-#undef SIMD_SENARY_OPERATION_CASE_ITEM
-        default:
-          UNREACHABLE();
-          return Representation::None();
-      }
-    }
-  }
-
-  BuiltinFunctionId op() const { return op_; }
-  const char* OpName() const;
-
-  DECLARE_CONCRETE_INSTRUCTION(SenarySIMDOperation)
-
- protected:
-  bool DataEquals(HValue* other) override {
-    HSenarySIMDOperation* b = HSenarySIMDOperation::cast(other);
-    return op_ == b->op();
-  }
-
- private:
-  HSenarySIMDOperation(HValue* context, HValue* a0, HValue* a1, HValue* a2,
-                       HValue* a3, HValue* a4, HValue* a5, BuiltinFunctionId op)
-      : HTemplateInstruction<7>(HType::None()), op_(op) {
-    SetOperandAt(0, context);
-    SetOperandAt(1, a0);
-    SetOperandAt(2, a1);
-    SetOperandAt(3, a2);
-    SetOperandAt(4, a3);
-    SetOperandAt(5, a4);
-    SetOperandAt(6, a5);
-    switch (op) {
-#define SIMD_SENARY_OPERATION_CASE_ITEM(p1, p2, name, representation, p5, p6, \
-                                        p7, p8, p9, p10)                      \
-  case k##name:                                                               \
-    set_representation(Representation::representation());                     \
-    set_type(HType::FromRepresentation(representation_));                     \
-    break;
-      SIMD_SENARY_OPERATIONS(SIMD_SENARY_OPERATION_CASE_ITEM)
-#undef SIMD_SENARY_OPERATION_CASE_ITEM
-      default:
-        UNREACHABLE();
-    }
-    SetFlag(kUseGVN);
-  }
-
-  bool IsDeletable() const override { return true; }
-
-  BuiltinFunctionId op_;
-};
-
 #undef DECLARE_INSTRUCTION
 #undef DECLARE_CONCRETE_INSTRUCTION
 
diff --git a/src/crankshaft/hydrogen-representation-changes.cc b/src/crankshaft/hydrogen-representation-changes.cc
index 7fc2e50c63..32b614c56c 100644
--- a/src/crankshaft/hydrogen-representation-changes.cc
+++ b/src/crankshaft/hydrogen-representation-changes.cc
@@ -36,20 +36,8 @@ void HRepresentationChangesPhase::InsertRepresentationChangeForUse(
   }
 
   if (new_value == NULL) {
-    if (((to.IsFloat32x4() || to.IsBool32x4() || to.IsInt32x4()) &&
-         !value->representation().IsTagged()) ||
-        ((value->representation().IsFloat32x4() ||
-          value->representation().IsBool32x4() ||
-          value->representation().IsInt32x4()) &&
-         !to.IsTagged())) {
-      new_value = HUnarySIMDOperation::New(
-          graph()->isolate(), graph()->zone(),
-          graph()->entry_block()->last_environment()->context(), value,
-          kSIMD128Change, to);
-    } else {
-      new_value = new (graph()->zone())
-          HChange(value, to, is_truncating_to_smi, is_truncating_to_int);
-    }
+    new_value = new(graph()->zone()) HChange(
+        value, to, is_truncating_to_smi, is_truncating_to_int);
     if (!use_value->operand_position(use_index).IsUnknown()) {
       new_value->set_position(use_value->operand_position(use_index));
     } else {
diff --git a/src/crankshaft/hydrogen-types.cc b/src/crankshaft/hydrogen-types.cc
index f81d24c28e..20d50d897c 100644
--- a/src/crankshaft/hydrogen-types.cc
+++ b/src/crankshaft/hydrogen-types.cc
@@ -7,7 +7,6 @@
 #include "src/field-type.h"
 #include "src/handles-inl.h"
 #include "src/ostreams.h"
-#include "src/property-details.h"
 
 namespace v8 {
 namespace internal {
@@ -44,9 +43,6 @@ HType HType::FromValue(Handle<Object> value) {
     double n = Handle<v8::internal::HeapNumber>::cast(value)->value();
     return IsSmiDouble(n) ? HType::Smi() : HType::HeapNumber();
   }
-  if (raw_value->IsFloat32x4()) return HType::Float32x4();
-  if (raw_value->IsBool32x4()) return HType::Bool32x4();
-  if (raw_value->IsInt32x4()) return HType::Int32x4();
   if (raw_value->IsString()) return HType::String();
   if (raw_value->IsBoolean()) return HType::Boolean();
   if (raw_value->IsUndefined(isolate)) return HType::Undefined();
@@ -60,22 +56,6 @@ HType HType::FromValue(Handle<Object> value) {
   return HType::HeapObject();
 }
 
-// static
-HType HType::FromRepresentation(Representation representation) {
-  HType result = HType::Tagged();
-  if (representation.IsSmi()) {
-    result = HType::Smi();
-  } else if (representation.IsDouble()) {
-    result = HType::HeapNumber();
-  } else if (representation.IsFloat32x4()) {
-    result = HType::Float32x4();
-  } else if (representation.IsBool32x4()) {
-    result = HType::Bool32x4();
-  } else if (representation.IsInt32x4()) {
-    result = HType::Int32x4();
-  }
-  return result;
-}
 
 std::ostream& operator<<(std::ostream& os, const HType& t) {
   // Note: The c1visualizer syntax for locals allows only a sequence of the
diff --git a/src/crankshaft/hydrogen-types.h b/src/crankshaft/hydrogen-types.h
index de2d64b662..0690ece34f 100644
--- a/src/crankshaft/hydrogen-types.h
+++ b/src/crankshaft/hydrogen-types.h
@@ -18,7 +18,6 @@ namespace internal {
 template <typename T> class Handle;
 class FieldType;
 class Object;
-class Representation;
 
 #define HTYPE_LIST(V)                               \
   V(Any, 0x0)             /* 0000 0000 0000 0000 */ \
@@ -30,16 +29,13 @@ class Representation;
   V(HeapPrimitive, 0x25)  /* 0000 0000 0010 0101 */ \
   V(Null, 0x27)           /* 0000 0000 0010 0111 */ \
   V(HeapNumber, 0x2d)     /* 0000 0000 0010 1101 */ \
-  V(Float32x4, 0x65)      /* 0000 0000 0110 0101 */ \
-  V(Bool32x4, 0xa5)       /* 0000 0000 1010 0101 */ \
-  V(Int32x4, 0x125)       /* 0000 0001 0010 0101 */ \
-  V(String, 0x225)        /* 0000 0010 0010 0101 */ \
-  V(Boolean, 0x425)       /* 0000 0100 0010 0101 */ \
-  V(Undefined, 0x825)     /* 0000 1000 0010 0101 */ \
-  V(JSReceiver, 0x1021)   /* 0001 0000 0010 0001 */ \
-  V(JSObject, 0x3021)     /* 0011 0000 0010 0001 */ \
-  V(JSArray, 0x7021)      /* 0111 0000 0010 0001 */ \
-  V(None, 0x7fff)         /* 0111 1111 1111 1111 */
+  V(String, 0x65)         /* 0000 0000 0110 0101 */ \
+  V(Boolean, 0xa5)        /* 0000 0000 1010 0101 */ \
+  V(Undefined, 0x125)     /* 0000 0001 0010 0101 */ \
+  V(JSReceiver, 0x221)    /* 0000 0010 0010 0001 */ \
+  V(JSObject, 0x621)      /* 0000 0110 0010 0001 */ \
+  V(JSArray, 0xe21)       /* 0000 1110 0010 0001 */ \
+  V(None, 0xfff)          /* 0000 1111 1111 1111 */
 
 class HType final {
  public:
@@ -72,7 +68,6 @@ class HType final {
   static HType FromFieldType(Handle<FieldType> type,
                              Zone* temp_zone) WARN_UNUSED_RESULT;
   static HType FromValue(Handle<Object> value) WARN_UNUSED_RESULT;
-  static HType FromRepresentation(Representation representation);
 
   friend std::ostream& operator<<(std::ostream& os, const HType& t);
 
diff --git a/src/crankshaft/hydrogen.cc b/src/crankshaft/hydrogen.cc
index 2b8c569b4b..23e090710a 100644
--- a/src/crankshaft/hydrogen.cc
+++ b/src/crankshaft/hydrogen.cc
@@ -2760,11 +2760,16 @@ HValue* HGraphBuilder::BuildStringAdd(
   return Pop();
 }
 
+
 HInstruction* HGraphBuilder::BuildUncheckedMonomorphicElementAccess(
-    HValue* checked_object, HValue* key, HValue* val, bool is_js_array,
-    ElementsKind elements_kind, PropertyAccessType access_type,
-    LoadKeyedHoleMode load_mode, KeyedAccessStoreMode store_mode,
-    BuiltinFunctionId op) {
+    HValue* checked_object,
+    HValue* key,
+    HValue* val,
+    bool is_js_array,
+    ElementsKind elements_kind,
+    PropertyAccessType access_type,
+    LoadKeyedHoleMode load_mode,
+    KeyedAccessStoreMode store_mode) {
   DCHECK(top_info()->IsStub() || checked_object->IsCompareMap() ||
          checked_object->IsCheckMaps());
   DCHECK(!IsFixedTypedArrayElementsKind(elements_kind) || !is_js_array);
@@ -2827,10 +2832,10 @@ HInstruction* HGraphBuilder::BuildUncheckedMonomorphicElementAccess(
       return result;
     } else {
       DCHECK(store_mode == STANDARD_STORE);
-      checked_key = Add<HBoundsCheck>(key, length, op, elements_kind);
+      checked_key = Add<HBoundsCheck>(key, length);
       return AddElementAccess(backing_store, checked_key, val, checked_object,
                               checked_object->ActualValue(), elements_kind,
-                              access_type, NEVER_RETURN_HOLE, op);
+                              access_type);
     }
   }
   DCHECK(fast_smi_only_elements ||
@@ -2870,7 +2875,7 @@ HInstruction* HGraphBuilder::BuildUncheckedMonomorphicElementAccess(
     }
   }
   return AddElementAccess(elements, checked_key, val, checked_object, nullptr,
-                          elements_kind, access_type, load_mode, op);
+                          elements_kind, access_type, load_mode);
 }
 
 
@@ -3029,27 +3034,25 @@ void HGraphBuilder::BuildJSArrayHeader(HValue* array,
   }
 }
 
+
 HInstruction* HGraphBuilder::AddElementAccess(
     HValue* elements, HValue* checked_key, HValue* val, HValue* dependency,
     HValue* backing_store_owner, ElementsKind elements_kind,
-    PropertyAccessType access_type, LoadKeyedHoleMode load_mode,
-    BuiltinFunctionId op) {
+    PropertyAccessType access_type, LoadKeyedHoleMode load_mode) {
   if (access_type == STORE) {
     DCHECK(val != NULL);
     if (elements_kind == UINT8_CLAMPED_ELEMENTS) {
       val = Add<HClampToUint8>(val);
     }
     return Add<HStoreKeyed>(elements, checked_key, val, backing_store_owner,
-                            elements_kind, STORE_TO_INITIALIZED_ENTRY,
-                            kDefaultKeyedHeaderOffsetSentinel, op);
+                            elements_kind, STORE_TO_INITIALIZED_ENTRY);
   }
 
   DCHECK(access_type == LOAD);
   DCHECK(val == NULL);
-  HLoadKeyed* load = Add<HLoadKeyed>(
-      elements, checked_key, dependency, backing_store_owner, elements_kind,
-      load_mode, kDefaultKeyedHeaderOffsetSentinel, op);
-
+  HLoadKeyed* load =
+      Add<HLoadKeyed>(elements, checked_key, dependency, backing_store_owner,
+                      elements_kind, load_mode);
   if (elements_kind == UINT32_ELEMENTS) {
     graph()->RecordUint32Instruction(load);
   }
@@ -6596,7 +6599,6 @@ bool HOptimizedGraphBuilder::PropertyAccessInfo::CanAccessAsMonomorphic(
   if (!CanAccessMonomorphic()) return false;
   STATIC_ASSERT(kMaxLoadPolymorphism == kMaxStorePolymorphism);
   if (maps->length() > kMaxLoadPolymorphism) return false;
-
   HObjectAccess access = HObjectAccess::ForMap();  // bogus default
   if (GetJSObjectFieldAccess(&access)) {
     for (int i = 1; i < maps->length(); ++i) {
@@ -6649,6 +6651,7 @@ bool HOptimizedGraphBuilder::PropertyAccessInfo::NeedsWrappingFor(
   return NeedsWrapping(map_, target);
 }
 
+
 HValue* HOptimizedGraphBuilder::BuildMonomorphicAccess(
     PropertyAccessInfo* info, HValue* object, HValue* checked_object,
     HValue* value, BailoutId ast_id, BailoutId return_id,
@@ -6929,6 +6932,7 @@ static bool AreStringTypes(SmallMapList* maps) {
   return true;
 }
 
+
 void HOptimizedGraphBuilder::BuildStore(Expression* expr, Property* prop,
                                         FeedbackVectorSlot slot,
                                         BailoutId ast_id, BailoutId return_id,
@@ -8883,7 +8887,7 @@ bool HOptimizedGraphBuilder::TryInlineBuiltinFunctionCall(Call* expr) {
       // Not supported for inlining yet.
       break;
   }
-  return TryInlineSIMDBuiltinCall(expr, id, expr->arguments()->length() + 1);
+  return false;
 }
 
 
@@ -9367,166 +9371,13 @@ bool HOptimizedGraphBuilder::TryInlineBuiltinMethodCall(
       ast_context()->ReturnValue(index);
       return true;
     }
-#define SIMD_NULLARY_OPERATION_CASE_ITEM(p1, p2, name, p4) case k##name:
-      SIMD_NULLARY_OPERATIONS(SIMD_NULLARY_OPERATION_CASE_ITEM)
-#undef SIMD_NULLARY_OPERATION_CASE_ITEM
-      if (CpuFeatures::SupportsSIMD128InCrankshaft() && argument_count == 1) {
-        Drop(2);  // Receiver and function.
-        HInstruction* op = NewUncasted<HNullarySIMDOperation>(id);
-        ast_context()->ReturnInstruction(op, ast_id);
-        return true;
-      }
-      break;
-#define SIMD_UNARY_OPERATION_CASE_ITEM(p1, p2, name, p4, p5) case k##name:
-      SIMD_UNARY_OPERATIONS(SIMD_UNARY_OPERATION_CASE_ITEM)
-#undef SIMD_UNARY_OPERATION_CASE_ITEM
-      if (CpuFeatures::SupportsSIMD128InCrankshaft() && argument_count == 2) {
-        HValue* argument = Pop();
-        Drop(2);  // Receiver and function.
-        HInstruction* op = NewUncasted<HUnarySIMDOperation>(argument, id);
-        ast_context()->ReturnInstruction(op, ast_id);
-        return true;
-      }
-      break;
-#define SIMD_BINARY_OPERATION_CASE_ITEM(p1, p2, name, p4, p5, p6) case k##name:
-      SIMD_BINARY_OPERATIONS(SIMD_BINARY_OPERATION_CASE_ITEM)
-#undef SIMD_BINARY_OPERATION_CASE_ITEM
-      if (CpuFeatures::SupportsSIMD128InCrankshaft() && argument_count == 3) {
-        HValue* right = Pop();
-        HValue* left = Pop();
-        Drop(2);  // Receiver and function.
-        HInstruction* op = NewUncasted<HBinarySIMDOperation>(left, right, id);
-        ast_context()->ReturnInstruction(op, ast_id);
-        return true;
-      }
-      break;
-#define SIMD_TERNARY_OPERATION_CASE_ITEM(p1, p2, name, p4, p5, p6, p7) \
-  case k##name:
-      SIMD_TERNARY_OPERATIONS(SIMD_TERNARY_OPERATION_CASE_ITEM)
-#undef SIMD_TERNARY_OPERATION_CASE_ITEM
-      if (CpuFeatures::SupportsSIMD128InCrankshaft() && argument_count == 4) {
-        HValue* right = Pop();
-        HValue* left = Pop();
-        HValue* value = Pop();
-        Drop(2);  // Receiver and function.
-        HInstruction* op =
-            NewUncasted<HTernarySIMDOperation>(value, left, right, id);
-        ast_context()->ReturnInstruction(op, ast_id);
-        return true;
-      }
-      break;
-#define SIMD_QUARTERNARY_OPERATION_CASE_ITEM(p1, p2, name, p4, p5, p6, p7, p8) \
-  case k##name:
-      SIMD_QUARTERNARY_OPERATIONS(SIMD_QUARTERNARY_OPERATION_CASE_ITEM)
-#undef SIMD_QUARTERNARY_OPERATION_CASE_ITEM
-      if (CpuFeatures::SupportsSIMD128InCrankshaft() && argument_count == 5) {
-        HValue* w = Pop();
-        HValue* z = Pop();
-        HValue* y = Pop();
-        HValue* x = Pop();
-        Drop(2);  // Receiver and function.
-        HValue* context = environment()->context();
-        HInstruction* op = HQuarternarySIMDOperation::New(
-            isolate(), zone(), context, x, y, z, w, id);
-        ast_context()->ReturnInstruction(op, ast_id);
-        return true;
-      }
-      break;
-#define SIMD_QUINARY_OPERATION_CASE_ITEM(p1, p2, name, p4, p5, p6, p7, p8, p9) \
-  case k##name:
-      SIMD_QUINARY_OPERATIONS(SIMD_QUINARY_OPERATION_CASE_ITEM)
-#undef SIMD_QUINARY_OPERATION_CASE_ITEM
-      if (CpuFeatures::SupportsSIMD128InCrankshaft() &&
-          args_count_no_receiver == 5) {
-        HValue* a4 = Pop();
-        HValue* a3 = Pop();
-        HValue* a2 = Pop();
-        HValue* a1 = Pop();
-        HValue* a0 = Pop();
-        Drop(2);  // Receiver and function.
-        HInstruction* op =
-            NewUncasted<HQuinarySIMDOperation>(a0, a1, a2, a3, a4, id);
-        ast_context()->ReturnInstruction(op, ast_id);
-        return true;
-      }
-      break;
-#define SIMD_SENARY_OPERATION_CASE_ITEM(p1, p2, name, p4, p5, p6, p7, p8, p9, \
-                                        p10)                                  \
-  case k##name:
-      SIMD_SENARY_OPERATIONS(SIMD_SENARY_OPERATION_CASE_ITEM)
-#undef SIMD_SENARY_OPERATION_CASE_ITEM
-      if (CpuFeatures::SupportsSIMD128InCrankshaft() &&
-          args_count_no_receiver == 6) {
-        HValue* a5 = Pop();
-        HValue* a4 = Pop();
-        HValue* a3 = Pop();
-        HValue* a2 = Pop();
-        HValue* a1 = Pop();
-        HValue* a0 = Pop();
-        Drop(2);  // Receiver and function.
-        HInstruction* op =
-            NewUncasted<HSenarySIMDOperation>(a0, a1, a2, a3, a4, a5, id);
-        ast_context()->ReturnInstruction(op, ast_id);
-        return true;
-      }
-      break;
-#define TYPED_ARRAY_SIMD_LOAD_OPERATION_CASE_ITEM(p1, p2, name) case k##name:
-      TYPED_ARRAYS_SIMD_LOAD_OPERATIONS(
-          TYPED_ARRAY_SIMD_LOAD_OPERATION_CASE_ITEM)
-#undef TYPED_ARRAY_SIMD_LOAD_OPERATION_CASE_ITEM
-      if (receiver_map.is_null()) return false;
-      if (CpuFeatures::SupportsSIMD128InCrankshaft() && argument_count == 2) {
-#if V8_TARGET_ARCH_X64
-        // TODO(nhu): support x64.
-        return false;
-#else
-        HValue* key = Pop();
-        HValue* tarray = Pop();
-        Drop(1);  // Drop function.
-        HInstruction* instr = BuildUncheckedMonomorphicElementAccess(
-            tarray, key, NULL, receiver_map->instance_type() == JS_ARRAY_TYPE,
-            receiver_map->elements_kind(),
-            LOAD,               // is_store.
-            NEVER_RETURN_HOLE,  // load_mode.
-            STANDARD_STORE, id);
-        ast_context()->ReturnValue(instr);
-        return true;
-#endif
-      }
-      break;
-#define TYPED_ARRAY_SIMD_STORE_OPERATION_CASE_ITEM(p1, p2, name) case k##name:
-      TYPED_ARRAYS_SIMD_STORE_OPERATIONS(
-          TYPED_ARRAY_SIMD_STORE_OPERATION_CASE_ITEM)
-#undef TYPED_ARRAY_SIMD_STORE_OPERATION_CASE_ITEM
-      if (receiver_map.is_null()) return false;
-      if (CpuFeatures::SupportsSIMD128InCrankshaft() && argument_count == 3) {
-#if V8_TARGET_ARCH_X64
-        // TODO(nhu): support x64.
-        return false;
-#else
-        HValue* value = Pop();
-        HValue* key = Pop();
-        HValue* tarray = Pop();
-        Drop(1);  // Drop function.
-        BuildUncheckedMonomorphicElementAccess(
-            tarray, key, value, receiver_map->instance_type() == JS_ARRAY_TYPE,
-            receiver_map->elements_kind(),
-            STORE,              // is_store.
-            NEVER_RETURN_HOLE,  // load_mode.
-            STANDARD_STORE, id);
-        Push(value);
-        Add<HSimulate>(ast_id, REMOVABLE_SIMULATE);
-        ast_context()->ReturnValue(Pop());
-        return true;
-#endif
-      }
-      break;
     default:
       // Not yet supported for inlining.
       break;
   }
   return false;
-}  // NOLINT(readability/fn_size)
+}
+
 
 bool HOptimizedGraphBuilder::TryInlineApiFunctionCall(Call* expr,
                                                       HValue* receiver) {
@@ -10532,118 +10383,6 @@ void HGraphBuilder::BuildArrayBufferViewInitialization(
                         buffer);
 }
 
-bool HOptimizedGraphBuilder::TryInlineSIMDBuiltinCall(Call* expr,
-                                                      BuiltinFunctionId id,
-                                                      int argument_count) {
-  switch (id) {
-#define SIMD_NULLARY_OPERATION_CASE_ITEM(p1, p2, name, p4) case k##name:
-    SIMD_NULLARY_OPERATIONS(SIMD_NULLARY_OPERATION_CASE_ITEM)
-#undef SIMD_NULLARY_OPERATION_CASE_ITEM
-    if (CpuFeatures::SupportsSIMD128InCrankshaft() && argument_count == 1) {
-      Drop(2);  // Receiver and function.
-      HInstruction* op = NewUncasted<HNullarySIMDOperation>(id);
-      ast_context()->ReturnInstruction(op, expr->id());
-      return true;
-    }
-    break;
-#define SIMD_UNARY_OPERATION_CASE_ITEM(p1, p2, name, p4, p5) case k##name:
-    SIMD_UNARY_OPERATIONS(SIMD_UNARY_OPERATION_CASE_ITEM)
-#undef SIMD_UNARY_OPERATION_CASE_ITEM
-    if (CpuFeatures::SupportsSIMD128InCrankshaft() && argument_count == 2) {
-      HValue* argument = Pop();
-      Drop(2);  // Receiver and function.
-      HInstruction* op = NewUncasted<HUnarySIMDOperation>(argument, id);
-      ast_context()->ReturnInstruction(op, expr->id());
-      return true;
-    }
-    break;
-#define SIMD_BINARY_OPERATION_CASE_ITEM(p1, p2, name, p4, p5, p6) case k##name:
-    SIMD_BINARY_OPERATIONS(SIMD_BINARY_OPERATION_CASE_ITEM)
-#undef SIMD_BINARY_OPERATION_CASE_ITEM
-    if (CpuFeatures::SupportsSIMD128InCrankshaft() && argument_count == 3) {
-      HValue* right = Pop();
-      HValue* left = Pop();
-      Drop(2);  // Receiver and function.
-      HInstruction* op = NewUncasted<HBinarySIMDOperation>(left, right, id);
-      ast_context()->ReturnInstruction(op, expr->id());
-      return true;
-    }
-    break;
-#define SIMD_TERNARY_OPERATION_CASE_ITEM(p1, p2, name, p4, p5, p6, p7) \
-  case k##name:
-    SIMD_TERNARY_OPERATIONS(SIMD_TERNARY_OPERATION_CASE_ITEM)
-#undef SIMD_TERNARY_OPERATION_CASE_ITEM
-    if (CpuFeatures::SupportsSIMD128InCrankshaft() && argument_count == 4) {
-      HValue* right = Pop();
-      HValue* left = Pop();
-      HValue* value = Pop();
-      Drop(2);  // Receiver and function.
-      HInstruction* op =
-          NewUncasted<HTernarySIMDOperation>(value, left, right, id);
-      ast_context()->ReturnInstruction(op, expr->id());
-      return true;
-    }
-    break;
-#define SIMD_QUARTERNARY_OPERATION_CASE_ITEM(p1, p2, name, p4, p5, p6, p7, p8) \
-  case k##name:
-    SIMD_QUARTERNARY_OPERATIONS(SIMD_QUARTERNARY_OPERATION_CASE_ITEM)
-#undef SIMD_QUARTERNARY_OPERATION_CASE_ITEM
-    if (CpuFeatures::SupportsSIMD128InCrankshaft() && argument_count == 5) {
-      HValue* w = Pop();
-      HValue* z = Pop();
-      HValue* y = Pop();
-      HValue* x = Pop();
-      Drop(2);  // Receiver and function.
-      HValue* context = environment()->context();
-      HInstruction* op = HQuarternarySIMDOperation::New(
-          isolate(), zone(), context, x, y, z, w, id);
-      ast_context()->ReturnInstruction(op, expr->id());
-      return true;
-    }
-    break;
-#define SIMD_QUINARY_OPERATION_CASE_ITEM(p1, p2, name, p4, p5, p6, p7, p8, p9) \
-  case k##name:
-    SIMD_QUINARY_OPERATIONS(SIMD_QUINARY_OPERATION_CASE_ITEM)
-#undef SIMD_QUINARY_OPERATION_CASE_ITEM
-    if (CpuFeatures::SupportsSIMD128InCrankshaft() &&
-        expr->arguments()->length() == 5) {
-      HValue* a4 = Pop();
-      HValue* a3 = Pop();
-      HValue* a2 = Pop();
-      HValue* a1 = Pop();
-      HValue* a0 = Pop();
-      Drop(2);  // Receiver and function.
-      HInstruction* op =
-          NewUncasted<HQuinarySIMDOperation>(a0, a1, a2, a3, a4, id);
-      ast_context()->ReturnInstruction(op, expr->id());
-      return true;
-    }
-    break;
-#define SIMD_SENARY_OPERATION_CASE_ITEM(p1, p2, name, p4, p5, p6, p7, p8, p9, \
-                                        p10)                                  \
-  case k##name:
-    SIMD_SENARY_OPERATIONS(SIMD_SENARY_OPERATION_CASE_ITEM)
-#undef SIMD_SENARY_OPERATION_CASE_ITEM
-    if (CpuFeatures::SupportsSIMD128InCrankshaft() &&
-        expr->arguments()->length() == 6) {
-      HValue* a5 = Pop();
-      HValue* a4 = Pop();
-      HValue* a3 = Pop();
-      HValue* a2 = Pop();
-      HValue* a1 = Pop();
-      HValue* a0 = Pop();
-      Drop(2);  // Receiver and function.
-      HInstruction* op =
-          NewUncasted<HSenarySIMDOperation>(a0, a1, a2, a3, a4, a5, id);
-      ast_context()->ReturnInstruction(op, expr->id());
-      return true;
-    }
-    break;
-    default:
-      break;
-  }
-  return false;
-}
 
 HValue* HOptimizedGraphBuilder::BuildAllocateExternalElements(
     ExternalArrayType array_type,
@@ -11926,11 +11665,9 @@ bool IsLiteralCompareStrict(Isolate* isolate, HValue* left, Token::Value op,
   return op == Token::EQ_STRICT &&
          ((left->IsConstant() &&
            !HConstant::cast(left)->handle(isolate)->IsNumber() &&
-           !HConstant::cast(left)->handle(isolate)->IsSimd128Value() &&
            !HConstant::cast(left)->handle(isolate)->IsString()) ||
           (right->IsConstant() &&
            !HConstant::cast(right)->handle(isolate)->IsNumber() &&
-           !HConstant::cast(right)->handle(isolate)->IsSimd128Value() &&
            !HConstant::cast(right)->handle(isolate)->IsString()));
 }
 
@@ -13816,30 +13553,6 @@ void HTracer::TraceLiveRange(LiveRange* range, const char* type,
       if (op->IsDoubleRegister()) {
         trace_.Add(" \"%s\"",
                    GetRegConfig()->GetDoubleRegisterName(assigned_reg));
-      } else if (op->IsFloat32x4Register()) {
-#if V8_TARGET_ARCH_IA32 || V8_TARGET_ARCH_X64
-        trace_.Add(" \"%s\"",
-                   RegisterConfiguration::Crankshaft()->GetSimd128RegisterName(
-                       assigned_reg));
-#else
-        trace_.Add(" \"%s\"", "target hasn't no method toString()");
-#endif
-      } else if (op->IsBool32x4Register()) {
-#if V8_TARGET_ARCH_IA32 || V8_TARGET_ARCH_X64
-        trace_.Add(" \"%s\"",
-                   RegisterConfiguration::Crankshaft()->GetSimd128RegisterName(
-                       assigned_reg));
-#else
-        trace_.Add(" \"%s\"", "target hasn't no method toString()");
-#endif
-      } else if (op->IsInt32x4Register()) {
-#if V8_TARGET_ARCH_IA32 || V8_TARGET_ARCH_X64
-        trace_.Add(" \"%s\"",
-                   RegisterConfiguration::Crankshaft()->GetSimd128RegisterName(
-                       assigned_reg));
-#else
-        trace_.Add(" \"%s\"", "target hasn't no method toString()");
-#endif
       } else {
         DCHECK(op->IsRegister());
         trace_.Add(" \"%s\"",
@@ -13849,12 +13562,6 @@ void HTracer::TraceLiveRange(LiveRange* range, const char* type,
       LOperand* op = range->TopLevel()->GetSpillOperand();
       if (op->IsDoubleStackSlot()) {
         trace_.Add(" \"double_stack:%d\"", op->index());
-      } else if (op->IsFloat32x4StackSlot()) {
-        trace_.Add(" \"float32x4_stack:%d\"", op->index());
-      } else if (op->IsBool32x4StackSlot()) {
-        trace_.Add(" \"bool32x4_stack:%d\"", op->index());
-      } else if (op->IsInt32x4StackSlot()) {
-        trace_.Add(" \"int32x4_stack:%d\"", op->index());
       } else {
         DCHECK(op->IsStackSlot());
         trace_.Add(" \"stack:%d\"", op->index());
diff --git a/src/crankshaft/hydrogen.h b/src/crankshaft/hydrogen.h
index abf04ac097..d0f757bdf0 100644
--- a/src/crankshaft/hydrogen.h
+++ b/src/crankshaft/hydrogen.h
@@ -1466,17 +1466,20 @@ class HGraphBuilder {
                          HAllocationMode allocation_mode);
 
   HInstruction* BuildUncheckedMonomorphicElementAccess(
-      HValue* checked_object, HValue* key, HValue* val, bool is_js_array,
-      ElementsKind elements_kind, PropertyAccessType access_type,
-      LoadKeyedHoleMode load_mode, KeyedAccessStoreMode store_mode,
-      BuiltinFunctionId id = kNumberOfBuiltinFunction);
+      HValue* checked_object,
+      HValue* key,
+      HValue* val,
+      bool is_js_array,
+      ElementsKind elements_kind,
+      PropertyAccessType access_type,
+      LoadKeyedHoleMode load_mode,
+      KeyedAccessStoreMode store_mode);
 
   HInstruction* AddElementAccess(
       HValue* elements, HValue* checked_key, HValue* val, HValue* dependency,
       HValue* backing_store_owner, ElementsKind elements_kind,
       PropertyAccessType access_type,
-      LoadKeyedHoleMode load_mode = NEVER_RETURN_HOLE,
-      BuiltinFunctionId id = kNumberOfBuiltinFunction);
+      LoadKeyedHoleMode load_mode = NEVER_RETURN_HOLE);
 
   HInstruction* AddLoadStringInstanceType(HValue* string);
   HInstruction* AddLoadStringLength(HValue* string);
@@ -2889,9 +2892,6 @@ class HOptimizedGraphBuilder : public HGraphBuilder, public AstVisitor {
 
   bool CanBeFunctionApplyArguments(Call* expr);
 
-  bool TryInlineSIMDBuiltinCall(Call* expr, BuiltinFunctionId id,
-                                int argument_count);
-
   // The translation state of the currently-being-translated function.
   FunctionState* function_state_;
 
diff --git a/src/crankshaft/ia32/lithium-codegen-ia32.cc b/src/crankshaft/ia32/lithium-codegen-ia32.cc
index 0e2636cfdd..e4854e70d5 100644
--- a/src/crankshaft/ia32/lithium-codegen-ia32.cc
+++ b/src/crankshaft/ia32/lithium-codegen-ia32.cc
@@ -19,75 +19,6 @@
 namespace v8 {
 namespace internal {
 
-inline bool IsSIMD128LoadStoreOp(BuiltinFunctionId op) {
-  return (
-      op == kFloat32ArrayGetFloat32x4XYZW || op == kFloat32ArrayGetFloat32x4X ||
-      op == kFloat32ArrayGetFloat32x4XY || op == kFloat32ArrayGetFloat32x4XYZ ||
-      op == kInt32ArrayGetInt32x4XYZW || op == kInt32ArrayGetInt32x4X ||
-      op == kInt32ArrayGetInt32x4XY || op == kInt32ArrayGetInt32x4XYZ ||
-      op == kInt8ArrayGetFloat32x4XYZW || op == kInt8ArrayGetFloat32x4X ||
-      op == kInt8ArrayGetFloat32x4XY || op == kInt8ArrayGetFloat32x4XYZ ||
-      op == kInt8ArrayGetInt32x4XYZW || op == kInt8ArrayGetInt32x4X ||
-      op == kInt8ArrayGetInt32x4XY || op == kInt8ArrayGetInt32x4XYZ ||
-      op == kUint8ArrayGetFloat32x4XYZW || op == kUint8ArrayGetFloat32x4X ||
-      op == kUint8ArrayGetFloat32x4XY || op == kUint8ArrayGetFloat32x4XYZ ||
-      op == kUint8ArrayGetInt32x4XYZW || op == kUint8ArrayGetInt32x4X ||
-      op == kUint8ArrayGetInt32x4XY || op == kUint8ArrayGetInt32x4XYZ ||
-      op == kFloat32ArraySetFloat32x4XYZW || op == kFloat32ArraySetFloat32x4X ||
-      op == kFloat32ArraySetFloat32x4XY || op == kFloat32ArraySetFloat32x4XYZ ||
-      op == kInt32ArraySetInt32x4XYZW || op == kInt32ArraySetInt32x4X ||
-      op == kInt32ArraySetInt32x4XY || op == kInt32ArraySetInt32x4XYZ ||
-      op == kInt8ArraySetFloat32x4XYZW || op == kInt8ArraySetFloat32x4X ||
-      op == kInt8ArraySetFloat32x4XY || op == kInt8ArraySetFloat32x4XYZ ||
-      op == kInt8ArraySetInt32x4XYZW || op == kInt8ArraySetInt32x4X ||
-      op == kInt8ArraySetInt32x4XY || op == kInt8ArraySetInt32x4XYZ ||
-      op == kUint8ArraySetFloat32x4XYZW || op == kUint8ArraySetFloat32x4X ||
-      op == kUint8ArraySetFloat32x4XY || op == kUint8ArraySetFloat32x4XYZ ||
-      op == kUint8ArraySetInt32x4XYZW || op == kUint8ArraySetInt32x4X ||
-      op == kUint8ArraySetInt32x4XY || op == kUint8ArraySetInt32x4XYZ);
-}
-
-int GetSIMD128LoadStoreBytes(BuiltinFunctionId op) {
-  if (op == kFloat32ArrayGetFloat32x4XYZW || op == kInt32ArrayGetInt32x4XYZW ||
-      op == kInt8ArrayGetFloat32x4XYZW || op == kInt8ArrayGetInt32x4XYZW ||
-      op == kUint8ArrayGetFloat32x4XYZW || op == kUint8ArrayGetInt32x4XYZW ||
-      op == kFloat32ArraySetFloat32x4XYZW || op == kInt32ArraySetInt32x4XYZW ||
-      op == kInt8ArraySetFloat32x4XYZW || op == kInt8ArraySetInt32x4XYZW ||
-      op == kUint8ArraySetFloat32x4XYZW || op == kUint8ArraySetInt32x4XYZW) {
-    return 16;
-  } else if (op == kFloat32ArrayGetFloat32x4X || op == kInt32ArrayGetInt32x4X ||
-             op == kInt8ArrayGetFloat32x4X || op == kInt8ArrayGetInt32x4X ||
-             op == kUint8ArrayGetFloat32x4X || op == kUint8ArrayGetInt32x4X ||
-             op == kFloat32ArraySetFloat32x4X || op == kInt32ArraySetInt32x4X ||
-             op == kInt8ArraySetFloat32x4X || op == kInt8ArraySetInt32x4X ||
-             op == kUint8ArraySetFloat32x4X || op == kUint8ArraySetInt32x4X) {
-    return 4;
-  } else if (op == kFloat32ArrayGetFloat32x4XY ||
-             op == kInt32ArrayGetInt32x4XY || op == kInt8ArrayGetFloat32x4XY ||
-             op == kInt8ArrayGetInt32x4XY || op == kUint8ArrayGetFloat32x4XY ||
-             op == kUint8ArrayGetInt32x4XY ||
-             op == kFloat32ArraySetFloat32x4XY ||
-             op == kInt32ArraySetInt32x4XY || op == kInt8ArraySetFloat32x4XY ||
-             op == kInt8ArraySetInt32x4XY || op == kUint8ArraySetFloat32x4XY ||
-             op == kUint8ArraySetInt32x4XY) {
-    return 8;
-  } else if (op == kFloat32ArrayGetFloat32x4XYZ ||
-             op == kInt32ArrayGetInt32x4XYZ ||
-             op == kInt8ArrayGetFloat32x4XYZ || op == kInt8ArrayGetInt32x4XYZ ||
-             op == kUint8ArrayGetFloat32x4XYZ ||
-             op == kUint8ArrayGetInt32x4XYZ ||
-             op == kFloat32ArraySetFloat32x4XYZ ||
-             op == kInt32ArraySetInt32x4XYZ ||
-             op == kInt8ArraySetFloat32x4XYZ || op == kInt8ArraySetInt32x4XYZ ||
-             op == kUint8ArraySetFloat32x4XYZ ||
-             op == kUint8ArraySetInt32x4XYZ) {
-    return 12;
-  } else {
-    UNREACHABLE();
-    return -1;
-  }
-}
-
 // When invoking builtins, we need to record the safepoint in the middle of
 // the invoke instruction sequence generated by the macro assembler.
 class SafepointGenerator final : public CallWrapper {
@@ -456,9 +387,6 @@ XMMRegister LCodeGen::ToDoubleRegister(int code) const {
   return XMMRegister::from_code(code);
 }
 
-XMMRegister LCodeGen::ToSIMD128Register(int code) const {
-  return XMMRegister::from_code(code);
-}
 
 Register LCodeGen::ToRegister(LOperand* op) const {
   DCHECK(op->IsRegister());
@@ -471,26 +399,6 @@ XMMRegister LCodeGen::ToDoubleRegister(LOperand* op) const {
   return ToDoubleRegister(op->index());
 }
 
-XMMRegister LCodeGen::ToFloat32x4Register(LOperand* op) const {
-  DCHECK(op->IsFloat32x4Register());
-  return ToSIMD128Register(op->index());
-}
-
-XMMRegister LCodeGen::ToBool32x4Register(LOperand* op) const {
-  DCHECK(op->IsBool32x4Register());
-  return ToSIMD128Register(op->index());
-}
-
-XMMRegister LCodeGen::ToInt32x4Register(LOperand* op) const {
-  DCHECK(op->IsInt32x4Register());
-  return ToSIMD128Register(op->index());
-}
-
-XMMRegister LCodeGen::ToSIMD128Register(LOperand* op) const {
-  DCHECK(op->IsFloat32x4Register() || op->IsBool32x4Register() ||
-         op->IsInt32x4Register());
-  return ToSIMD128Register(op->index());
-}
 
 int32_t LCodeGen::ToInteger32(LConstantOperand* op) const {
   return ToRepresentation(op, Representation::Integer32());
@@ -551,12 +459,7 @@ static int ArgumentsOffsetWithoutFrame(int index) {
 Operand LCodeGen::ToOperand(LOperand* op) const {
   if (op->IsRegister()) return Operand(ToRegister(op));
   if (op->IsDoubleRegister()) return Operand(ToDoubleRegister(op));
-  if (op->IsFloat32x4Register()) return Operand(ToFloat32x4Register(op));
-  if (op->IsBool32x4Register()) return Operand(ToBool32x4Register(op));
-  if (op->IsInt32x4Register()) return Operand(ToInt32x4Register(op));
-  DCHECK(op->IsStackSlot() || op->IsDoubleStackSlot() ||
-         op->IsFloat32x4StackSlot() || op->IsBool32x4StackSlot() ||
-         op->IsInt32x4StackSlot());
+  DCHECK(op->IsStackSlot() || op->IsDoubleStackSlot());
   if (NeedsEagerFrame()) {
     return Operand(ebp, FrameSlotToFPOffset(op->index()));
   } else {
@@ -649,25 +552,6 @@ void LCodeGen::AddToTranslation(LEnvironment* environment,
   } else if (op->IsDoubleStackSlot()) {
     int index = op->index();
     translation->StoreDoubleStackSlot(index);
-  } else if (op->IsFloat32x4StackSlot()) {
-    int index = op->index();
-    if (index >= 0) {
-      index += StandardFrameConstants::kFixedFrameSize / kPointerSize;
-    }
-    translation->StoreSIMD128StackSlot(index,
-                                       Translation::FLOAT32x4_STACK_SLOT);
-  } else if (op->IsBool32x4StackSlot()) {
-    int index = op->index();
-    if (index >= 0) {
-      index += StandardFrameConstants::kFixedFrameSize / kPointerSize;
-    }
-    translation->StoreSIMD128StackSlot(index, Translation::BOOL32x4_STACK_SLOT);
-  } else if (op->IsInt32x4StackSlot()) {
-    int index = op->index();
-    if (index >= 0) {
-      index += StandardFrameConstants::kFixedFrameSize / kPointerSize;
-    }
-    translation->StoreSIMD128StackSlot(index, Translation::INT32x4_STACK_SLOT);
   } else if (op->IsRegister()) {
     Register reg = ToRegister(op);
     if (is_tagged) {
@@ -680,15 +564,6 @@ void LCodeGen::AddToTranslation(LEnvironment* environment,
   } else if (op->IsDoubleRegister()) {
     XMMRegister reg = ToDoubleRegister(op);
     translation->StoreDoubleRegister(reg);
-  } else if (op->IsFloat32x4Register()) {
-    XMMRegister reg = ToFloat32x4Register(op);
-    translation->StoreSIMD128Register(reg, Translation::FLOAT32x4_REGISTER);
-  } else if (op->IsBool32x4Register()) {
-    XMMRegister reg = ToBool32x4Register(op);
-    translation->StoreSIMD128Register(reg, Translation::BOOL32x4_REGISTER);
-  } else if (op->IsInt32x4Register()) {
-    XMMRegister reg = ToInt32x4Register(op);
-    translation->StoreSIMD128Register(reg, Translation::INT32x4_REGISTER);
   } else if (op->IsConstantOperand()) {
     HConstant* constant = chunk()->LookupConstant(LConstantOperand::cast(op));
     int src_index = DefineDeoptimizationLiteral(constant->handle(isolate()));
@@ -812,7 +687,6 @@ void LCodeGen::DeoptimizeIf(Condition cc, LInstruction* instr,
   RegisterEnvironmentForDeoptimization(environment, Safepoint::kNoLazyDeopt);
   DCHECK(environment->HasBeenRegistered());
   int id = environment->deoptimization_index();
-  if (never == cc) return;
   Address entry =
       Deoptimizer::GetDeoptimizationEntry(isolate(), id, bailout_type);
   if (entry == NULL) {
@@ -1957,9 +1831,6 @@ void LCodeGen::DoBranch(LBranch* instr) {
     __ xorps(xmm_scratch, xmm_scratch);
     __ ucomisd(reg, xmm_scratch);
     EmitBranch(instr, not_equal);
-  } else if (r.IsSIMD128()) {
-    DCHECK(!info()->IsStub());
-    EmitBranch(instr, no_condition);
   } else {
     DCHECK(r.IsTagged());
     Register reg = ToRegister(instr->value());
@@ -2721,37 +2592,6 @@ void LCodeGen::DoAccessArgumentsAt(LAccessArgumentsAt* instr) {
   }
 }
 
-void LCodeGen::DoDeferredSIMD128ToTagged(LInstruction* instr,
-                                         Runtime::FunctionId id) {
-  // TODO(3095996): Get rid of this. For now, we need to make the
-  // result register contain a valid pointer because it is already
-  // contained in the register pointer map.
-  Register reg = ToRegister(instr->result());
-  __ Move(reg, Immediate(0));
-
-  PushSafepointRegistersScope scope(this);
-  __ mov(esi, Operand(ebp, StandardFrameConstants::kContextOffset));
-  __ CallRuntimeSaveDoubles(id);
-  RecordSafepointWithRegisters(instr->pointer_map(), 0,
-                               Safepoint::kNoLazyDeopt);
-  __ StoreToSafepointRegisterSlot(reg, eax);
-}
-
-void LCodeGen::HandleExternalArrayOpRequiresTemp(
-    LOperand* key, Representation key_representation,
-    ElementsKind elements_kind) {
-  if (ExternalArrayOpRequiresPreScale(key_representation, elements_kind)) {
-    int pre_shift_size = ElementsKindToShiftSize(elements_kind) -
-                         static_cast<int>(maximal_scale_factor);
-    if (key_representation.IsSmi()) {
-      pre_shift_size -= kSmiTagSize;
-    }
-    DCHECK(pre_shift_size > 0);
-    __ shl(ToRegister(key), pre_shift_size);
-  } else {
-    __ SmiUntag(ToRegister(key));
-  }
-}
 
 void LCodeGen::DoLoadKeyedExternalArray(LLoadKeyed* instr) {
   ElementsKind elements_kind = instr->elements_kind();
@@ -2759,42 +2599,20 @@ void LCodeGen::DoLoadKeyedExternalArray(LLoadKeyed* instr) {
   if (!key->IsConstantOperand() &&
       ExternalArrayOpRequiresTemp(instr->hydrogen()->key()->representation(),
                                   elements_kind)) {
-    HandleExternalArrayOpRequiresTemp(
-        key, instr->hydrogen()->key()->representation(), elements_kind);
+    __ SmiUntag(ToRegister(key));
   }
-
   Operand operand(BuildFastArrayOperand(
       instr->elements(),
       key,
       instr->hydrogen()->key()->representation(),
       elements_kind,
       instr->base_offset()));
-  BuiltinFunctionId op = instr->hydrogen()->op();
-  if (IsSIMD128LoadStoreOp(op)) {
-    if (GetSIMD128LoadStoreBytes(op) == 16) {
-      __ movups(ToSIMD128Register(instr->result()), operand);
-    } else if (GetSIMD128LoadStoreBytes(op) == 4) {
-      __ movss(ToSIMD128Register(instr->result()), operand);
-    } else if (GetSIMD128LoadStoreBytes(op) == 8) {
-      __ movq(ToSIMD128Register(instr->result()), operand);
-    } else if (GetSIMD128LoadStoreBytes(op) == 12) {
-      XMMRegister result(ToSIMD128Register(instr->result()));
-      XMMRegister xmm_scratch = double_scratch0();
-      __ movq(result, operand);
-      Operand operand2(BuildFastArrayOperand(
-          instr->elements(), key, instr->hydrogen()->key()->representation(),
-          elements_kind, instr->base_offset() + 8));
-      __ movss(xmm_scratch, operand2);
-      __ movlhps(result, xmm_scratch);
-    }
-  } else if (elements_kind == FLOAT32_ELEMENTS) {
+  if (elements_kind == FLOAT32_ELEMENTS) {
     XMMRegister result(ToDoubleRegister(instr->result()));
     __ movss(result, operand);
     __ cvtss2sd(result, result);
   } else if (elements_kind == FLOAT64_ELEMENTS) {
     __ movsd(ToDoubleRegister(instr->result()), operand);
-  } else if (IsSIMD128ElementsKind(elements_kind)) {
-    __ movups(ToSIMD128Register(instr->result()), operand);
   } else {
     Register result(ToRegister(instr->result()));
     switch (elements_kind) {
@@ -2931,11 +2749,8 @@ Operand LCodeGen::BuildFastArrayOperand(
                    ((constant_value) << shift_size)
                        + base_offset);
   } else {
-    if (ExternalArrayOpRequiresPreScale(key_representation, elements_kind)) {
-      // Make sure the key is pre-scaled against maximal_scale_factor.
-      shift_size = static_cast<int>(maximal_scale_factor);
-    } else if (key_representation.IsSmi() && (shift_size >= 1)) {
-      // Take the tag bit into account while computing the shift size.
+    // Take the tag bit into account while computing the shift size.
+    if (key_representation.IsSmi() && (shift_size >= 1)) {
       shift_size -= kSmiTagSize;
     }
     ScaleFactor scale_factor = static_cast<ScaleFactor>(shift_size);
@@ -3907,51 +3722,17 @@ void LCodeGen::DoStoreNamedGeneric(LStoreNamedGeneric* instr) {
 
 void LCodeGen::DoBoundsCheck(LBoundsCheck* instr) {
   Condition cc = instr->hydrogen()->allow_equality() ? above : above_equal;
-  BuiltinFunctionId op = instr->hydrogen()->op();
-  if (IsSIMD128LoadStoreOp(op)) {
-    cc = above;
-    Register index_in_bytes = ToRegister(instr->temp0());
-    Register length_in_bytes = ToRegister(instr->temp1());
-    if (instr->index()->IsConstantOperand())
-      __ mov(index_in_bytes,
-             ToImmediate(LConstantOperand::cast(instr->index()),
-                         instr->hydrogen()->index()->representation()));
-    else
-      __ mov(index_in_bytes, ToOperand(instr->index()));
-    int index_shift_size =
-        ElementsKindToShiftSize(instr->hydrogen()->element_kind());
-    if (instr->hydrogen()->index()->representation().IsSmi())
-      index_shift_size -= kSmiTagSize;
-    DCHECK(index_shift_size >= 0);
-    if (index_shift_size > 0) __ shl(index_in_bytes, index_shift_size);
-    int bytes = GetSIMD128LoadStoreBytes(op);
-    __ add(index_in_bytes, Immediate(bytes));
-    if (instr->length()->IsConstantOperand())
-      __ mov(length_in_bytes,
-             ToImmediate(LConstantOperand::cast(instr->length()),
-                         instr->hydrogen()->length()->representation()));
-    else
-      __ mov(length_in_bytes, ToOperand(instr->length()));
-    int length_shift_size =
-        ElementsKindToShiftSize(instr->hydrogen()->element_kind());
-    if (instr->hydrogen()->length()->representation().IsSmi())
-      length_shift_size -= kSmiTagSize;
-    DCHECK(length_shift_size >= 0);
-    if (length_shift_size > 0) __ shl(length_in_bytes, length_shift_size);
-    __ cmp(index_in_bytes, length_in_bytes);
+  if (instr->index()->IsConstantOperand()) {
+    __ cmp(ToOperand(instr->length()),
+           ToImmediate(LConstantOperand::cast(instr->index()),
+                       instr->hydrogen()->length()->representation()));
+    cc = CommuteCondition(cc);
+  } else if (instr->length()->IsConstantOperand()) {
+    __ cmp(ToOperand(instr->index()),
+           ToImmediate(LConstantOperand::cast(instr->length()),
+                       instr->hydrogen()->index()->representation()));
   } else {
-    if (instr->index()->IsConstantOperand()) {
-      __ cmp(ToOperand(instr->length()),
-             ToImmediate(LConstantOperand::cast(instr->index()),
-                         instr->hydrogen()->length()->representation()));
-      cc = CommuteCondition(cc);
-    } else if (instr->length()->IsConstantOperand()) {
-      __ cmp(ToOperand(instr->index()),
-             ToImmediate(LConstantOperand::cast(instr->length()),
-                         instr->hydrogen()->index()->representation()));
-    } else {
-      __ cmp(ToRegister(instr->index()), ToOperand(instr->length()));
-    }
+    __ cmp(ToRegister(instr->index()), ToOperand(instr->length()));
   }
   if (FLAG_debug_code && instr->hydrogen()->skip_check()) {
     Label done;
@@ -3970,42 +3751,20 @@ void LCodeGen::DoStoreKeyedExternalArray(LStoreKeyed* instr) {
   if (!key->IsConstantOperand() &&
       ExternalArrayOpRequiresTemp(instr->hydrogen()->key()->representation(),
                                   elements_kind)) {
-    HandleExternalArrayOpRequiresTemp(
-        key, instr->hydrogen()->key()->representation(), elements_kind);
+    __ SmiUntag(ToRegister(key));
   }
-
   Operand operand(BuildFastArrayOperand(
       instr->elements(),
       key,
       instr->hydrogen()->key()->representation(),
       elements_kind,
       instr->base_offset()));
-  BuiltinFunctionId op = instr->hydrogen()->op();
-  if (IsSIMD128LoadStoreOp(op)) {
-    if (GetSIMD128LoadStoreBytes(op) == 16) {
-      __ movups(operand, ToSIMD128Register(instr->value()));
-    } else if (GetSIMD128LoadStoreBytes(op) == 4) {
-      __ movss(operand, ToSIMD128Register(instr->value()));
-    } else if (GetSIMD128LoadStoreBytes(op) == 8) {
-      __ movq(operand, ToSIMD128Register(instr->value()));
-    } else if (GetSIMD128LoadStoreBytes(op) == 12) {
-      XMMRegister value(ToSIMD128Register(instr->value()));
-      XMMRegister xmm_scratch = double_scratch0();
-      __ movq(operand, value);
-      Operand operand2(BuildFastArrayOperand(
-          instr->elements(), key, instr->hydrogen()->key()->representation(),
-          elements_kind, instr->base_offset() + 8));
-      __ movhlps(xmm_scratch, value);
-      __ movss(operand2, xmm_scratch);
-    }
-  } else if (elements_kind == FLOAT32_ELEMENTS) {
+  if (elements_kind == FLOAT32_ELEMENTS) {
     XMMRegister xmm_scratch = double_scratch0();
     __ cvtsd2ss(xmm_scratch, ToDoubleRegister(instr->value()));
     __ movss(operand, xmm_scratch);
   } else if (elements_kind == FLOAT64_ELEMENTS) {
     __ movsd(operand, ToDoubleRegister(instr->value()));
-  } else if (IsSIMD128ElementsKind(elements_kind)) {
-    __ movups(operand, ToSIMD128Register(instr->value()));
   } else {
     Register value = ToRegister(instr->value());
     switch (elements_kind) {
@@ -5552,1240 +5311,6 @@ void LCodeGen::DoLoadFieldByIndex(LLoadFieldByIndex* instr) {
   __ bind(&done);
 }
 
-template <InstanceType I, class T, Runtime::FunctionId D>
-void LCodeGen::HandleSIMD128ToTagged(LSIMD128ToTagged* instr) {
-  class DeferredSIMD128ToTagged final : public LDeferredCode {
-   public:
-    DeferredSIMD128ToTagged(LCodeGen* codegen, LInstruction* instr,
-                            Runtime::FunctionId id)
-        : LDeferredCode(codegen), instr_(instr), id_(id) {}
-    void Generate() override {
-      codegen()->DoDeferredSIMD128ToTagged(instr_, id_);
-    }
-    LInstruction* instr() override { return instr_; }
-
-   private:
-    LInstruction* instr_;
-    Runtime::FunctionId id_;
-  };
-
-  XMMRegister input_reg = ToSIMD128Register(instr->value());
-  Register reg = ToRegister(instr->result());
-  Register tmp = ToRegister(instr->temp());
-  Register tmp2 = ToRegister(instr->temp2());
-
-  DeferredSIMD128ToTagged* deferred = new (zone())
-      DeferredSIMD128ToTagged(this, instr, static_cast<Runtime::FunctionId>(D));
-
-  if (FLAG_inline_new) {
-    if (I == FLOAT32x4_TYPE) {
-      __ AllocateFloat32x4(reg, tmp, tmp2, deferred->entry());
-    } else if (I == BOOL32x4_TYPE) {
-      __ AllocateBool32x4(reg, tmp, tmp2, deferred->entry());
-    } else if (I == INT32x4_TYPE) {
-      __ AllocateInt32x4(reg, tmp, tmp2, deferred->entry());
-    }
-  } else {
-    __ jmp(deferred->entry());
-  }
-  __ bind(deferred->exit());
-
-  // load the value to SIMD object.
-  __ movups(FieldOperand(reg, T::kValueOffset), input_reg);
-}
-
-void LCodeGen::DoSIMD128ToTagged(LSIMD128ToTagged* instr) {
-  if (instr->value()->IsFloat32x4Register()) {
-    HandleSIMD128ToTagged<FLOAT32x4_TYPE, Float32x4,
-                          Runtime::kAllocateFloat32x4>(instr);
-  } else if (instr->value()->IsBool32x4Register()) {
-    DCHECK(instr->value()->IsBool32x4Register());
-    HandleSIMD128ToTagged<BOOL32x4_TYPE, Bool32x4, Runtime::kAllocateBool32x4>(
-        instr);
-  } else {
-    DCHECK(instr->value()->IsInt32x4Register());
-    HandleSIMD128ToTagged<INT32x4_TYPE, Int32x4, Runtime::kAllocateInt32x4>(
-        instr);
-  }
-}
-
-template <InstanceType I, class T>
-void LCodeGen::HandleTaggedToSIMD128(LTaggedToSIMD128* instr) {
-  LOperand* input = instr->value();
-  DCHECK(input->IsRegister());
-  LOperand* result = instr->result();
-  DCHECK(result->IsSIMD128Register());
-
-  Register input_reg = ToRegister(input);
-  Register temp_reg = ToRegister(instr->temp());
-  XMMRegister result_reg = ToSIMD128Register(result);
-
-  __ test(input_reg, Immediate(kSmiTagMask));
-  DeoptimizeIf(zero, instr, Deoptimizer::kSmi);
-  __ CmpObjectType(input_reg, SIMD128_VALUE_TYPE, temp_reg);
-  DeoptimizeIf(not_equal, instr, Deoptimizer::kNotASIMD128);
-
-  // Load the  object to SIMD128 register.
-  __ movups(result_reg, FieldOperand(input_reg, T::kValueOffset));
-}
-
-void LCodeGen::DoTaggedToSIMD128(LTaggedToSIMD128* instr) {
-  if (instr->representation().IsFloat32x4()) {
-    HandleTaggedToSIMD128<FLOAT32x4_TYPE, Float32x4>(instr);
-  } else if (instr->representation().IsBool32x4()) {
-    HandleTaggedToSIMD128<BOOL32x4_TYPE, Bool32x4>(instr);
-  } else {
-    DCHECK(instr->representation().IsInt32x4());
-    HandleTaggedToSIMD128<INT32x4_TYPE, Int32x4>(instr);
-  }
-}
-
-void LCodeGen::DoNullarySIMDOperation(LNullarySIMDOperation* instr) {
-  switch (instr->op()) {
-    case kFloat32x4Zero: {
-      XMMRegister result_reg = ToFloat32x4Register(instr->result());
-      __ xorps(result_reg, result_reg);
-      return;
-    }
-    case kInt32x4Zero: {
-      XMMRegister result_reg = ToInt32x4Register(instr->result());
-      __ xorps(result_reg, result_reg);
-      return;
-    }
-    default:
-      UNREACHABLE();
-      return;
-  }
-}
-
-void LCodeGen::DoUnarySIMDOperation(LUnarySIMDOperation* instr) {
-  uint8_t select = 0;
-  switch (instr->op()) {
-    case kFloat32x4Check: {
-      XMMRegister input_reg = ToFloat32x4Register(instr->value());
-      XMMRegister result_reg = ToFloat32x4Register(instr->result());
-      if (!result_reg.is(input_reg)) {
-        __ movaps(result_reg, input_reg);
-      }
-      return;
-    }
-    case kInt32x4Check: {
-      XMMRegister input_reg = ToInt32x4Register(instr->value());
-      XMMRegister result_reg = ToInt32x4Register(instr->result());
-      if (!result_reg.is(input_reg)) {
-        __ movaps(result_reg, input_reg);
-      }
-      return;
-    }
-    case kSIMD128Change: {
-      Comment(
-          ";;; deoptimize: can not perform representation change"
-          "for float32x4 or int32x4");
-      DeoptimizeIf(no_condition, instr, Deoptimizer::kForcedDeoptToRuntime);
-      return;
-    }
-    case kFloat32x4Abs:
-    case kFloat32x4Neg:
-    case kFloat32x4RecipApprox:
-    case kFloat32x4RecipSqrtApprox:
-    case kFloat32x4Sqrt: {
-      DCHECK(instr->value()->Equals(instr->result()));
-      DCHECK(instr->hydrogen()->value()->representation().IsFloat32x4());
-      XMMRegister input_reg = ToFloat32x4Register(instr->value());
-      switch (instr->op()) {
-        case kFloat32x4Abs:
-          __ absps(input_reg);
-          break;
-        case kFloat32x4Neg:
-          __ negateps(input_reg);
-          break;
-        case kFloat32x4RecipApprox:
-          __ rcpps(input_reg, input_reg);
-          break;
-        case kFloat32x4RecipSqrtApprox:
-          __ rsqrtps(input_reg, input_reg);
-          break;
-        case kFloat32x4Sqrt:
-          __ sqrtps(input_reg, input_reg);
-          break;
-        default:
-          UNREACHABLE();
-          break;
-      }
-      return;
-    }
-    case kInt32x4Not:
-    case kInt32x4Neg: {
-      DCHECK(instr->hydrogen()->value()->representation().IsInt32x4());
-      XMMRegister input_reg = ToInt32x4Register(instr->value());
-      switch (instr->op()) {
-        case kInt32x4Not:
-          __ notps(input_reg);
-          break;
-        case kInt32x4Neg:
-          __ pnegd(input_reg);
-          break;
-        default:
-          UNREACHABLE();
-          break;
-      }
-      return;
-    }
-    case kFloat32x4BitsToInt32x4:
-    case kFloat32x4ToInt32x4: {
-      DCHECK(instr->hydrogen()->value()->representation().IsFloat32x4());
-      XMMRegister input_reg = ToFloat32x4Register(instr->value());
-      XMMRegister result_reg = ToInt32x4Register(instr->result());
-      if (instr->op() == kFloat32x4BitsToInt32x4) {
-        if (!result_reg.is(input_reg)) {
-          __ movaps(result_reg, input_reg);
-        }
-      } else {
-        DCHECK(instr->op() == kFloat32x4ToInt32x4);
-        __ cvtps2dq(result_reg, input_reg);
-      }
-      return;
-    }
-    case kInt32x4BitsToFloat32x4:
-    case kInt32x4ToFloat32x4: {
-      DCHECK(instr->hydrogen()->value()->representation().IsInt32x4());
-      XMMRegister input_reg = ToInt32x4Register(instr->value());
-      XMMRegister result_reg = ToFloat32x4Register(instr->result());
-      if (instr->op() == kInt32x4BitsToFloat32x4) {
-        if (!result_reg.is(input_reg)) {
-          __ movaps(result_reg, input_reg);
-        }
-      } else {
-        DCHECK(instr->op() == kInt32x4ToFloat32x4);
-        __ cvtdq2ps(result_reg, input_reg);
-      }
-      return;
-    }
-    case kFloat32x4Splat: {
-      DCHECK(instr->hydrogen()->value()->representation().IsDouble());
-      XMMRegister input_reg = ToDoubleRegister(instr->value());
-      XMMRegister result_reg = ToFloat32x4Register(instr->result());
-      XMMRegister xmm_scratch = xmm0;
-      __ xorps(xmm_scratch, xmm_scratch);
-      __ cvtsd2ss(xmm_scratch, input_reg);
-      __ shufps(xmm_scratch, xmm_scratch, 0x0);
-      __ movaps(result_reg, xmm_scratch);
-      return;
-    }
-    case kInt32x4Splat: {
-      DCHECK(instr->hydrogen()->value()->representation().IsInteger32());
-      Register input_reg = ToRegister(instr->value());
-      XMMRegister result_reg = ToInt32x4Register(instr->result());
-      __ movd(result_reg, input_reg);
-      __ shufps(result_reg, result_reg, 0x0);
-      return;
-    }
-    case kInt32x4GetSignMask: {
-      DCHECK(instr->hydrogen()->value()->representation().IsInt32x4());
-      XMMRegister input_reg = ToInt32x4Register(instr->value());
-      Register result = ToRegister(instr->result());
-      __ movmskps(result, input_reg);
-      return;
-    }
-    case kFloat32x4GetSignMask: {
-      DCHECK(instr->hydrogen()->value()->representation().IsFloat32x4());
-      XMMRegister input_reg = ToFloat32x4Register(instr->value());
-      Register result = ToRegister(instr->result());
-      __ movmskps(result, input_reg);
-      return;
-    }
-    case kFloat32x4GetW:
-      select++;
-    case kFloat32x4GetZ:
-      select++;
-    case kFloat32x4GetY:
-      select++;
-    case kFloat32x4GetX: {
-      DCHECK(instr->hydrogen()->value()->representation().IsFloat32x4());
-      XMMRegister input_reg = ToFloat32x4Register(instr->value());
-      XMMRegister result = ToDoubleRegister(instr->result());
-      XMMRegister xmm_scratch = result.is(input_reg) ? xmm0 : result;
-
-      if (select == 0x0) {
-        __ xorps(xmm_scratch, xmm_scratch);
-        __ cvtss2sd(xmm_scratch, input_reg);
-        if (!xmm_scratch.is(result)) {
-          __ movaps(result, xmm_scratch);
-        }
-      } else {
-        __ pshufd(xmm_scratch, input_reg, select);
-        if (!xmm_scratch.is(result)) {
-          __ xorps(result, result);
-        }
-        __ cvtss2sd(result, xmm_scratch);
-      }
-      return;
-    }
-    case kBool32x4AnyTrue: {
-      DCHECK(instr->hydrogen()->value()->representation().IsBool32x4());
-      XMMRegister input_reg = ToBool32x4Register(instr->value());
-      Register result = ToRegister(instr->result());
-      __ movmskps(result, input_reg);
-      Label false_value, done;
-      __ test(result, result);
-      __ j(zero, &false_value, Label::kNear);
-      __ LoadRoot(result, Heap::kTrueValueRootIndex);
-      __ jmp(&done, Label::kNear);
-      __ bind(&false_value);
-      __ LoadRoot(result, Heap::kFalseValueRootIndex);
-      __ bind(&done);
-      return;
-    }
-    case kBool32x4AllTrue: {
-      DCHECK(instr->hydrogen()->value()->representation().IsBool32x4());
-      XMMRegister input_reg = ToBool32x4Register(instr->value());
-      Register result = ToRegister(instr->result());
-      __ movmskps(result, input_reg);
-      Label all_value, done;
-      __ xor_(result, 0xF);
-      __ j(zero, &all_value, Label::kNear);
-      __ LoadRoot(result, Heap::kFalseValueRootIndex);
-      __ jmp(&done, Label::kNear);
-      __ bind(&all_value);
-      __ LoadRoot(result, Heap::kTrueValueRootIndex);
-      __ bind(&done);
-      return;
-    }
-    case kInt32x4GetX:
-    case kInt32x4GetY:
-    case kInt32x4GetZ:
-    case kInt32x4GetW:
-    case kInt32x4GetFlagX:
-    case kInt32x4GetFlagY:
-    case kInt32x4GetFlagZ:
-    case kInt32x4GetFlagW: {
-      DCHECK(instr->hydrogen()->value()->representation().IsInt32x4());
-      bool flag = false;
-      switch (instr->op()) {
-        case kInt32x4GetFlagX:
-          flag = true;
-        case kInt32x4GetX:
-          break;
-        case kInt32x4GetFlagY:
-          flag = true;
-        case kInt32x4GetY:
-          select = 0x1;
-          break;
-        case kInt32x4GetFlagZ:
-          flag = true;
-        case kInt32x4GetZ:
-          select = 0x2;
-          break;
-        case kInt32x4GetFlagW:
-          flag = true;
-        case kInt32x4GetW:
-          select = 0x3;
-          break;
-        default:
-          UNREACHABLE();
-      }
-
-      XMMRegister input_reg = ToInt32x4Register(instr->value());
-      Register result = ToRegister(instr->result());
-      if (select == 0x0) {
-        __ movd(result, input_reg);
-      } else {
-        if (CpuFeatures::IsSupported(SSE4_1)) {
-          CpuFeatureScope scope(masm(), SSE4_1);
-          __ extractps(result, input_reg, select);
-        } else {
-          XMMRegister xmm_scratch = xmm0;
-          __ pshufd(xmm_scratch, input_reg, select);
-          __ movd(result, xmm_scratch);
-        }
-      }
-
-      if (flag) {
-        Label false_value, done;
-        __ test(result, result);
-        __ j(zero, &false_value, Label::kNear);
-        __ LoadRoot(result, Heap::kTrueValueRootIndex);
-        __ jmp(&done, Label::kNear);
-        __ bind(&false_value);
-        __ LoadRoot(result, Heap::kFalseValueRootIndex);
-        __ bind(&done);
-      }
-      return;
-    }
-    default:
-      UNREACHABLE();
-      return;
-  }
-}
-
-void LCodeGen::DoBinarySIMDOperation(LBinarySIMDOperation* instr) {
-  uint8_t imm8 = 0;  // for with operation
-  switch (instr->op()) {
-    case kFloat32x4ExtractLane: {
-      Condition cc = never;
-      DCHECK(instr->hydrogen()->left()->representation().IsFloat32x4());
-      DCHECK(instr->hydrogen()->right()->representation().IsInteger32());
-      if (instr->hydrogen()->right()->IsConstant() &&
-          HConstant::cast(instr->hydrogen()->right())->HasInteger32Value()) {
-        uint32_t right = ToInteger32(LConstantOperand::cast(instr->right()));
-        DCHECK((right >= 0) && (right <= 3));
-        XMMRegister left_reg = ToFloat32x4Register(instr->left());
-        XMMRegister result = ToDoubleRegister(instr->result());
-        XMMRegister xmm_scratch = result.is(left_reg) ? xmm0 : result;
-        switch (right) {
-          case 3:
-            imm8++;
-          case 2:
-            imm8++;
-          case 1:
-            imm8++;
-          case 0:
-            break;
-        }
-        if (imm8 == 0x0) {
-          __ xorps(xmm_scratch, xmm_scratch);
-          __ cvtss2sd(xmm_scratch, left_reg);
-          if (!xmm_scratch.is(result)) {
-            __ movaps(result, xmm_scratch);
-          }
-        } else {
-          __ pshufd(xmm_scratch, left_reg, imm8);
-          if (!xmm_scratch.is(result)) {
-            __ xorps(result, result);
-          }
-          __ cvtss2sd(result, xmm_scratch);
-        }
-      } else {
-        Comment(";;; deoptimize: non-constant selector for extractLane");
-        cc = no_condition;
-      }
-      DeoptimizeIf(cc, instr, Deoptimizer::kForcedDeoptToRuntime);
-      return;
-    }
-    case kBool32x4ExtractLane: {
-      Condition cc = never;
-      DCHECK(instr->hydrogen()->left()->representation().IsBool32x4());
-      DCHECK(instr->hydrogen()->right()->representation().IsInteger32());
-      if (instr->hydrogen()->right()->IsConstant() &&
-          HConstant::cast(instr->hydrogen()->right())->HasInteger32Value()) {
-        uint32_t right = ToInteger32(LConstantOperand::cast(instr->right()));
-        DCHECK((right >= 0) && (right <= 3));
-        XMMRegister left_reg = ToBool32x4Register(instr->left());
-        Register result = ToRegister(instr->result());
-        switch (right) {
-          case 3:
-            imm8++;
-          case 2:
-            imm8++;
-          case 1:
-            imm8++;
-          case 0:
-            break;
-        }
-        if (imm8 == 0x0) {
-          __ movd(result, left_reg);
-        } else {
-          if (CpuFeatures::IsSupported(SSE4_1)) {
-            CpuFeatureScope scope(masm(), SSE4_1);
-            __ extractps(result, left_reg, imm8);
-          } else {
-            XMMRegister xmm_scratch = xmm0;
-            __ pshufd(xmm_scratch, left_reg, imm8);
-            __ movd(result, xmm_scratch);
-          }
-        }
-        {
-          Label false_value, done;
-          __ test(result, result);
-          __ j(zero, &false_value, Label::kNear);
-          __ LoadRoot(result, Heap::kTrueValueRootIndex);
-          __ jmp(&done, Label::kNear);
-          __ bind(&false_value);
-          __ LoadRoot(result, Heap::kFalseValueRootIndex);
-          __ bind(&done);
-        }
-      } else {
-        Comment(";;; deoptimize: non-constant selector for extractLane");
-        cc = no_condition;
-      }
-      DeoptimizeIf(cc, instr, Deoptimizer::kForcedDeoptToRuntime);
-      return;
-    }
-
-    case kInt32x4ExtractLane: {
-      Condition cc = never;
-      DCHECK(instr->hydrogen()->left()->representation().IsInt32x4());
-      DCHECK(instr->hydrogen()->right()->representation().IsInteger32());
-      if (instr->hydrogen()->right()->IsConstant() &&
-          HConstant::cast(instr->hydrogen()->right())->HasInteger32Value()) {
-        XMMRegister left_reg = ToInt32x4Register(instr->left());
-        uint32_t right = ToInteger32(LConstantOperand::cast(instr->right()));
-        DCHECK((right >= 0) && (right <= 3));
-        Register result = ToRegister(instr->result());
-        switch (right) {
-          case 3:
-            imm8 = 0x3;
-            break;
-          case 2:
-            imm8 = 0x2;
-            break;
-          case 1:
-            imm8 = 0x1;
-            break;
-          case 0:
-            imm8 = 0x0;
-            break;
-          default:
-            UNREACHABLE();
-        }
-        if (imm8 == 0x0) {
-          __ movd(result, left_reg);
-        } else {
-          if (CpuFeatures::IsSupported(SSE4_1)) {
-            CpuFeatureScope scope(masm(), SSE4_1);
-            __ extractps(result, left_reg, imm8);
-          } else {
-            XMMRegister xmm_scratch = xmm0;
-            __ pshufd(xmm_scratch, left_reg, imm8);
-            __ movd(result, xmm_scratch);
-          }
-        }
-      } else {
-        Comment(";;; deoptimize: non-constant selector for extractLane");
-        cc = no_condition;
-      }
-      DeoptimizeIf(cc, instr, Deoptimizer::kForcedDeoptToRuntime);
-      return;
-    }
-    case kFloat32x4Add:
-    case kFloat32x4Sub:
-    case kFloat32x4Mul:
-    case kFloat32x4Div:
-    case kFloat32x4Min:
-    case kFloat32x4Max: {
-      DCHECK(instr->left()->Equals(instr->result()));
-      DCHECK(instr->hydrogen()->left()->representation().IsFloat32x4());
-      DCHECK(instr->hydrogen()->right()->representation().IsFloat32x4());
-      XMMRegister left_reg = ToFloat32x4Register(instr->left());
-      XMMRegister right_reg = ToFloat32x4Register(instr->right());
-      switch (instr->op()) {
-        case kFloat32x4Add:
-          __ addps(left_reg, right_reg);
-          break;
-        case kFloat32x4Sub:
-          __ subps(left_reg, right_reg);
-          break;
-        case kFloat32x4Mul:
-          __ mulps(left_reg, right_reg);
-          break;
-        case kFloat32x4Div:
-          __ divps(left_reg, right_reg);
-          break;
-        case kFloat32x4Min:
-          __ minps(left_reg, right_reg);
-          break;
-        case kFloat32x4Max:
-          __ maxps(left_reg, right_reg);
-          break;
-        default:
-          UNREACHABLE();
-          break;
-      }
-      return;
-    }
-    case kInt32x4ShiftLeft:
-    case kInt32x4ShiftRightArithmetic: {
-      DCHECK(instr->left()->Equals(instr->result()));
-      DCHECK(instr->hydrogen()->left()->representation().IsInt32x4());
-      if (instr->hydrogen()->right()->IsConstant() &&
-          HConstant::cast(instr->hydrogen()->right())->HasInteger32Value()) {
-        int32_t value = ToInteger32(LConstantOperand::cast(instr->right()));
-        uint8_t shift = static_cast<uint8_t>(value & 0xFF);
-        XMMRegister left_reg = ToInt32x4Register(instr->left());
-        switch (instr->op()) {
-          case kInt32x4ShiftLeft:
-            __ pslld(left_reg, shift);
-            break;
-          case kInt32x4ShiftRightArithmetic:
-            __ psrad(left_reg, shift);
-            break;
-          default:
-            UNREACHABLE();
-        }
-        return;
-      } else {
-        XMMRegister left_reg = ToInt32x4Register(instr->left());
-        Register shift = ToRegister(instr->right());
-        XMMRegister xmm_scratch = double_scratch0();
-        __ movd(xmm_scratch, shift);
-        switch (instr->op()) {
-          case kInt32x4ShiftLeft:
-            __ pslld(left_reg, xmm_scratch);
-            break;
-          case kInt32x4ShiftRightArithmetic:
-            __ psrad(left_reg, xmm_scratch);
-            break;
-          default:
-            UNREACHABLE();
-        }
-        return;
-      }
-    }
-    case kFloat32x4LessThan:
-    case kFloat32x4LessThanOrEqual:
-    case kFloat32x4Equal:
-    case kFloat32x4NotEqual:
-    case kFloat32x4GreaterThanOrEqual:
-    case kFloat32x4GreaterThan: {
-      DCHECK(instr->hydrogen()->left()->representation().IsFloat32x4());
-      DCHECK(instr->hydrogen()->right()->representation().IsFloat32x4());
-      XMMRegister left_reg = ToFloat32x4Register(instr->left());
-      XMMRegister right_reg = ToFloat32x4Register(instr->right());
-      XMMRegister result_reg = ToBool32x4Register(instr->result());
-      switch (instr->op()) {
-        case kFloat32x4LessThan:
-          if (result_reg.is(left_reg)) {
-            __ cmpltps(result_reg, right_reg);
-          } else if (result_reg.is(right_reg)) {
-            __ cmpnltps(result_reg, left_reg);
-          } else {
-            __ movaps(result_reg, left_reg);
-            __ cmpltps(result_reg, right_reg);
-          }
-          break;
-        case kFloat32x4LessThanOrEqual: {
-          if (result_reg.is(left_reg)) {
-            __ cmpleps(result_reg, right_reg);
-          } else if (result_reg.is(right_reg)) {
-            __ cmpnltps(result_reg, left_reg);
-          } else {
-            __ movaps(result_reg, left_reg);
-            __ cmpleps(result_reg, right_reg);
-          }
-          break;
-        }
-        case kFloat32x4Equal:
-          if (result_reg.is(left_reg)) {
-            __ cmpeqps(result_reg, right_reg);
-          } else if (result_reg.is(right_reg)) {
-            __ cmpeqps(result_reg, left_reg);
-          } else {
-            __ movaps(result_reg, left_reg);
-            __ cmpeqps(result_reg, right_reg);
-          }
-          break;
-        case kFloat32x4NotEqual:
-          if (result_reg.is(left_reg)) {
-            __ cmpneqps(result_reg, right_reg);
-          } else if (result_reg.is(right_reg)) {
-            __ cmpneqps(result_reg, left_reg);
-          } else {
-            __ movaps(result_reg, left_reg);
-            __ cmpneqps(result_reg, right_reg);
-          }
-          break;
-        case kFloat32x4GreaterThanOrEqual:
-          if (result_reg.is(left_reg)) {
-            __ cmpnltps(result_reg, right_reg);
-          } else if (result_reg.is(right_reg)) {
-            __ cmpltps(result_reg, left_reg);
-          } else {
-            __ movaps(result_reg, left_reg);
-            __ cmpnltps(result_reg, right_reg);
-          }
-          break;
-        case kFloat32x4GreaterThan:
-          if (result_reg.is(left_reg)) {
-            __ cmpnleps(result_reg, right_reg);
-          } else if (result_reg.is(right_reg)) {
-            __ cmpleps(result_reg, left_reg);
-          } else {
-            __ movaps(result_reg, left_reg);
-            __ cmpnleps(result_reg, right_reg);
-          }
-          break;
-        default:
-          UNREACHABLE();
-          break;
-      }
-      return;
-    }
-    case kInt32x4And:
-    case kInt32x4Or:
-    case kInt32x4Xor:
-    case kInt32x4Add:
-    case kInt32x4Sub:
-    case kInt32x4Mul: {
-      DCHECK(instr->left()->Equals(instr->result()));
-      DCHECK(instr->hydrogen()->left()->representation().IsInt32x4());
-      DCHECK(instr->hydrogen()->right()->representation().IsInt32x4());
-      XMMRegister left_reg = ToInt32x4Register(instr->left());
-      XMMRegister right_reg = ToInt32x4Register(instr->right());
-      switch (instr->op()) {
-        case kInt32x4And:
-          __ andps(left_reg, right_reg);
-          break;
-        case kInt32x4Or:
-          __ orps(left_reg, right_reg);
-          break;
-        case kInt32x4Xor:
-          __ xorps(left_reg, right_reg);
-          break;
-        case kInt32x4Add:
-          __ paddd(left_reg, right_reg);
-          break;
-        case kInt32x4Sub:
-          __ psubd(left_reg, right_reg);
-          break;
-        case kInt32x4Mul: {
-          if (CpuFeatures::IsSupported(SSE4_1)) {
-            CpuFeatureScope scope(masm(), SSE4_1);
-            __ pmulld(left_reg, right_reg);
-          } else {
-            // The algorithm is from
-            // http://stackoverflow.com/questions/10500766/sse-multiplication-of-4-32-bit-integers
-            XMMRegister xmm_scratch = xmm0;
-            __ movaps(xmm_scratch, left_reg);
-            __ pmuludq(left_reg, right_reg);
-            __ psrldq(xmm_scratch, 4);
-            __ psrldq(right_reg, 4);
-            __ pmuludq(xmm_scratch, right_reg);
-            __ pshufd(left_reg, left_reg, 8);
-            __ pshufd(xmm_scratch, xmm_scratch, 8);
-            __ punpackldq(left_reg, xmm_scratch);
-          }
-        } break;
-        default:
-          UNREACHABLE();
-          break;
-      }
-      return;
-    }
-    case kInt32x4GreaterThan:
-    case kInt32x4Equal:
-    case kInt32x4LessThan: {
-      DCHECK(instr->left()->Equals(instr->result()));
-      DCHECK(instr->hydrogen()->left()->representation().IsInt32x4());
-      DCHECK(instr->hydrogen()->right()->representation().IsInt32x4());
-      XMMRegister left_reg = ToInt32x4Register(instr->left());
-      XMMRegister right_reg = ToBool32x4Register(instr->right());
-      switch (instr->op()) {
-        case kInt32x4GreaterThan:
-          __ pcmpgtd(left_reg, right_reg);
-          break;
-        case kInt32x4Equal:
-          __ pcmpeqd(left_reg, right_reg);
-          break;
-        case kInt32x4LessThan: {
-          XMMRegister xmm_scratch = xmm0;
-          __ movaps(xmm_scratch, right_reg);
-          __ pcmpgtd(xmm_scratch, left_reg);
-          __ movaps(left_reg, xmm_scratch);
-          break;
-        }
-        default:
-          UNREACHABLE();
-          break;
-      }
-      return;
-    }
-    default:
-      UNREACHABLE();
-      return;
-  }
-}
-
-void LCodeGen::DoTernarySIMDOperation(LTernarySIMDOperation* instr) {
-  uint8_t imm8 = 0;
-  switch (instr->op()) {
-    case kFloat32x4Select: {
-      DCHECK(instr->hydrogen()->first()->representation().IsInt32x4());
-      DCHECK(instr->hydrogen()->second()->representation().IsFloat32x4());
-      DCHECK(instr->hydrogen()->third()->representation().IsFloat32x4());
-
-      XMMRegister mask_reg = ToInt32x4Register(instr->first());
-      XMMRegister left_reg = ToFloat32x4Register(instr->second());
-      XMMRegister right_reg = ToFloat32x4Register(instr->third());
-      XMMRegister result_reg = ToFloat32x4Register(instr->result());
-      XMMRegister temp_reg = xmm0;
-
-      // Copy mask.
-      __ movaps(temp_reg, mask_reg);
-      // Invert it.
-      __ notps(temp_reg);
-      // temp_reg = temp_reg & falseValue.
-      __ andps(temp_reg, right_reg);
-
-      if (!result_reg.is(mask_reg)) {
-        if (result_reg.is(left_reg)) {
-          // result_reg = result_reg & trueValue.
-          __ andps(result_reg, mask_reg);
-          // out = result_reg | temp_reg.
-          __ orps(result_reg, temp_reg);
-        } else {
-          __ movaps(result_reg, mask_reg);
-          // result_reg = result_reg & trueValue.
-          __ andps(result_reg, left_reg);
-          // out = result_reg | temp_reg.
-          __ orps(result_reg, temp_reg);
-        }
-      } else {
-        // result_reg = result_reg & trueValue.
-        __ andps(result_reg, left_reg);
-        // out = result_reg | temp_reg.
-        __ orps(result_reg, temp_reg);
-      }
-      return;
-    }
-    case kInt32x4Select: {
-      DCHECK(instr->hydrogen()->first()->representation().IsBool32x4());
-      DCHECK(instr->hydrogen()->second()->representation().IsInt32x4());
-      DCHECK(instr->hydrogen()->third()->representation().IsInt32x4());
-
-      XMMRegister mask_reg = ToBool32x4Register(instr->first());
-      XMMRegister left_reg = ToInt32x4Register(instr->second());
-      XMMRegister right_reg = ToInt32x4Register(instr->third());
-      XMMRegister result_reg = ToInt32x4Register(instr->result());
-      XMMRegister temp_reg = xmm0;
-
-      // Copy mask.
-      __ movaps(temp_reg, mask_reg);
-      // Invert it.
-      __ notps(temp_reg);
-      // temp_reg = temp_reg & falseValue.
-      __ andps(temp_reg, right_reg);
-
-      if (!result_reg.is(mask_reg)) {
-        if (result_reg.is(left_reg)) {
-          // result_reg = result_reg & trueValue.
-          __ andps(result_reg, mask_reg);
-          // out = result_reg | temp_reg.
-          __ orps(result_reg, temp_reg);
-        } else {
-          __ movaps(result_reg, mask_reg);
-          // result_reg = result_reg & trueValue.
-          __ andps(result_reg, left_reg);
-          // out = result_reg | temp_reg.
-          __ orps(result_reg, temp_reg);
-        }
-      } else {
-        // result_reg = result_reg & trueValue.
-        __ andps(result_reg, left_reg);
-        // out = result_reg | temp_reg.
-        __ orps(result_reg, temp_reg);
-      }
-      return;
-    }
-    case kFloat32x4ReplaceLane: {
-      Condition cc = never;
-      DCHECK(instr->first()->Equals(instr->result()));
-      DCHECK(instr->hydrogen()->first()->representation().IsFloat32x4());
-      DCHECK(instr->hydrogen()->second()->representation().IsInteger32());
-      DCHECK(instr->hydrogen()->third()->representation().IsDouble());
-      if (instr->hydrogen()->second()->IsConstant() &&
-          HConstant::cast(instr->hydrogen()->second())->HasInteger32Value()) {
-        int32_t x = ToInteger32(LConstantOperand::cast(instr->second()));
-        DCHECK((x >= 0) && (x <= 3));
-        switch (x) {
-          case 3:
-            imm8++;
-          case 2:
-            imm8++;
-          case 1:
-            imm8++;
-          case 0:
-            break;
-        }
-        XMMRegister result_reg = ToFloat32x4Register(instr->first());
-        XMMRegister value_reg = ToDoubleRegister(instr->third());
-        XMMRegister xmm_scratch = xmm0;
-        __ xorps(xmm_scratch, xmm_scratch);
-        __ cvtsd2ss(xmm_scratch, value_reg);
-        if (CpuFeatures::IsSupported(SSE4_1)) {
-          imm8 = imm8 << 4;
-          CpuFeatureScope scope(masm(), SSE4_1);
-          __ insertps(result_reg, xmm_scratch, imm8);
-        } else {
-          __ sub(esp, Immediate(kFloat32x4Size));
-          __ movups(Operand(esp, 0), result_reg);
-          __ movss(Operand(esp, imm8 * kFloatSize), xmm_scratch);
-          __ movups(result_reg, Operand(esp, 0));
-          __ add(esp, Immediate(kFloat32x4Size));
-        }
-      } else {
-        Comment(";;; deoptimize: non-constant selector for replaceLane.");
-        cc = no_condition;
-      }
-      DeoptimizeIf(cc, instr, Deoptimizer::kForcedDeoptToRuntime);
-      return;
-    }
-    case kInt32x4ReplaceLane: {
-      Condition cc = never;
-      DCHECK(instr->first()->Equals(instr->result()));
-      DCHECK(instr->hydrogen()->first()->representation().IsInt32x4());
-      DCHECK(instr->hydrogen()->second()->representation().IsInteger32());
-      DCHECK(instr->hydrogen()->third()->representation().IsInteger32());
-      if (instr->hydrogen()->second()->IsConstant() &&
-          HConstant::cast(instr->hydrogen()->second())->HasInteger32Value()) {
-        int32_t x = ToInteger32(LConstantOperand::cast(instr->second()));
-        DCHECK((x >= 0) && (x <= 4));
-        switch (x) {
-          case 3:
-            imm8++;
-          case 2:
-            imm8++;
-          case 1:
-            imm8++;
-          case 0:
-            break;
-        }
-        XMMRegister result_reg = ToInt32x4Register(instr->first());
-        Register value_reg = ToRegister(instr->third());
-        if (CpuFeatures::IsSupported(SSE4_1)) {
-          CpuFeatureScope scope(masm(), SSE4_1);
-          __ pinsrd(result_reg, value_reg, imm8);
-        } else {
-          __ sub(esp, Immediate(kInt32x4Size));
-          __ movdqu(Operand(esp, 0), result_reg);
-          __ mov(Operand(esp, imm8 * kFloatSize), value_reg);
-          __ movdqu(result_reg, Operand(esp, 0));
-          __ add(esp, Immediate(kInt32x4Size));
-        }
-      } else {
-        Comment(";;; deoptimize: non-constant selector for replaceLane.");
-        cc = no_condition;
-      }
-      DeoptimizeIf(cc, instr, Deoptimizer::kForcedDeoptToRuntime);
-      return;
-    }
-    default:
-      UNREACHABLE();
-      return;
-  }
-}
-
-void LCodeGen::DoQuarternarySIMDOperation(LQuarternarySIMDOperation* instr) {
-  switch (instr->op()) {
-    case kFloat32x4Constructor: {
-      DCHECK(instr->hydrogen()->x()->representation().IsDouble());
-      DCHECK(instr->hydrogen()->y()->representation().IsDouble());
-      DCHECK(instr->hydrogen()->z()->representation().IsDouble());
-      DCHECK(instr->hydrogen()->w()->representation().IsDouble());
-      XMMRegister x_reg = ToDoubleRegister(instr->x());
-      XMMRegister y_reg = ToDoubleRegister(instr->y());
-      XMMRegister z_reg = ToDoubleRegister(instr->z());
-      XMMRegister w_reg = ToDoubleRegister(instr->w());
-      XMMRegister result_reg = ToFloat32x4Register(instr->result());
-      __ sub(esp, Immediate(kFloat32x4Size));
-      __ xorps(xmm0, xmm0);
-      __ cvtsd2ss(xmm0, x_reg);
-      __ movss(Operand(esp, 0 * kFloatSize), xmm0);
-      __ xorps(xmm0, xmm0);
-      __ cvtsd2ss(xmm0, y_reg);
-      __ movss(Operand(esp, 1 * kFloatSize), xmm0);
-      __ xorps(xmm0, xmm0);
-      __ cvtsd2ss(xmm0, z_reg);
-      __ movss(Operand(esp, 2 * kFloatSize), xmm0);
-      __ xorps(xmm0, xmm0);
-      __ cvtsd2ss(xmm0, w_reg);
-      __ movss(Operand(esp, 3 * kFloatSize), xmm0);
-      __ movups(result_reg, Operand(esp, 0 * kFloatSize));
-      __ add(esp, Immediate(kFloat32x4Size));
-      return;
-    }
-    case kInt32x4Constructor: {
-      DCHECK(instr->hydrogen()->x()->representation().IsInteger32());
-      DCHECK(instr->hydrogen()->y()->representation().IsInteger32());
-      DCHECK(instr->hydrogen()->z()->representation().IsInteger32());
-      DCHECK(instr->hydrogen()->w()->representation().IsInteger32());
-      Register x_reg = ToRegister(instr->x());
-      Register y_reg = ToRegister(instr->y());
-      Register z_reg = ToRegister(instr->z());
-      Register w_reg = ToRegister(instr->w());
-      XMMRegister result_reg = ToInt32x4Register(instr->result());
-      __ sub(esp, Immediate(kInt32x4Size));
-      __ mov(Operand(esp, 0 * kInt32Size), x_reg);
-      __ mov(Operand(esp, 1 * kInt32Size), y_reg);
-      __ mov(Operand(esp, 2 * kInt32Size), z_reg);
-      __ mov(Operand(esp, 3 * kInt32Size), w_reg);
-      __ movups(result_reg, Operand(esp, 0 * kInt32Size));
-      __ add(esp, Immediate(kInt32x4Size));
-      return;
-    }
-    case kBool32x4Constructor: {
-      DCHECK(instr->hydrogen()->x()->representation().IsTagged());
-      DCHECK(instr->hydrogen()->y()->representation().IsTagged());
-      DCHECK(instr->hydrogen()->z()->representation().IsTagged());
-      DCHECK(instr->hydrogen()->w()->representation().IsTagged());
-      DCHECK(instr->hydrogen()->x()->type().IsBoolean());
-      DCHECK(instr->hydrogen()->y()->type().IsBoolean());
-      DCHECK(instr->hydrogen()->z()->type().IsBoolean());
-      DCHECK(instr->hydrogen()->w()->type().IsBoolean());
-
-      Register x_reg = ToRegister(instr->x());
-      Register y_reg = ToRegister(instr->y());
-      Register z_reg = ToRegister(instr->z());
-      Register w_reg = ToRegister(instr->w());
-      XMMRegister result_reg = ToBool32x4Register(instr->result());
-
-      Immediate neg(-1);
-      Label done_x, done_y, done_z, done_w;
-
-      __ xorps(result_reg, result_reg);
-      __ sub(esp, Immediate(kBool32x4Size));
-      __ movups(Operand(esp, 0 * kBool32Size), result_reg);
-
-      __ CompareRoot(x_reg, Heap::kTrueValueRootIndex);
-      __ j(not_equal, &done_x, Label::kNear);
-      __ mov(Operand(esp, 0 * kBool32Size), neg);
-      __ jmp(&done_x, Label::kNear);
-      __ bind(&done_x);
-
-      __ CompareRoot(y_reg, Heap::kTrueValueRootIndex);
-      __ j(not_equal, &done_y, Label::kNear);
-      __ mov(Operand(esp, 1 * kBool32Size), neg);
-      __ jmp(&done_y, Label::kNear);
-      __ bind(&done_y);
-
-      __ CompareRoot(z_reg, Heap::kTrueValueRootIndex);
-      __ j(not_equal, &done_z, Label::kNear);
-      __ mov(Operand(esp, 2 * kBool32Size), neg);
-      __ jmp(&done_z, Label::kNear);
-      __ bind(&done_z);
-
-      __ CompareRoot(w_reg, Heap::kTrueValueRootIndex);
-      __ j(not_equal, &done_w, Label::kNear);
-      __ mov(Operand(esp, 3 * kBool32Size), neg);
-      __ jmp(&done_w, Label::kNear);
-      __ bind(&done_w);
-
-      __ movups(result_reg, Operand(esp, 0 * kInt32Size));
-      __ add(esp, Immediate(kBool32x4Size));
-      return;
-    }
-    default:
-      UNREACHABLE();
-      return;
-  }
-}
-
-static uint8_t ComputeShuffleSelect(uint32_t x, uint32_t y, uint32_t z,
-                                    uint32_t w) {
-  DCHECK(x < 4 && y < 4 && z < 4 && w < 4);
-  uint32_t r =
-      static_cast<uint8_t>(((w << 6) | (z << 4) | (y << 2) | (x << 0)) & 0xFF);
-  return r;
-}
-
-void LCodeGen::DoQuinarySIMDOperation(LQuinarySIMDOperation* instr) {
-  switch (instr->op()) {
-    case kFloat32x4Swizzle: {
-      Condition cc = never;
-      DCHECK(instr->a0()->Equals(instr->result()));
-      DCHECK(instr->hydrogen()->a0()->representation().IsFloat32x4());
-      if ((instr->hydrogen()->a1()->IsConstant() &&
-           HConstant::cast(instr->hydrogen()->a1())->HasInteger32Value()) &&
-          (instr->hydrogen()->a2()->IsConstant() &&
-           HConstant::cast(instr->hydrogen()->a2())->HasInteger32Value()) &&
-          (instr->hydrogen()->a3()->IsConstant() &&
-           HConstant::cast(instr->hydrogen()->a3())->HasInteger32Value()) &&
-          (instr->hydrogen()->a4()->IsConstant() &&
-           HConstant::cast(instr->hydrogen()->a4())->HasInteger32Value())) {
-        int32_t x = ToInteger32(LConstantOperand::cast(instr->a1()));
-        int32_t y = ToInteger32(LConstantOperand::cast(instr->a2()));
-        int32_t z = ToInteger32(LConstantOperand::cast(instr->a3()));
-        int32_t w = ToInteger32(LConstantOperand::cast(instr->a4()));
-        uint8_t select = ComputeShuffleSelect(x, y, z, w);
-        XMMRegister left_reg = ToFloat32x4Register(instr->a0());
-        __ shufps(left_reg, left_reg, select);
-      } else {
-        Comment(";;; deoptimize: non-constant selector for swizzle");
-        cc = no_condition;
-      }
-      DeoptimizeIf(cc, instr, Deoptimizer::kForcedDeoptToRuntime);
-      return;
-    }
-    case kInt32x4Swizzle: {
-      Condition cc = never;
-      DCHECK(instr->a0()->Equals(instr->result()));
-      DCHECK(instr->hydrogen()->a0()->representation().IsInt32x4());
-      if ((instr->hydrogen()->a1()->IsConstant() &&
-           HConstant::cast(instr->hydrogen()->a1())->HasInteger32Value()) &&
-          (instr->hydrogen()->a2()->IsConstant() &&
-           HConstant::cast(instr->hydrogen()->a2())->HasInteger32Value()) &&
-          (instr->hydrogen()->a3()->IsConstant() &&
-           HConstant::cast(instr->hydrogen()->a3())->HasInteger32Value()) &&
-          (instr->hydrogen()->a4()->IsConstant() &&
-           HConstant::cast(instr->hydrogen()->a4())->HasInteger32Value())) {
-        int32_t x = ToInteger32(LConstantOperand::cast(instr->a1()));
-        int32_t y = ToInteger32(LConstantOperand::cast(instr->a2()));
-        int32_t z = ToInteger32(LConstantOperand::cast(instr->a3()));
-        int32_t w = ToInteger32(LConstantOperand::cast(instr->a4()));
-        uint8_t select = ComputeShuffleSelect(x, y, z, w);
-        XMMRegister left_reg = ToInt32x4Register(instr->a0());
-        __ pshufd(left_reg, left_reg, select);
-      } else {
-        Comment(";;; deoptimize: non-constant selector for shuffle");
-        cc = no_condition;
-      }
-      DeoptimizeIf(cc, instr, Deoptimizer::kForcedDeoptToRuntime);
-      return;
-    }
-    default:
-      UNREACHABLE();
-      return;
-  }
-}
-
-void LCodeGen::DoSenarySIMDOperation(LSenarySIMDOperation* instr) {
-  switch (instr->op()) {
-    case kFloat32x4Shuffle:
-    case kInt32x4Shuffle: {
-      Condition cc = never;
-      DCHECK(instr->a0()->Equals(instr->result()));
-      if (instr->op() == kFloat32x4Shuffle) {
-        DCHECK(instr->hydrogen()->a0()->representation().IsFloat32x4());
-        DCHECK(instr->hydrogen()->a1()->representation().IsFloat32x4());
-      } else {
-        DCHECK(instr->hydrogen()->a0()->representation().IsInt32x4());
-        DCHECK(instr->hydrogen()->a1()->representation().IsInt32x4());
-      }
-
-      if ((instr->hydrogen()->a2()->IsConstant() &&
-           HConstant::cast(instr->hydrogen()->a2())->HasInteger32Value()) &&
-          (instr->hydrogen()->a3()->IsConstant() &&
-           HConstant::cast(instr->hydrogen()->a3())->HasInteger32Value()) &&
-          (instr->hydrogen()->a4()->IsConstant() &&
-           HConstant::cast(instr->hydrogen()->a4())->HasInteger32Value()) &&
-          (instr->hydrogen()->a5()->IsConstant() &&
-           HConstant::cast(instr->hydrogen()->a5())->HasInteger32Value())) {
-        int32_t x = ToInteger32(LConstantOperand::cast(instr->a2()));
-        int32_t y = ToInteger32(LConstantOperand::cast(instr->a3()));
-        int32_t z = ToInteger32(LConstantOperand::cast(instr->a4()));
-        int32_t w = ToInteger32(LConstantOperand::cast(instr->a5()));
-        XMMRegister lhs, rhs;
-        if (instr->op() == kFloat32x4Shuffle) {
-          lhs = ToFloat32x4Register(instr->a0());
-          rhs = ToFloat32x4Register(instr->a1());
-        } else {
-          lhs = ToInt32x4Register(instr->a0());
-          rhs = ToInt32x4Register(instr->a1());
-        }
-        XMMRegister temp = xmm0;
-
-        uint32_t num_lanes_from_lhs = (x < 4) + (y < 4) + (z < 4) + (w < 4);
-        if (num_lanes_from_lhs == 4) {
-          uint8_t select = ComputeShuffleSelect(x, y, z, w);
-          __ shufps(lhs, lhs, select);
-        } else if (num_lanes_from_lhs == 0) {
-          x -= 4;
-          y -= 4;
-          z -= 4;
-          w -= 4;
-          uint8_t select = ComputeShuffleSelect(x, y, z, w);
-          __ movaps(lhs, rhs);
-          __ shufps(lhs, lhs, select);
-        } else if (num_lanes_from_lhs == 3) {
-          uint8_t first_select = 0xFF;
-          uint8_t second_select = 0xFF;
-          if (x < 4 && y < 4) {
-            if (w >= 4) {
-              w -= 4;
-              // T = (Rw Rw Lz Lz) = shufps(firstMask, lhs, rhs)
-              first_select = ComputeShuffleSelect(w, w, z, z);
-              // (Lx Ly Lz Rw) = (Lx Ly Tz Tx) = shufps(secondMask, T, lhs)
-              second_select = ComputeShuffleSelect(x, y, 2, 0);
-            } else {
-              DCHECK(z >= 4);
-              z -= 4;
-              // T = (Rz Rz Lw Lw) = shufps(firstMask, lhs, rhs)
-              first_select = ComputeShuffleSelect(z, z, w, w);
-              // (Lx Ly Rz Lw) = (Lx Ly Tx Tz) = shufps(secondMask, T, lhs)
-              second_select = ComputeShuffleSelect(x, y, 0, 2);
-            }
-
-            __ movaps(temp, rhs);
-            __ shufps(temp, lhs, first_select);
-            __ shufps(lhs, temp, second_select);
-          }
-
-          DCHECK(z < 4 && w < 4);
-          if (z < 4 && w < 4) {
-            if (y >= 4) {
-              y -= 4;
-              // T = (Ry Ry Lx Lx) = shufps(firstMask, lhs, rhs)
-              first_select = ComputeShuffleSelect(y, y, x, x);
-              // (Lx Ry Lz Lw) = (Tz Tx Lz Lw) = shufps(secondMask, lhs, T)
-              second_select = ComputeShuffleSelect(2, 0, z, w);
-            } else {
-              DCHECK(x >= 4);
-              x -= 4;
-              // T = (Rx Rx Ly Ly) = shufps(firstMask, lhs, rhs)
-              first_select = ComputeShuffleSelect(x, x, y, y);
-              // (Rx Ly Lz Lw) = (Tx Tz Lz Lw) = shufps(secondMask, lhs, T)
-              second_select = ComputeShuffleSelect(0, 2, z, w);
-            }
-
-            __ movaps(temp, rhs);
-            __ shufps(temp, lhs, first_select);
-            __ shufps(temp, lhs, second_select);
-            __ movaps(lhs, temp);
-          }
-        } else if (num_lanes_from_lhs == 2) {
-          if (x < 4 && y < 4) {
-            uint8_t select = ComputeShuffleSelect(x, y, z % 4, w % 4);
-            __ shufps(lhs, rhs, select);
-          } else if (z < 4 && w < 4) {
-            uint8_t select = ComputeShuffleSelect(x % 4, y % 4, z, w);
-            __ movaps(temp, rhs);
-            __ shufps(temp, lhs, select);
-            __ movaps(lhs, temp);
-          } else {
-            // In two shufps, for the most generic case:
-            uint8_t first_select[4], second_select[4];
-            uint32_t i = 0, j = 2, k = 0;
-
-#define COMPUTE_SELECT(lane)    \
-  if (lane >= 4) {              \
-    first_select[j] = lane % 4; \
-    second_select[k++] = j++;   \
-  } else {                      \
-    first_select[i] = lane;     \
-    second_select[k++] = i++;   \
-  }
-
-            COMPUTE_SELECT(x)
-            COMPUTE_SELECT(y)
-            COMPUTE_SELECT(z)
-            COMPUTE_SELECT(w)
-#undef COMPUTE_SELECT
-
-            DCHECK(i == 2 && j == 4 && k == 4);
-
-            int8_t select;
-            select = ComputeShuffleSelect(first_select[0], first_select[1],
-                                          first_select[2], first_select[3]);
-            __ shufps(lhs, rhs, select);
-
-            select = ComputeShuffleSelect(second_select[0], second_select[1],
-                                          second_select[2], second_select[3]);
-            __ shufps(lhs, lhs, select);
-          }
-        }
-      } else {
-        Comment(";;; deoptimize: non-constant selector for shuffle");
-        cc = no_condition;
-      }
-      DeoptimizeIf(cc, instr, Deoptimizer::kForcedDeoptToRuntime);
-      return;
-    }
-
-    default:
-      UNREACHABLE();
-      return;
-  }
-}
-
 #undef __
 
 }  // namespace internal
diff --git a/src/crankshaft/ia32/lithium-codegen-ia32.h b/src/crankshaft/ia32/lithium-codegen-ia32.h
index 8a1bac18df..5084819dce 100644
--- a/src/crankshaft/ia32/lithium-codegen-ia32.h
+++ b/src/crankshaft/ia32/lithium-codegen-ia32.h
@@ -56,10 +56,6 @@ class LCodeGen: public LCodeGenBase {
   Operand ToOperand(LOperand* op) const;
   Register ToRegister(LOperand* op) const;
   XMMRegister ToDoubleRegister(LOperand* op) const;
-  XMMRegister ToFloat32x4Register(LOperand* op) const;
-  XMMRegister ToBool32x4Register(LOperand* op) const;
-  XMMRegister ToInt32x4Register(LOperand* op) const;
-  XMMRegister ToSIMD128Register(LOperand* op) const;
 
   bool IsInteger32(LConstantOperand* op) const;
   bool IsSmi(LConstantOperand* op) const;
@@ -93,8 +89,6 @@ class LCodeGen: public LCodeGenBase {
                              IntegerSignedness signedness);
 
   void DoDeferredTaggedToI(LTaggedToI* instr, Label* done);
-  void DoDeferredFloat32x4ToTagged(LInstruction* instr);
-  void DoDeferredInt32x4ToTagged(LInstruction* instr);
   void DoDeferredMathAbsTaggedHeapNumber(LMathAbs* instr);
   void DoDeferredStackCheck(LStackCheck* instr);
   void DoDeferredMaybeGrowElements(LMaybeGrowElements* instr);
@@ -105,12 +99,6 @@ class LCodeGen: public LCodeGenBase {
   void DoDeferredLoadMutableDouble(LLoadFieldByIndex* instr,
                                    Register object,
                                    Register index);
-  void DoDeferredSIMD128ToTagged(LInstruction* instr, Runtime::FunctionId id);
-
-  template <InstanceType I, class T>
-  void HandleTaggedToSIMD128(LTaggedToSIMD128* instr);
-  template <InstanceType I, class T, Runtime::FunctionId F>
-  void HandleSIMD128ToTagged(LSIMD128ToTagged* instr);
 
   // Parallel move support.
   void DoParallelMove(LParallelMove* move);
@@ -235,10 +223,6 @@ class LCodeGen: public LCodeGenBase {
 
   Register ToRegister(int index) const;
   XMMRegister ToDoubleRegister(int index) const;
-  XMMRegister ToFloat32x4Register(int index) const;
-  XMMRegister ToBool32x4Register(int index) const;
-  XMMRegister ToInt32x4Register(int index) const;
-  XMMRegister ToSIMD128Register(int index) const;
   int32_t ToRepresentation(LConstantOperand* op, const Representation& r) const;
   int32_t ToInteger32(LConstantOperand* op) const;
   ExternalReference ToExternalReference(LConstantOperand* op) const;
@@ -304,9 +288,6 @@ class LCodeGen: public LCodeGenBase {
 
   void EnsureSpaceForLazyDeopt(int space_needed) override;
   void DoLoadKeyedExternalArray(LLoadKeyed* instr);
-  void HandleExternalArrayOpRequiresTemp(LOperand* key,
-                                         Representation key_representation,
-                                         ElementsKind elements_kind);
   void DoLoadKeyedFixedDoubleArray(LLoadKeyed* instr);
   void DoLoadKeyedFixedArray(LLoadKeyed* instr);
   void DoStoreKeyedExternalArray(LStoreKeyed* instr);
diff --git a/src/crankshaft/ia32/lithium-gap-resolver-ia32.cc b/src/crankshaft/ia32/lithium-gap-resolver-ia32.cc
index b97365cae7..be8251cffb 100644
--- a/src/crankshaft/ia32/lithium-gap-resolver-ia32.cc
+++ b/src/crankshaft/ia32/lithium-gap-resolver-ia32.cc
@@ -346,23 +346,6 @@ void LGapResolver::EmitMove(int index) {
       __ movsd(xmm0, src);
       __ movsd(dst, xmm0);
     }
-  } else if (source->IsSIMD128Register()) {
-    XMMRegister src = cgen_->ToSIMD128Register(source);
-    if (destination->IsSIMD128Register()) {
-      __ movaps(cgen_->ToSIMD128Register(destination), src);
-    } else {
-      DCHECK(destination->IsSIMD128StackSlot());
-      __ movups(cgen_->ToOperand(destination), src);
-    }
-  } else if (source->IsSIMD128StackSlot()) {
-    Operand src = cgen_->ToOperand(source);
-    if (destination->IsSIMD128Register()) {
-      __ movups(cgen_->ToSIMD128Register(destination), src);
-    } else {
-      DCHECK(destination->IsSIMD128StackSlot());
-      __ movups(xmm0, src);
-      __ movups(cgen_->ToOperand(destination), xmm0);
-    }
   } else {
     UNREACHABLE();
   }
@@ -463,40 +446,6 @@ void LGapResolver::EmitSwap(int index) {
     __ mov(dst1, tmp);
     __ movsd(src0, xmm0);
 
-  } else if ((source->IsSIMD128StackSlot() &&
-              destination->IsSIMD128StackSlot())) {
-    // Swap two XMM stack slots.
-    Operand src = cgen_->ToOperand(source);
-    Operand dst = cgen_->ToOperand(destination);
-    Register tmp = EnsureTempRegister();
-    __ movups(xmm0, src);
-    for (int offset = 0; offset < kSIMD128Size; offset += kPointerSize) {
-      __ mov(tmp, Operand(dst, offset));
-      __ mov(Operand(src, offset), tmp);
-    }
-    __ movups(dst, xmm0);
-
-  } else if (source->IsSIMD128Register() && destination->IsSIMD128Register()) {
-    // Swap two XMM registers.
-    XMMRegister source_reg = cgen_->ToSIMD128Register(source);
-    XMMRegister destination_reg = cgen_->ToSIMD128Register(destination);
-    __ movaps(xmm0, source_reg);
-    __ movaps(source_reg, destination_reg);
-    __ movaps(destination_reg, xmm0);
-
-  } else if (source->IsSIMD128Register() || destination->IsSIMD128Register()) {
-    // Swap a xmm register and a xmm stack slot.
-    DCHECK((source->IsSIMD128Register() && destination->IsSIMD128StackSlot()) ||
-           (source->IsSIMD128StackSlot() && destination->IsSIMD128Register()));
-    XMMRegister reg = cgen_->ToSIMD128Register(
-        source->IsSIMD128Register() ? source : destination);
-    LOperand* other = source->IsSIMD128Register() ? destination : source;
-    DCHECK(other->IsSIMD128StackSlot());
-    Operand other_operand = cgen_->ToOperand(other);
-    __ movups(xmm0, other_operand);
-    __ movups(other_operand, reg);
-    __ movaps(reg, xmm0);
-
   } else {
     // No other combinations are possible.
     UNREACHABLE();
diff --git a/src/crankshaft/ia32/lithium-ia32.cc b/src/crankshaft/ia32/lithium-ia32.cc
index 95510fbd7c..501ff47ab7 100644
--- a/src/crankshaft/ia32/lithium-ia32.cc
+++ b/src/crankshaft/ia32/lithium-ia32.cc
@@ -321,47 +321,23 @@ void LAccessArgumentsAt::PrintDataTo(StringStream* stream) {
 
 
 int LPlatformChunk::GetNextSpillIndex(RegisterKind kind) {
-  switch (kind) {
-    case GENERAL_REGISTERS:
-      return current_frame_slots_++;
-    case DOUBLE_REGISTERS: {
-      // Skip a slot if for a double-width slot.
-      current_frame_slots_++;
-      current_frame_slots_ |= 1;
-      num_double_slots_++;
-      return current_frame_slots_++;
-    }
-    case FLOAT32x4_REGISTERS:
-    case BOOL32x4_REGISTERS:
-    case INT32x4_REGISTERS: {
-      // Skip three slots if for a quad-width slot.
-      current_frame_slots_ += 3;
-      num_double_slots_ += 2;  // for dynamic frame alignment
-      return current_frame_slots_++;
-    }
-    default:
-      UNREACHABLE();
-      return -1;
+  // Skip a slot if for a double-width slot.
+  if (kind == DOUBLE_REGISTERS) {
+    current_frame_slots_++;
+    current_frame_slots_ |= 1;
+    num_double_slots_++;
   }
+  return current_frame_slots_++;
 }
 
 
 LOperand* LPlatformChunk::GetNextSpillSlot(RegisterKind kind) {
   int index = GetNextSpillIndex(kind);
-  switch (kind) {
-    case GENERAL_REGISTERS:
-      return LStackSlot::Create(index, zone());
-    case DOUBLE_REGISTERS:
-      return LDoubleStackSlot::Create(index, zone());
-    case FLOAT32x4_REGISTERS:
-      return LFloat32x4StackSlot::Create(index, zone());
-    case BOOL32x4_REGISTERS:
-      return LBool32x4StackSlot::Create(index, zone());
-    case INT32x4_REGISTERS:
-      return LInt32x4StackSlot::Create(index, zone());
-    default:
-      UNREACHABLE();
-      return NULL;
+  if (kind == DOUBLE_REGISTERS) {
+    return LDoubleStackSlot::Create(index, zone());
+  } else {
+    DCHECK(kind == GENERAL_REGISTERS);
+    return LStackSlot::Create(index, zone());
   }
 }
 
@@ -955,7 +931,6 @@ LInstruction* LChunkBuilder::DoBranch(HBranch* instr) {
 
   bool easy_case = !r.IsTagged() || type.IsBoolean() || type.IsSmi() ||
       type.IsJSArray() || type.IsHeapNumber() || type.IsString();
-
   LOperand* temp = !easy_case && expected.NeedsMap() ? TempRegister() : NULL;
   LInstruction* branch = new(zone()) LBranch(UseRegister(value), temp);
   if (!easy_case &&
@@ -1807,9 +1782,7 @@ LInstruction* LChunkBuilder::DoBoundsCheck(HBoundsCheck* instr) {
   LOperand* length = !index->IsConstantOperand()
       ? UseOrConstantAtStart(instr->length())
       : UseAtStart(instr->length());
-  LOperand* temp0 = TempRegister();
-  LOperand* temp1 = TempRegister();
-  LInstruction* result = new (zone()) LBoundsCheck(index, length, temp0, temp1);
+  LInstruction* result = new(zone()) LBoundsCheck(index, length);
   if (!FLAG_debug_code || !instr->skip_check()) {
     result = AssignEnvironment(result);
   }
@@ -1856,11 +1829,6 @@ LInstruction* LChunkBuilder::DoChange(HChange* instr) {
           DefineAsRegister(new(zone()) LNumberUntagD(value, temp));
       if (!val->representation().IsSmi()) result = AssignEnvironment(result);
       return result;
-    } else if (to.IsSIMD128()) {
-      LOperand* value = UseRegister(instr->value());
-      LOperand* temp = TempRegister();
-      LTaggedToSIMD128* res = new (zone()) LTaggedToSIMD128(value, temp, to);
-      return AssignEnvironment(DefineAsRegister(res));
     } else if (to.IsSmi()) {
       LOperand* value = UseRegister(val);
       if (val->type().IsSmi()) {
@@ -1935,18 +1903,6 @@ LInstruction* LChunkBuilder::DoChange(HChange* instr) {
         return DefineAsRegister(new(zone()) LInteger32ToDouble(Use(val)));
       }
     }
-  } else if (from.IsSIMD128()) {
-    DCHECK(to.IsTagged());
-    info()->MarkAsDeferredCalling();
-    LOperand* value = UseRegister(instr->value());
-    LOperand* temp = TempRegister();
-    LOperand* temp2 = TempRegister();
-
-    // Make sure that temp and result_temp are different registers.
-    LUnallocated* result_temp = TempRegister();
-    LSIMD128ToTagged* result =
-        new (zone()) LSIMD128ToTagged(value, temp, temp2);
-    return AssignPointerMap(Define(result, result_temp));
   }
   UNREACHABLE();
   return NULL;
@@ -2198,20 +2154,12 @@ LInstruction* LChunkBuilder::DoLoadKeyedGeneric(HLoadKeyedGeneric* instr) {
 
 LOperand* LChunkBuilder::GetStoreKeyedValueOperand(HStoreKeyed* instr) {
   ElementsKind elements_kind = instr->elements_kind();
-  BuiltinFunctionId op = instr->op();
 
   // Determine if we need a byte register in this case for the value.
   bool val_is_fixed_register =
-      (elements_kind == UINT8_ELEMENTS || elements_kind == INT8_ELEMENTS ||
-       elements_kind == UINT8_CLAMPED_ELEMENTS) &&
-      (op != kInt8ArraySetFloat32x4XYZW && op != kInt8ArraySetFloat32x4X &&
-       op != kInt8ArraySetFloat32x4XY && op != kInt8ArraySetFloat32x4XYZ &&
-       op != kInt8ArraySetInt32x4XYZW && op != kInt8ArraySetInt32x4X &&
-       op != kInt8ArraySetInt32x4XY && op != kInt8ArraySetInt32x4XYZ &&
-       op != kUint8ArraySetFloat32x4XYZW && op != kUint8ArraySetFloat32x4X &&
-       op != kUint8ArraySetFloat32x4XY && op != kUint8ArraySetFloat32x4XYZ &&
-       op != kUint8ArraySetInt32x4XYZW && op != kUint8ArraySetInt32x4X &&
-       op != kUint8ArraySetInt32x4XY && op != kUint8ArraySetInt32x4XYZ);
+      elements_kind == UINT8_ELEMENTS ||
+      elements_kind == INT8_ELEMENTS ||
+      elements_kind == UINT8_CLAMPED_ELEMENTS;
   if (val_is_fixed_register) {
     return UseFixed(instr->value(), eax);
   }
@@ -2625,286 +2573,6 @@ LInstruction* LChunkBuilder::DoLoadFieldByIndex(HLoadFieldByIndex* instr) {
   return AssignPointerMap(result);
 }
 
-const char* LNullarySIMDOperation::Mnemonic() const {
-  switch (op()) {
-#define SIMD_NULLARY_OPERATION_CASE_ITEM(module, function, name, p4) \
-  case k##name:                                                      \
-    return #module "-" #function;
-    SIMD_NULLARY_OPERATIONS(SIMD_NULLARY_OPERATION_CASE_ITEM)
-#undef SIMD_NULLARY_OPERATION_CASE_ITEM
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-LInstruction* LChunkBuilder::DoNullarySIMDOperation(
-    HNullarySIMDOperation* instr) {
-  LNullarySIMDOperation* result =
-      new (zone()) LNullarySIMDOperation(instr->op());
-  switch (instr->op()) {
-#define SIMD_NULLARY_OPERATION_CASE_ITEM(module, function, name, p4) \
-  case k##name:
-    SIMD_NULLARY_OPERATIONS(SIMD_NULLARY_OPERATION_CASE_ITEM)
-#undef SIMD_NULLARY_OPERATION_CASE_ITEM
-    return DefineAsRegister(result);
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-const char* LUnarySIMDOperation::Mnemonic() const {
-  switch (op()) {
-    case kSIMD128Change:
-      return "SIMD128-change";
-#define SIMD_UNARY_OPERATION_CASE_ITEM(module, function, name, p4, p5) \
-  case k##name:                                                        \
-    return #module "-" #function;
-      SIMD_UNARY_OPERATIONS(SIMD_UNARY_OPERATION_CASE_ITEM)
-      SIMD_UNARY_OPERATIONS_FOR_PROPERTY_ACCESS(SIMD_UNARY_OPERATION_CASE_ITEM)
-#undef SIMD_UNARY_OPERATION_CASE_ITEM
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-LInstruction* LChunkBuilder::DoUnarySIMDOperation(HUnarySIMDOperation* instr) {
-  LOperand* input = UseRegisterAtStart(instr->value());
-  LUnarySIMDOperation* result =
-      new (zone()) LUnarySIMDOperation(input, instr->op());
-  switch (instr->op()) {
-    case kSIMD128Change:
-      return AssignEnvironment(DefineAsRegister(result));
-    case kFloat32x4Abs:
-    case kFloat32x4Neg:
-    case kFloat32x4RecipApprox:
-    case kFloat32x4RecipSqrtApprox:
-    case kFloat32x4Sqrt:
-    case kInt32x4Neg:
-    case kInt32x4Not:
-      return DefineSameAsFirst(result);
-    case kFloat32x4Check:
-    case kInt32x4Check:
-    case kFloat32x4BitsToInt32x4:
-    case kFloat32x4ToInt32x4:
-    case kInt32x4BitsToFloat32x4:
-    case kInt32x4ToFloat32x4:
-    case kFloat32x4Splat:
-    case kInt32x4Splat:
-    case kFloat32x4GetSignMask:
-    case kFloat32x4GetX:
-    case kFloat32x4GetY:
-    case kFloat32x4GetZ:
-    case kFloat32x4GetW:
-    case kInt32x4GetSignMask:
-    case kInt32x4GetX:
-    case kInt32x4GetY:
-    case kInt32x4GetZ:
-    case kInt32x4GetW:
-    case kBool32x4AnyTrue:
-    case kBool32x4AllTrue:
-    case kInt32x4GetFlagX:
-    case kInt32x4GetFlagY:
-    case kInt32x4GetFlagZ:
-    case kInt32x4GetFlagW:
-      return DefineAsRegister(result);
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-const char* LBinarySIMDOperation::Mnemonic() const {
-  switch (op()) {
-#define SIMD_BINARY_OPERATION_CASE_ITEM(module, function, name, p4, p5, p6) \
-  case k##name:                                                             \
-    return #module "-" #function;
-    SIMD_BINARY_OPERATIONS(SIMD_BINARY_OPERATION_CASE_ITEM)
-#undef SIMD_BINARY_OPERATION_CASE_ITEM
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-LInstruction* LChunkBuilder::DoBinarySIMDOperation(
-    HBinarySIMDOperation* instr) {
-  switch (instr->op()) {
-    case kFloat32x4Add:
-    case kFloat32x4Div:
-    case kFloat32x4Max:
-    case kFloat32x4Min:
-    case kFloat32x4Mul:
-    case kFloat32x4Sub:
-    case kInt32x4Add:
-    case kInt32x4And:
-    case kInt32x4Mul:
-    case kInt32x4Or:
-    case kInt32x4Sub:
-    case kInt32x4Xor:
-    case kInt32x4GreaterThan:
-    case kInt32x4Equal:
-    case kInt32x4LessThan: {
-      LOperand* left = UseRegisterAtStart(instr->left());
-      LOperand* right = UseRegisterAtStart(instr->right());
-      LBinarySIMDOperation* result =
-          new (zone()) LBinarySIMDOperation(left, right, instr->op());
-      return DefineSameAsFirst(result);
-    }
-    case kFloat32x4ExtractLane:
-    case kBool32x4ExtractLane:
-    case kInt32x4ExtractLane:
-    case kInt32x4ShiftLeft:
-    case kInt32x4ShiftRightArithmetic: {
-      LOperand* left = UseRegisterAtStart(instr->left());
-      LOperand* right = UseOrConstant(instr->right());
-      LBinarySIMDOperation* result =
-          new (zone()) LBinarySIMDOperation(left, right, instr->op());
-      if (instr->op() == kFloat32x4ExtractLane ||
-          instr->op() == kBool32x4ExtractLane ||
-          instr->op() == kInt32x4ExtractLane)
-        return AssignEnvironment(DefineAsRegister(result));
-      else
-        return AssignEnvironment(DefineSameAsFirst(result));
-    }
-    case kFloat32x4LessThan:
-    case kFloat32x4LessThanOrEqual:
-    case kFloat32x4Equal:
-    case kFloat32x4NotEqual:
-    case kFloat32x4GreaterThanOrEqual:
-    case kFloat32x4GreaterThan: {
-      LOperand* left = UseRegisterAtStart(instr->left());
-      LOperand* right = UseRegisterAtStart(instr->right());
-      LBinarySIMDOperation* result =
-          new (zone()) LBinarySIMDOperation(left, right, instr->op());
-      return DefineAsRegister(result);
-    }
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-const char* LTernarySIMDOperation::Mnemonic() const {
-  switch (op()) {
-#define SIMD_TERNARY_OPERATION_CASE_ITEM(module, function, name, p4, p5, p6, \
-                                         p7)                                 \
-  case k##name:                                                              \
-    return #module "-" #function;
-    SIMD_TERNARY_OPERATIONS(SIMD_TERNARY_OPERATION_CASE_ITEM)
-#undef SIMD_TERNARY_OPERATION_CASE_ITEM
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-LInstruction* LChunkBuilder::DoTernarySIMDOperation(
-    HTernarySIMDOperation* instr) {
-  LOperand* first = UseRegisterAtStart(instr->first());
-  LOperand* second = UseRegisterAtStart(instr->second());
-  LOperand* third = UseRegisterAtStart(instr->third());
-  LTernarySIMDOperation* result =
-      new (zone()) LTernarySIMDOperation(first, second, third, instr->op());
-  switch (instr->op()) {
-    case kInt32x4Select:
-    case kFloat32x4Select: {
-      return DefineAsRegister(result);
-    }
-    case kFloat32x4ReplaceLane:
-    case kInt32x4ReplaceLane: {
-      LOperand* second = UseOrConstant(instr->second());
-      LOperand* third = UseRegisterAtStart(instr->third());
-      LTernarySIMDOperation* result =
-          new (zone()) LTernarySIMDOperation(first, second, third, instr->op());
-      return AssignEnvironment(DefineSameAsFirst(result));
-    }
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-const char* LQuarternarySIMDOperation::Mnemonic() const {
-  switch (op()) {
-#define SIMD_QUARTERNARY_OPERATION_CASE_ITEM(module, function, name, p4, p5, \
-                                             p6, p7, p8)                     \
-  case k##name:                                                              \
-    return #module "-" #function;
-    SIMD_QUARTERNARY_OPERATIONS(SIMD_QUARTERNARY_OPERATION_CASE_ITEM)
-#undef SIMD_QUARTERNARY_OPERATION_CASE_ITEM
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-LInstruction* LChunkBuilder::DoQuarternarySIMDOperation(
-    HQuarternarySIMDOperation* instr) {
-  LOperand* x = UseRegisterAtStart(instr->x());
-  LOperand* y = UseRegisterAtStart(instr->y());
-  LOperand* z = UseRegisterAtStart(instr->z());
-  LOperand* w = UseRegisterAtStart(instr->w());
-  LQuarternarySIMDOperation* result =
-      new (zone()) LQuarternarySIMDOperation(x, y, z, w, instr->op());
-  return DefineAsRegister(result);
-}
-
-const char* LQuinarySIMDOperation::Mnemonic() const {
-  switch (op()) {
-#define SIMD_QUINARY_OPERATION_CASE_ITEM(module, function, name, p4, p5, p6, \
-                                         p7, p8, p9)                         \
-  case k##name:                                                              \
-    return #module "-" #function;
-    SIMD_QUINARY_OPERATIONS(SIMD_QUINARY_OPERATION_CASE_ITEM)
-#undef SIMD_QUINARY_OPERATION_CASE_ITEM
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-LInstruction* LChunkBuilder::DoQuinarySIMDOperation(
-    HQuinarySIMDOperation* instr) {
-  LOperand* a0 = UseRegisterAtStart(instr->a0());
-  LOperand* a1 = UseOrConstant(instr->a1());
-  LOperand* a2 = UseOrConstant(instr->a2());
-  LOperand* a3 = UseOrConstant(instr->a3());
-  LOperand* a4 = UseOrConstant(instr->a4());
-  LQuinarySIMDOperation* result =
-      new (zone()) LQuinarySIMDOperation(a0, a1, a2, a3, a4, instr->op());
-  return AssignEnvironment(DefineSameAsFirst(result));
-}
-
-const char* LSenarySIMDOperation::Mnemonic() const {
-  switch (op()) {
-#define SIMD_SENARY_OPERATION_CASE_ITEM(module, function, name, p4, p5, p6, \
-                                        p7, p8, p9, p10)                    \
-  case k##name:                                                             \
-    return #module "-" #function;
-    SIMD_SENARY_OPERATIONS(SIMD_SENARY_OPERATION_CASE_ITEM)
-#undef SIMD_SENARY_OPERATION_CASE_ITEM
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-LInstruction* LChunkBuilder::DoSenarySIMDOperation(
-    HSenarySIMDOperation* instr) {
-  LOperand* a0 = UseRegisterAtStart(instr->a0());
-  LOperand* a1 = UseRegisterAtStart(instr->a1());
-  LOperand* a2 = UseOrConstant(instr->a2());
-  LOperand* a3 = UseOrConstant(instr->a3());
-  LOperand* a4 = UseOrConstant(instr->a4());
-  LOperand* a5 = UseOrConstant(instr->a5());
-  LSenarySIMDOperation* result =
-      new (zone()) LSenarySIMDOperation(a0, a1, a2, a3, a4, a5, instr->op());
-  return AssignEnvironment(DefineSameAsFirst(result));
-}
-
 }  // namespace internal
 }  // namespace v8
 
diff --git a/src/crankshaft/ia32/lithium-ia32.h b/src/crankshaft/ia32/lithium-ia32.h
index 356f5438c4..7dd22e0f66 100644
--- a/src/crankshaft/ia32/lithium-ia32.h
+++ b/src/crankshaft/ia32/lithium-ia32.h
@@ -116,21 +116,12 @@ class LCodeGen;
   V(MaybeGrowElements)                       \
   V(ModByConstI)                             \
   V(ModByPowerOf2I)                          \
-  V(NullarySIMDOperation)                    \
-  V(UnarySIMDOperation)                      \
-  V(BinarySIMDOperation)                     \
-  V(TernarySIMDOperation)                    \
-  V(QuarternarySIMDOperation)                \
-  V(QuinarySIMDOperation)                    \
-  V(SenarySIMDOperation)                     \
   V(ModI)                                    \
   V(MulI)                                    \
   V(NumberTagD)                              \
   V(NumberTagI)                              \
   V(NumberTagU)                              \
   V(NumberUntagD)                            \
-  V(SIMD128ToTagged)                         \
-  V(TaggedToSIMD128)                         \
   V(OsrEntry)                                \
   V(Parameter)                               \
   V(Power)                                   \
@@ -975,204 +966,6 @@ class LMathPowHalf final : public LTemplateInstruction<1, 1, 1> {
   DECLARE_CONCRETE_INSTRUCTION(MathPowHalf, "math-pow-half")
 };
 
-class LNullarySIMDOperation final : public LTemplateInstruction<1, 0, 0> {
- public:
-  explicit LNullarySIMDOperation(BuiltinFunctionId op) : op_(op) {}
-
-  BuiltinFunctionId op() const { return op_; }
-
-  Opcode opcode() const override { return LInstruction::kNullarySIMDOperation; }
-  void CompileToNative(LCodeGen* generator) override;
-  const char* Mnemonic() const override;
-  static LNullarySIMDOperation* cast(LInstruction* instr) {
-    DCHECK(instr->IsNullarySIMDOperation());
-    return reinterpret_cast<LNullarySIMDOperation*>(instr);
-  }
-
-  DECLARE_HYDROGEN_ACCESSOR(NullarySIMDOperation)
-
- private:
-  BuiltinFunctionId op_;
-};
-
-class LUnarySIMDOperation final : public LTemplateInstruction<1, 1, 0> {
- public:
-  LUnarySIMDOperation(LOperand* value, BuiltinFunctionId op) : op_(op) {
-    inputs_[0] = value;
-  }
-
-  LOperand* value() { return inputs_[0]; }
-  BuiltinFunctionId op() const { return op_; }
-
-  Opcode opcode() const override { return LInstruction::kUnarySIMDOperation; }
-  void CompileToNative(LCodeGen* generator) override;
-  const char* Mnemonic() const override;
-  static LUnarySIMDOperation* cast(LInstruction* instr) {
-    DCHECK(instr->IsUnarySIMDOperation());
-    return reinterpret_cast<LUnarySIMDOperation*>(instr);
-  }
-
-  DECLARE_HYDROGEN_ACCESSOR(UnarySIMDOperation)
-
- private:
-  BuiltinFunctionId op_;
-};
-
-class LBinarySIMDOperation final : public LTemplateInstruction<1, 2, 0> {
- public:
-  LBinarySIMDOperation(LOperand* left, LOperand* right, BuiltinFunctionId op)
-      : op_(op) {
-    inputs_[0] = left;
-    inputs_[1] = right;
-  }
-
-  LOperand* left() { return inputs_[0]; }
-  LOperand* right() { return inputs_[1]; }
-  BuiltinFunctionId op() const { return op_; }
-
-  Opcode opcode() const override { return LInstruction::kBinarySIMDOperation; }
-  void CompileToNative(LCodeGen* generator) override;
-  const char* Mnemonic() const override;
-  static LBinarySIMDOperation* cast(LInstruction* instr) {
-    DCHECK(instr->IsBinarySIMDOperation());
-    return reinterpret_cast<LBinarySIMDOperation*>(instr);
-  }
-
-  DECLARE_HYDROGEN_ACCESSOR(BinarySIMDOperation)
-
- private:
-  BuiltinFunctionId op_;
-};
-
-class LTernarySIMDOperation final : public LTemplateInstruction<1, 3, 0> {
- public:
-  LTernarySIMDOperation(LOperand* first, LOperand* second, LOperand* third,
-                        BuiltinFunctionId op)
-      : op_(op) {
-    inputs_[0] = first;
-    inputs_[1] = second;
-    inputs_[2] = third;
-  }
-
-  LOperand* first() { return inputs_[0]; }
-  LOperand* second() { return inputs_[1]; }
-  LOperand* third() { return inputs_[2]; }
-  BuiltinFunctionId op() const { return op_; }
-
-  Opcode opcode() const override { return LInstruction::kTernarySIMDOperation; }
-  void CompileToNative(LCodeGen* generator) override;
-  const char* Mnemonic() const override;
-  static LTernarySIMDOperation* cast(LInstruction* instr) {
-    DCHECK(instr->IsTernarySIMDOperation());
-    return reinterpret_cast<LTernarySIMDOperation*>(instr);
-  }
-
-  DECLARE_HYDROGEN_ACCESSOR(TernarySIMDOperation)
-
- private:
-  BuiltinFunctionId op_;
-};
-
-class LQuarternarySIMDOperation final : public LTemplateInstruction<1, 4, 0> {
- public:
-  LQuarternarySIMDOperation(LOperand* x, LOperand* y, LOperand* z, LOperand* w,
-                            BuiltinFunctionId op)
-      : op_(op) {
-    inputs_[0] = x;
-    inputs_[1] = y;
-    inputs_[2] = z;
-    inputs_[3] = w;
-  }
-
-  LOperand* x() { return inputs_[0]; }
-  LOperand* y() { return inputs_[1]; }
-  LOperand* z() { return inputs_[2]; }
-  LOperand* w() { return inputs_[3]; }
-  BuiltinFunctionId op() const { return op_; }
-
-  Opcode opcode() const override {
-    return LInstruction::kQuarternarySIMDOperation;
-  }
-  void CompileToNative(LCodeGen* generator) override;
-  const char* Mnemonic() const override;
-  static LQuarternarySIMDOperation* cast(LInstruction* instr) {
-    DCHECK(instr->IsQuarternarySIMDOperation());
-    return reinterpret_cast<LQuarternarySIMDOperation*>(instr);
-  }
-
-  DECLARE_HYDROGEN_ACCESSOR(QuarternarySIMDOperation)
-
- private:
-  BuiltinFunctionId op_;
-};
-
-class LQuinarySIMDOperation final : public LTemplateInstruction<1, 5, 0> {
- public:
-  LQuinarySIMDOperation(LOperand* a0, LOperand* a1, LOperand* a2, LOperand* a3,
-                        LOperand* a4, BuiltinFunctionId op)
-      : op_(op) {
-    inputs_[0] = a0;
-    inputs_[1] = a1;
-    inputs_[2] = a2;
-    inputs_[3] = a3;
-    inputs_[4] = a4;
-  }
-
-  LOperand* a0() { return inputs_[0]; }
-  LOperand* a1() { return inputs_[1]; }
-  LOperand* a2() { return inputs_[2]; }
-  LOperand* a3() { return inputs_[3]; }
-  LOperand* a4() { return inputs_[4]; }
-  BuiltinFunctionId op() const { return op_; }
-
-  Opcode opcode() const override { return LInstruction::kQuinarySIMDOperation; }
-  void CompileToNative(LCodeGen* generator) override;
-  const char* Mnemonic() const override;
-  static LQuinarySIMDOperation* cast(LInstruction* instr) {
-    DCHECK(instr->IsQuinarySIMDOperation());
-    return reinterpret_cast<LQuinarySIMDOperation*>(instr);
-  }
-
-  DECLARE_HYDROGEN_ACCESSOR(QuinarySIMDOperation)
-
- private:
-  BuiltinFunctionId op_;
-};
-
-class LSenarySIMDOperation final : public LTemplateInstruction<1, 6, 0> {
- public:
-  LSenarySIMDOperation(LOperand* a0, LOperand* a1, LOperand* a2, LOperand* a3,
-                       LOperand* a4, LOperand* a5, BuiltinFunctionId op)
-      : op_(op) {
-    inputs_[0] = a0;
-    inputs_[1] = a1;
-    inputs_[2] = a2;
-    inputs_[3] = a3;
-    inputs_[4] = a4;
-    inputs_[5] = a5;
-  }
-
-  LOperand* a0() { return inputs_[0]; }
-  LOperand* a1() { return inputs_[1]; }
-  LOperand* a2() { return inputs_[2]; }
-  LOperand* a3() { return inputs_[3]; }
-  LOperand* a4() { return inputs_[4]; }
-  LOperand* a5() { return inputs_[5]; }
-  BuiltinFunctionId op() const { return op_; }
-
-  Opcode opcode() const override { return LInstruction::kSenarySIMDOperation; }
-  void CompileToNative(LCodeGen* generator) override;
-  const char* Mnemonic() const override;
-  static LSenarySIMDOperation* cast(LInstruction* instr) {
-    DCHECK(instr->IsSenarySIMDOperation());
-    return reinterpret_cast<LSenarySIMDOperation*>(instr);
-  }
-
-  DECLARE_HYDROGEN_ACCESSOR(SenarySIMDOperation)
-
- private:
-  BuiltinFunctionId op_;
-};
 
 class LCmpObjectEqAndBranch final : public LControlInstruction<2, 0> {
  public:
@@ -1373,20 +1166,16 @@ class LHasInPrototypeChainAndBranch final : public LControlInstruction<2, 1> {
   DECLARE_HYDROGEN_ACCESSOR(HasInPrototypeChainAndBranch)
 };
 
-class LBoundsCheck final : public LTemplateInstruction<0, 2, 2> {
+
+class LBoundsCheck final : public LTemplateInstruction<0, 2, 0> {
  public:
-  LBoundsCheck(LOperand* index, LOperand* length, LOperand* temp0,
-               LOperand* temp1) {
+  LBoundsCheck(LOperand* index, LOperand* length) {
     inputs_[0] = index;
     inputs_[1] = length;
-    temps_[0] = temp0;
-    temps_[1] = temp1;
   }
 
   LOperand* index() { return inputs_[0]; }
   LOperand* length() { return inputs_[1]; }
-  LOperand* temp0() { return temps_[0]; }
-  LOperand* temp1() { return temps_[1]; }
 
   DECLARE_CONCRETE_INSTRUCTION(BoundsCheck, "bounds-check")
   DECLARE_HYDROGEN_ACCESSOR(BoundsCheck)
@@ -1777,13 +1566,6 @@ class LLoadKeyed final : public LTemplateInstruction<1, 3, 0> {
   }
 };
 
-inline static bool ExternalArrayOpRequiresPreScale(
-    Representation key_representation, ElementsKind kind) {
-  int shift_size = ElementsKindToShiftSize(kind);
-  return key_representation.IsSmi()
-             ? shift_size > static_cast<int>(maximal_scale_factor) + kSmiTagSize
-             : shift_size > static_cast<int>(maximal_scale_factor);
-}
 
 inline static bool ExternalArrayOpRequiresTemp(
     Representation key_representation,
@@ -1791,10 +1573,9 @@ inline static bool ExternalArrayOpRequiresTemp(
   // Operations that require the key to be divided by two to be converted into
   // an index cannot fold the scale operation into a load and need an extra
   // temp register to do the work.
-  return ExternalArrayOpRequiresPreScale(key_representation, elements_kind) ||
-         (key_representation.IsSmi() &&
-          (elements_kind == UINT8_ELEMENTS || elements_kind == INT8_ELEMENTS ||
-           elements_kind == UINT8_CLAMPED_ELEMENTS));
+  return key_representation.IsSmi() &&
+         (elements_kind == UINT8_ELEMENTS || elements_kind == INT8_ELEMENTS ||
+          elements_kind == UINT8_CLAMPED_ELEMENTS);
 }
 
 
@@ -2122,21 +1903,6 @@ class LNumberTagD final : public LTemplateInstruction<1, 1, 1> {
   DECLARE_HYDROGEN_ACCESSOR(Change)
 };
 
-class LSIMD128ToTagged final : public LTemplateInstruction<1, 1, 2> {
- public:
-  explicit LSIMD128ToTagged(LOperand* value, LOperand* temp, LOperand* temp2) {
-    inputs_[0] = value;
-    temps_[0] = temp;
-    temps_[1] = temp2;
-  }
-
-  LOperand* value() { return inputs_[0]; }
-  LOperand* temp() { return temps_[0]; }
-  LOperand* temp2() { return temps_[1]; }
-
-  DECLARE_CONCRETE_INSTRUCTION(SIMD128ToTagged, "simd128-tag")
-  DECLARE_HYDROGEN_ACCESSOR(Change)
-};
 
 // Sometimes truncating conversion from a tagged value to an int32.
 class LDoubleToI final : public LTemplateInstruction<1, 1, 1> {
@@ -2214,25 +1980,6 @@ class LNumberUntagD final : public LTemplateInstruction<1, 1, 1> {
   DECLARE_HYDROGEN_ACCESSOR(Change);
 };
 
-class LTaggedToSIMD128 final : public LTemplateInstruction<1, 1, 1> {
- public:
-  explicit LTaggedToSIMD128(LOperand* value, LOperand* temp,
-                            Representation representation)
-      : representation_(representation) {
-    inputs_[0] = value;
-    temps_[0] = temp;
-  }
-
-  LOperand* value() { return inputs_[0]; }
-  LOperand* temp() { return temps_[0]; }
-  Representation representation() const { return representation_; }
-
-  DECLARE_CONCRETE_INSTRUCTION(TaggedToSIMD128, "simd128-untag")
-  DECLARE_HYDROGEN_ACCESSOR(Change);
-
- private:
-  Representation representation_;
-};
 
 class LSmiUntag final : public LTemplateInstruction<1, 1, 0> {
  public:
diff --git a/src/crankshaft/lithium-allocator-inl.h b/src/crankshaft/lithium-allocator-inl.h
index 31c89add08..631af6024b 100644
--- a/src/crankshaft/lithium-allocator-inl.h
+++ b/src/crankshaft/lithium-allocator-inl.h
@@ -46,8 +46,7 @@ LGap* LAllocator::GapAt(int index) {
 
 
 void LAllocator::SetLiveRangeAssignedRegister(LiveRange* range, int reg) {
-  if (range->Kind() == DOUBLE_REGISTERS ||
-      IsSIMD128RegisterKind(range->Kind())) {
+  if (range->Kind() == DOUBLE_REGISTERS) {
     assigned_double_registers_->Add(reg);
   } else {
     DCHECK(range->Kind() == GENERAL_REGISTERS);
diff --git a/src/crankshaft/lithium-allocator.cc b/src/crankshaft/lithium-allocator.cc
index 63bbe7faa7..d17cd27c10 100644
--- a/src/crankshaft/lithium-allocator.cc
+++ b/src/crankshaft/lithium-allocator.cc
@@ -208,15 +208,6 @@ LOperand* LiveRange::CreateAssignedOperand(Zone* zone) {
       case DOUBLE_REGISTERS:
         op = LDoubleRegister::Create(assigned_register(), zone);
         break;
-      case FLOAT32x4_REGISTERS:
-        op = LFloat32x4Register::Create(assigned_register(), zone);
-        break;
-      case BOOL32x4_REGISTERS:
-        op = LBool32x4Register::Create(assigned_register(), zone);
-        break;
-      case INT32x4_REGISTERS:
-        op = LInt32x4Register::Create(assigned_register(), zone);
-        break;
       default:
         UNREACHABLE();
     }
@@ -467,7 +458,7 @@ void LiveRange::ConvertOperands(Zone* zone) {
 
     if (use_pos->HasOperand()) {
       DCHECK(op->IsRegister() || op->IsDoubleRegister() ||
-             op->IsSIMD128Register() || !use_pos->RequiresRegister());
+             !use_pos->RequiresRegister());
       use_pos->operand()->ConvertTo(op->kind(), op->index());
     }
     use_pos = use_pos->next();
@@ -532,7 +523,6 @@ LAllocator::LAllocator(int num_values, HGraph* graph)
       active_live_ranges_(8, zone()),
       inactive_live_ranges_(8, zone()),
       reusable_slots_(8, zone()),
-      reusable_simd128_slots_(8, zone()),
       next_virtual_register_(num_values),
       first_artificial_register_(num_values),
       mode_(UNALLOCATED_REGISTERS),
@@ -851,21 +841,6 @@ void LAllocator::MeetConstraintsBetween(LInstruction* first,
           double_artificial_registers_.Add(
               cur_input->virtual_register() - first_artificial_register_,
               zone());
-        } else if (RequiredRegisterKind(input_copy->virtual_register()) ==
-                   FLOAT32x4_REGISTERS) {
-          float32x4_artificial_registers_.Add(
-              cur_input->virtual_register() - first_artificial_register_,
-              zone());
-        } else if (RequiredRegisterKind(input_copy->virtual_register()) ==
-                   BOOL32x4_REGISTERS) {
-          bool32x4_artificial_registers_.Add(
-              cur_input->virtual_register() - first_artificial_register_,
-              zone());
-        } else if (RequiredRegisterKind(input_copy->virtual_register()) ==
-                   INT32x4_REGISTERS) {
-          int32x4_artificial_registers_.Add(
-              cur_input->virtual_register() - first_artificial_register_,
-              zone());
         }
 
         AddConstraintsGapMove(gap_index, input_copy, cur_input);
@@ -1187,9 +1162,7 @@ void LAllocator::ResolveControlFlow(LiveRange* range,
           if (HasTaggedValue(range->id())) {
             branch->pointer_map()->RecordPointer(cur_op, chunk()->zone());
           } else if (!cur_op->IsDoubleStackSlot() &&
-                     !cur_op->IsDoubleRegister() &&
-                     !cur_op->IsSIMD128StackSlot() &&
-                     !cur_op->IsSIMD128Register()) {
+                     !cur_op->IsDoubleRegister()) {
             branch->pointer_map()->RemovePointer(cur_op);
           }
         }
@@ -1512,9 +1485,6 @@ void LAllocator::AllocateRegisters() {
     if (live_ranges_[i] != NULL) {
       if (live_ranges_[i]->Kind() == mode_) {
         AddToUnhandledUnsorted(live_ranges_[i]);
-      } else if (mode_ == DOUBLE_REGISTERS &&
-                 IsSIMD128RegisterKind(live_ranges_[i]->Kind())) {
-        AddToUnhandledUnsorted(live_ranges_[i]);
       }
     }
   }
@@ -1522,7 +1492,6 @@ void LAllocator::AllocateRegisters() {
   DCHECK(UnhandledIsSorted());
 
   DCHECK(reusable_slots_.is_empty());
-  DCHECK(reusable_simd128_slots_.is_empty());
   DCHECK(active_live_ranges_.is_empty());
   DCHECK(inactive_live_ranges_.is_empty());
 
@@ -1614,7 +1583,6 @@ void LAllocator::AllocateRegisters() {
   }
 
   reusable_slots_.Rewind(0);
-  reusable_simd128_slots_.Rewind(0);
   active_live_ranges_.Rewind(0);
   inactive_live_ranges_.Rewind(0);
 }
@@ -1651,25 +1619,10 @@ RegisterKind LAllocator::RequiredRegisterKind(int virtual_register) const {
     HValue* value = graph_->LookupValue(virtual_register);
     if (value != NULL && value->representation().IsDouble()) {
       return DOUBLE_REGISTERS;
-    } else if (value != NULL && (value->representation().IsFloat32x4())) {
-      return FLOAT32x4_REGISTERS;
-    } else if (value != NULL && (value->representation().IsBool32x4())) {
-      return BOOL32x4_REGISTERS;
-    } else if (value != NULL && (value->representation().IsInt32x4())) {
-      return INT32x4_REGISTERS;
     }
   } else if (double_artificial_registers_.Contains(
       virtual_register - first_artificial_register_)) {
     return DOUBLE_REGISTERS;
-  } else if (float32x4_artificial_registers_.Contains(
-                 virtual_register - first_artificial_register_)) {
-    return FLOAT32x4_REGISTERS;
-  } else if (bool32x4_artificial_registers_.Contains(
-                 virtual_register - first_artificial_register_)) {
-    return BOOL32x4_REGISTERS;
-  } else if (int32x4_artificial_registers_.Contains(
-                 virtual_register - first_artificial_register_)) {
-    return INT32x4_REGISTERS;
   }
 
   return GENERAL_REGISTERS;
@@ -1752,26 +1705,19 @@ void LAllocator::FreeSpillSlot(LiveRange* range) {
 
   int index = range->TopLevel()->GetSpillOperand()->index();
   if (index >= 0) {
-    if (IsSIMD128RegisterKind(range->Kind())) {
-      reusable_simd128_slots_.Add(range, zone());
-    } else {
-      reusable_slots_.Add(range, zone());
-    }
+    reusable_slots_.Add(range, zone());
   }
 }
 
 
 LOperand* LAllocator::TryReuseSpillSlot(LiveRange* range) {
-  ZoneList<LiveRange*>* reusable_slots = IsSIMD128RegisterKind(range->Kind())
-                                             ? &reusable_simd128_slots_
-                                             : &reusable_slots_;
-  if (reusable_slots->is_empty()) return NULL;
-  if (reusable_slots->first()->End().Value() >
+  if (reusable_slots_.is_empty()) return NULL;
+  if (reusable_slots_.first()->End().Value() >
       range->TopLevel()->Start().Value()) {
     return NULL;
   }
-  LOperand* result = reusable_slots->first()->TopLevel()->GetSpillOperand();
-  reusable_slots->Remove(0);
+  LOperand* result = reusable_slots_.first()->TopLevel()->GetSpillOperand();
+  reusable_slots_.Remove(0);
   return result;
 }
 
@@ -1834,8 +1780,7 @@ bool LAllocator::TryAllocateFreeReg(LiveRange* current) {
   }
 
   LOperand* hint = current->FirstHint();
-  if (hint != NULL && (hint->IsRegister() || hint->IsDoubleRegister() ||
-                       hint->IsSIMD128Register())) {
+  if (hint != NULL && (hint->IsRegister() || hint->IsDoubleRegister())) {
     int register_index = hint->index();
     TraceAlloc(
         "Found reg hint %s (free until [%d) for live range %d (end %d[).\n",
@@ -2188,21 +2133,7 @@ void LAllocator::Spill(LiveRange* range) {
 
   if (!first->HasAllocatedSpillOperand()) {
     LOperand* op = TryReuseSpillSlot(range);
-    if (op == NULL) {
-      op = chunk_->GetNextSpillSlot(range->Kind());
-    } else if (range->Kind() == FLOAT32x4_REGISTERS &&
-               op->kind() != LOperand::FLOAT32x4_STACK_SLOT) {
-      // Convert to Float32x4StackSlot.
-      op = LFloat32x4StackSlot::Create(op->index(), zone());
-    } else if (range->Kind() == BOOL32x4_REGISTERS &&
-               op->kind() != LOperand::BOOL32x4_STACK_SLOT) {
-      // Convert to Bool32x4StackSlot.
-      op = LBool32x4StackSlot::Create(op->index(), zone());
-    } else if (range->Kind() == INT32x4_REGISTERS &&
-               op->kind() != LOperand::INT32x4_STACK_SLOT) {
-      // Convert to Int32x4StackSlot.
-      op = LInt32x4StackSlot::Create(op->index(), zone());
-    }
+    if (op == NULL) op = chunk_->GetNextSpillSlot(range->Kind());
     first->SetSpillOperand(op);
   }
   range->MakeSpilled(chunk()->zone());
diff --git a/src/crankshaft/lithium-allocator.h b/src/crankshaft/lithium-allocator.h
index 262ba683b5..ce0e56560b 100644
--- a/src/crankshaft/lithium-allocator.h
+++ b/src/crankshaft/lithium-allocator.h
@@ -116,10 +116,6 @@ class LifetimePosition {
   int value_;
 };
 
-inline bool IsSIMD128RegisterKind(RegisterKind kind) {
-  return kind == FLOAT32x4_REGISTERS || kind == BOOL32x4_REGISTERS ||
-         kind == INT32x4_REGISTERS;
-}
 
 // Representation of the non-empty interval [start,end[.
 class UseInterval: public ZoneObject {
@@ -533,16 +529,11 @@ class LAllocator BASE_EMBEDDED {
   ZoneList<LiveRange*> active_live_ranges_;
   ZoneList<LiveRange*> inactive_live_ranges_;
   ZoneList<LiveRange*> reusable_slots_;
-  // Slots reusable for float32x4, bool32x4 and int32x4 register spilling.
-  ZoneList<LiveRange*> reusable_simd128_slots_;
 
   // Next virtual register number to be assigned to temporaries.
   int next_virtual_register_;
   int first_artificial_register_;
   GrowableBitVector double_artificial_registers_;
-  GrowableBitVector float32x4_artificial_registers_;
-  GrowableBitVector bool32x4_artificial_registers_;
-  GrowableBitVector int32x4_artificial_registers_;
 
   RegisterKind mode_;
   int num_registers_;
diff --git a/src/crankshaft/lithium.cc b/src/crankshaft/lithium.cc
index 99f7d51d78..4b3e0bc63a 100644
--- a/src/crankshaft/lithium.cc
+++ b/src/crankshaft/lithium.cc
@@ -116,15 +116,6 @@ void LOperand::PrintTo(StringStream* stream) {
       }
       break;
     }
-    case FLOAT32x4_STACK_SLOT:
-      stream->Add("[float32x4_stack:%d]", index());
-      break;
-    case BOOL32x4_STACK_SLOT:
-      stream->Add("[bool32x4_stack:%d]", index());
-      break;
-    case INT32x4_STACK_SLOT:
-      stream->Add("[int32x4_stack:%d]", index());
-      break;
     case DOUBLE_REGISTER: {
       int reg_index = index();
       if (reg_index < 0 || reg_index >= DoubleRegister::kMaxNumRegisters) {
@@ -134,35 +125,6 @@ void LOperand::PrintTo(StringStream* stream) {
       }
       break;
     }
-    case FLOAT32x4_REGISTER:
-#if V8_TARGET_ARCH_IA32 || V8_TARGET_ARCH_X64
-      stream->Add(
-          "[%s|R]",
-          RegisterConfiguration::Crankshaft()->GetSimd128RegisterName(index()));
-#else
-      stream->Add("[%s|R]", "Target hasn't no method toString()");
-#endif
-      break;
-    case BOOL32x4_REGISTER:
-
-#if V8_TARGET_ARCH_IA32 || V8_TARGET_ARCH_X64
-      stream->Add("[%s|R]", "QwNeonRegister hasn't no toString");
-      stream->Add(
-          "[%s|R]",
-          RegisterConfiguration::Crankshaft()->GetSimd128RegisterName(index()));
-#else
-      stream->Add("[%s|R]", "Target hasn't no method toString()");
-#endif
-      break;
-    case INT32x4_REGISTER:
-#if V8_TARGET_ARCH_IA32 || V8_TARGET_ARCH_X64
-      stream->Add(
-          "[%s|R]",
-          RegisterConfiguration::Crankshaft()->GetSimd128RegisterName(index()));
-#else
-      stream->Add("[%s|R]", "Target hasn't no method toString()");
-#endif
-      break;
   }
 }
 
@@ -254,10 +216,7 @@ void LEnvironment::PrintTo(StringStream* stream) {
 void LPointerMap::RecordPointer(LOperand* op, Zone* zone) {
   // Do not record arguments as pointers.
   if (op->IsStackSlot() && op->index() < 0) return;
-  DCHECK(!op->IsDoubleRegister() && !op->IsDoubleStackSlot() &&
-         !op->IsFloat32x4Register() && !op->IsFloat32x4StackSlot() &&
-         !op->IsBool32x4Register() && !op->IsBool32x4StackSlot() &&
-         !op->IsInt32x4Register() && !op->IsInt32x4StackSlot());
+  DCHECK(!op->IsDoubleRegister() && !op->IsDoubleStackSlot());
   pointer_operands_.Add(op, zone);
 }
 
@@ -265,10 +224,7 @@ void LPointerMap::RecordPointer(LOperand* op, Zone* zone) {
 void LPointerMap::RemovePointer(LOperand* op) {
   // Do not record arguments as pointers.
   if (op->IsStackSlot() && op->index() < 0) return;
-  DCHECK(!op->IsDoubleRegister() && !op->IsDoubleStackSlot() &&
-         !op->IsFloat32x4Register() && !op->IsFloat32x4StackSlot() &&
-         !op->IsBool32x4Register() && !op->IsBool32x4StackSlot() &&
-         !op->IsInt32x4Register() && !op->IsInt32x4StackSlot());
+  DCHECK(!op->IsDoubleRegister() && !op->IsDoubleStackSlot());
   for (int i = 0; i < pointer_operands_.length(); ++i) {
     if (pointer_operands_[i]->Equals(op)) {
       pointer_operands_.Remove(i);
@@ -281,10 +237,7 @@ void LPointerMap::RemovePointer(LOperand* op) {
 void LPointerMap::RecordUntagged(LOperand* op, Zone* zone) {
   // Do not record arguments as pointers.
   if (op->IsStackSlot() && op->index() < 0) return;
-  DCHECK(!op->IsDoubleRegister() && !op->IsDoubleStackSlot() &&
-         !op->IsFloat32x4Register() && !op->IsFloat32x4StackSlot() &&
-         !op->IsBool32x4Register() && !op->IsBool32x4StackSlot() &&
-         !op->IsInt32x4Register() && !op->IsInt32x4StackSlot());
+  DCHECK(!op->IsDoubleRegister() && !op->IsDoubleStackSlot());
   untagged_operands_.Add(op, zone);
 }
 
diff --git a/src/crankshaft/lithium.h b/src/crankshaft/lithium.h
index 5c7ed075cd..a2c028330b 100644
--- a/src/crankshaft/lithium.h
+++ b/src/crankshaft/lithium.h
@@ -17,18 +17,12 @@
 namespace v8 {
 namespace internal {
 
-#define LITHIUM_OPERAND_LIST(V)                    \
-  V(ConstantOperand, CONSTANT_OPERAND, 128)        \
-  V(StackSlot, STACK_SLOT, 128)                    \
-  V(DoubleStackSlot, DOUBLE_STACK_SLOT, 128)       \
-  V(Float32x4StackSlot, FLOAT32x4_STACK_SLOT, 128) \
-  V(Bool32x4StackSlot, BOOL32x4_STACK_SLOT, 128)   \
-  V(Int32x4StackSlot, INT32x4_STACK_SLOT, 128)     \
-  V(Register, REGISTER, 16)                        \
-  V(DoubleRegister, DOUBLE_REGISTER, 16)           \
-  V(Float32x4Register, FLOAT32x4_REGISTER, 16)     \
-  V(Bool32x4Register, BOOL32x4_REGISTER, 16)       \
-  V(Int32x4Register, INT32x4_REGISTER, 16)
+#define LITHIUM_OPERAND_LIST(V)               \
+  V(ConstantOperand, CONSTANT_OPERAND,  128)  \
+  V(StackSlot,       STACK_SLOT,        128)  \
+  V(DoubleStackSlot, DOUBLE_STACK_SLOT, 128)  \
+  V(Register,        REGISTER,          16)   \
+  V(DoubleRegister,  DOUBLE_REGISTER,   16)
 
 class LOperand : public ZoneObject {
  public:
@@ -38,14 +32,8 @@ class LOperand : public ZoneObject {
     CONSTANT_OPERAND,
     STACK_SLOT,
     DOUBLE_STACK_SLOT,
-    FLOAT32x4_STACK_SLOT,
-    BOOL32x4_STACK_SLOT,
-    INT32x4_STACK_SLOT,
     REGISTER,
-    DOUBLE_REGISTER,
-    FLOAT32x4_REGISTER,
-    BOOL32x4_REGISTER,
-    INT32x4_REGISTER
+    DOUBLE_REGISTER
   };
 
   LOperand() : value_(KindField::encode(INVALID)) { }
@@ -58,20 +46,7 @@ class LOperand : public ZoneObject {
   LITHIUM_OPERAND_PREDICATE(Unallocated, UNALLOCATED, 0)
   LITHIUM_OPERAND_PREDICATE(Ignored, INVALID, 0)
 #undef LITHIUM_OPERAND_PREDICATE
-  bool IsSIMD128Register() const {
-    return kind() == FLOAT32x4_REGISTER || kind() == BOOL32x4_REGISTER ||
-           kind() == INT32x4_REGISTER;
-  }
-  bool IsSIMD128StackSlot() const {
-    return kind() == FLOAT32x4_STACK_SLOT || kind() == BOOL32x4_STACK_SLOT ||
-           kind() == INT32x4_STACK_SLOT;
-  }
-  bool Equals(LOperand* other) const {
-    return value_ == other->value_ ||
-           (index() == other->index() &&
-            ((IsSIMD128Register() && other->IsSIMD128Register()) ||
-             (IsSIMD128StackSlot() && other->IsSIMD128StackSlot())));
-  }
+  bool Equals(LOperand* other) const { return value_ == other->value_; }
 
   void PrintTo(StringStream* stream);
   void ConvertTo(Kind kind, int index) {
@@ -86,7 +61,7 @@ class LOperand : public ZoneObject {
   static void TearDownCaches();
 
  protected:
-  static const int kKindFieldWidth = 4;
+  static const int kKindFieldWidth = 3;
   class KindField : public BitField<Kind, 0, kKindFieldWidth> { };
 
   LOperand(Kind kind, int index) { ConvertTo(kind, index); }
@@ -171,32 +146,32 @@ class LUnallocated : public LOperand {
   // because it accommodates a larger pay-load.
   //
   // For FIXED_SLOT policy:
-  //     +-------------------------------------------+
-  //     |       slot_index      |  vreg  | 0 | 0001 |
-  //     +-------------------------------------------+
+  //     +------------------------------------------+
+  //     |       slot_index      |  vreg  | 0 | 001 |
+  //     +------------------------------------------+
   //
   // For all other (extended) policies:
-  //     +-------------------------------------------+
-  //     |  reg_index  | L | PPP |  vreg  | 1 | 0001 |    L ... Lifetime
-  //     +-------------------------------------------+    P ... Policy
+  //     +------------------------------------------+
+  //     |  reg_index  | L | PPP |  vreg  | 1 | 001 |    L ... Lifetime
+  //     +------------------------------------------+    P ... Policy
   //
   // The slot index is a signed value which requires us to decode it manually
   // instead of using the BitField utility class.
 
   // The superclass has a KindField.
-  STATIC_ASSERT(kKindFieldWidth == 4);
+  STATIC_ASSERT(kKindFieldWidth == 3);
 
   // BitFields for all unallocated operands.
-  class BasicPolicyField : public BitField<BasicPolicy, 4, 1> {};
-  class VirtualRegisterField : public BitField<unsigned, 5, 18> {};
+  class BasicPolicyField     : public BitField<BasicPolicy,     3,  1> {};
+  class VirtualRegisterField : public BitField<unsigned,        4, 18> {};
 
   // BitFields specific to BasicPolicy::FIXED_SLOT.
-  class FixedSlotIndexField : public BitField<int, 23, 9> {};
+  class FixedSlotIndexField  : public BitField<int,            22, 10> {};
 
   // BitFields specific to BasicPolicy::EXTENDED_POLICY.
-  class ExtendedPolicyField : public BitField<ExtendedPolicy, 23, 3> {};
-  class LifetimeField : public BitField<Lifetime, 26, 1> {};
-  class FixedRegisterField : public BitField<int, 27, 5> {};
+  class ExtendedPolicyField  : public BitField<ExtendedPolicy, 22,  3> {};
+  class LifetimeField        : public BitField<Lifetime,       25,  1> {};
+  class FixedRegisterField   : public BitField<int,            26,  6> {};
 
   static const int kMaxVirtualRegisters = VirtualRegisterField::kMax + 1;
   static const int kFixedSlotIndexWidth = FixedSlotIndexField::kSize;
@@ -822,13 +797,11 @@ class LPhase : public CompilationPhase {
 
 // A register-allocator view of a Lithium instruction. It contains the id of
 // the output operand and a list of input operand uses.
+
 enum RegisterKind {
   UNALLOCATED_REGISTERS,
   GENERAL_REGISTERS,
-  DOUBLE_REGISTERS,
-  FLOAT32x4_REGISTERS,
-  BOOL32x4_REGISTERS,
-  INT32x4_REGISTERS
+  DOUBLE_REGISTERS
 };
 
 // Iterator for non-null temp operands.
diff --git a/src/crankshaft/mips/lithium-mips.cc b/src/crankshaft/mips/lithium-mips.cc
index 4fa4e234dc..e7066209c4 100644
--- a/src/crankshaft/mips/lithium-mips.cc
+++ b/src/crankshaft/mips/lithium-mips.cc
@@ -1181,46 +1181,6 @@ LInstruction* LChunkBuilder::DoMathRound(HUnaryMathOperation* instr) {
   return AssignEnvironment(DefineAsRegister(result));
 }
 
-LInstruction* LChunkBuilder::DoNullarySIMDOperation(
-    HNullarySIMDOperation* instr) {
-  UNIMPLEMENTED();
-  return NULL;
-}
-
-LInstruction* LChunkBuilder::DoUnarySIMDOperation(HUnarySIMDOperation* instr) {
-  UNIMPLEMENTED();
-  return NULL;
-}
-
-LInstruction* LChunkBuilder::DoBinarySIMDOperation(
-    HBinarySIMDOperation* instr) {
-  UNIMPLEMENTED();
-  return NULL;
-}
-
-LInstruction* LChunkBuilder::DoTernarySIMDOperation(
-    HTernarySIMDOperation* instr) {
-  UNIMPLEMENTED();
-  return NULL;
-}
-
-LInstruction* LChunkBuilder::DoQuarternarySIMDOperation(
-    HQuarternarySIMDOperation* instr) {
-  UNIMPLEMENTED();
-  return NULL;
-}
-
-LInstruction* LChunkBuilder::DoQuinarySIMDOperation(
-    HQuinarySIMDOperation* instr) {
-  UNIMPLEMENTED();
-  return NULL;
-}
-
-LInstruction* LChunkBuilder::DoSenarySIMDOperation(
-    HSenarySIMDOperation* instr) {
-  UNIMPLEMENTED();
-  return NULL;
-}
 
 LInstruction* LChunkBuilder::DoCallNewArray(HCallNewArray* instr) {
   LOperand* context = UseFixed(instr->context(), cp);
diff --git a/src/crankshaft/x64/lithium-codegen-x64.cc b/src/crankshaft/x64/lithium-codegen-x64.cc
index 87a5252382..c82f6c1498 100644
--- a/src/crankshaft/x64/lithium-codegen-x64.cc
+++ b/src/crankshaft/x64/lithium-codegen-x64.cc
@@ -408,9 +408,6 @@ XMMRegister LCodeGen::ToDoubleRegister(int index) const {
   return XMMRegister::from_code(index);
 }
 
-XMMRegister LCodeGen::ToSIMD128Register(int index) const {
-  return XMMRegister::from_code(index);
-}
 
 Register LCodeGen::ToRegister(LOperand* op) const {
   DCHECK(op->IsRegister());
@@ -423,26 +420,6 @@ XMMRegister LCodeGen::ToDoubleRegister(LOperand* op) const {
   return ToDoubleRegister(op->index());
 }
 
-XMMRegister LCodeGen::ToFloat32x4Register(LOperand* op) const {
-  DCHECK(op->IsFloat32x4Register());
-  return ToSIMD128Register(op->index());
-}
-
-XMMRegister LCodeGen::ToBool32x4Register(LOperand* op) const {
-  DCHECK(op->IsBool32x4Register());
-  return ToSIMD128Register(op->index());
-}
-
-XMMRegister LCodeGen::ToInt32x4Register(LOperand* op) const {
-  DCHECK(op->IsInt32x4Register());
-  return ToSIMD128Register(op->index());
-}
-
-XMMRegister LCodeGen::ToSIMD128Register(LOperand* op) const {
-  DCHECK(op->IsFloat32x4Register() || op->IsBool32x4Register() ||
-         op->IsInt32x4Register());
-  return ToSIMD128Register(op->index());
-}
 
 bool LCodeGen::IsInteger32Constant(LConstantOperand* op) const {
   return chunk_->LookupLiteralRepresentation(op).IsSmiOrInteger32();
@@ -516,9 +493,7 @@ static int ArgumentsOffsetWithoutFrame(int index) {
 Operand LCodeGen::ToOperand(LOperand* op) const {
   // Does not handle registers. In X64 assembler, plain registers are not
   // representable as an Operand.
-  DCHECK(op->IsStackSlot() || op->IsDoubleStackSlot() ||
-         op->IsFloat32x4StackSlot() || op->IsBool32x4StackSlot() ||
-         op->IsInt32x4StackSlot());
+  DCHECK(op->IsStackSlot() || op->IsDoubleStackSlot());
   if (NeedsEagerFrame()) {
     return Operand(rbp, FrameSlotToFPOffset(op->index()));
   } else {
@@ -598,25 +573,6 @@ void LCodeGen::AddToTranslation(LEnvironment* environment,
   } else if (op->IsDoubleStackSlot()) {
     int index = op->index();
     translation->StoreDoubleStackSlot(index);
-  } else if (op->IsFloat32x4StackSlot()) {
-    int index = op->index();
-    if (index >= 0) {
-      index += StandardFrameConstants::kFixedFrameSize / kPointerSize;
-    }
-    translation->StoreSIMD128StackSlot(index,
-                                       Translation::FLOAT32x4_STACK_SLOT);
-  } else if (op->IsBool32x4StackSlot()) {
-    int index = op->index();
-    if (index >= 0) {
-      index += StandardFrameConstants::kFixedFrameSize / kPointerSize;
-    }
-    translation->StoreSIMD128StackSlot(index, Translation::BOOL32x4_STACK_SLOT);
-  } else if (op->IsInt32x4StackSlot()) {
-    int index = op->index();
-    if (index >= 0) {
-      index += StandardFrameConstants::kFixedFrameSize / kPointerSize;
-    }
-    translation->StoreSIMD128StackSlot(index, Translation::INT32x4_STACK_SLOT);
   } else if (op->IsRegister()) {
     Register reg = ToRegister(op);
     if (is_tagged) {
@@ -629,15 +585,6 @@ void LCodeGen::AddToTranslation(LEnvironment* environment,
   } else if (op->IsDoubleRegister()) {
     XMMRegister reg = ToDoubleRegister(op);
     translation->StoreDoubleRegister(reg);
-  } else if (op->IsFloat32x4Register()) {
-    XMMRegister reg = ToFloat32x4Register(op);
-    translation->StoreSIMD128Register(reg, Translation::FLOAT32x4_REGISTER);
-  } else if (op->IsBool32x4Register()) {
-    XMMRegister reg = ToBool32x4Register(op);
-    translation->StoreSIMD128Register(reg, Translation::BOOL32x4_REGISTER);
-  } else if (op->IsInt32x4Register()) {
-    XMMRegister reg = ToInt32x4Register(op);
-    translation->StoreSIMD128Register(reg, Translation::INT32x4_REGISTER);
   } else if (op->IsConstantOperand()) {
     HConstant* constant = chunk()->LookupConstant(LConstantOperand::cast(op));
     int src_index = DefineDeoptimizationLiteral(constant->handle(isolate()));
@@ -2024,9 +1971,6 @@ void LCodeGen::DoBranch(LBranch* instr) {
     __ Xorpd(xmm_scratch, xmm_scratch);
     __ Ucomisd(reg, xmm_scratch);
     EmitBranch(instr, not_equal);
-  } else if (r.IsSIMD128()) {
-    DCHECK(!info()->IsStub());
-    EmitBranch(instr, no_condition);
   } else {
     DCHECK(r.IsTagged());
     Register reg = ToRegister(instr->value());
@@ -2801,19 +2745,6 @@ void LCodeGen::DoAccessArgumentsAt(LAccessArgumentsAt* instr) {
   }
 }
 
-bool LCodeGen::HandleExternalArrayOpRequiresPreScale(
-    LOperand* key, Representation key_representation,
-    ElementsKind elements_kind) {
-  Register key_reg = ToRegister(key);
-  if (ExternalArrayOpRequiresPreScale(key_representation, elements_kind)) {
-    int pre_shift_size = ElementsKindToShiftSize(elements_kind) -
-                         static_cast<int>(maximal_scale_factor);
-    DCHECK(pre_shift_size > 0);
-    __ shll(key_reg, Immediate(pre_shift_size));
-    return true;
-  }
-  return false;
-}
 
 void LCodeGen::DoLoadKeyedExternalArray(LLoadKeyed* instr) {
   ElementsKind elements_kind = instr->elements_kind();
@@ -2823,22 +2754,13 @@ void LCodeGen::DoLoadKeyedExternalArray(LLoadKeyed* instr) {
     Representation key_representation =
         instr->hydrogen()->key()->representation();
     if (ExternalArrayOpRequiresTemp(key_representation, elements_kind)) {
-      if (!HandleExternalArrayOpRequiresPreScale(key, key_representation,
-                                                 elements_kind))
-        __ SmiToInteger64(key_reg, key_reg);
+      __ SmiToInteger64(key_reg, key_reg);
     } else if (instr->hydrogen()->IsDehoisted()) {
       // Sign extend key because it could be a 32 bit negative value
       // and the dehoisted address computation happens in 64 bits
       __ movsxlq(key_reg, key_reg);
     }
-  } else if (kPointerSize == kInt64Size && !key->IsConstantOperand()) {
-    Representation key_representation =
-        instr->hydrogen()->key()->representation();
-    if (ExternalArrayOpRequiresTemp(key_representation, elements_kind))
-      HandleExternalArrayOpRequiresPreScale(key, key_representation,
-                                            elements_kind);
   }
-
   Operand operand(BuildFastArrayOperand(
       instr->elements(),
       key,
@@ -2851,8 +2773,6 @@ void LCodeGen::DoLoadKeyedExternalArray(LLoadKeyed* instr) {
     __ Cvtss2sd(result, operand);
   } else if (elements_kind == FLOAT64_ELEMENTS) {
     __ Movsd(ToDoubleRegister(instr->result()), operand);
-  } else if (IsSIMD128ElementsKind(elements_kind)) {
-    __ movups(ToSIMD128Register(instr->result()), operand);
   } else {
     Register result(ToRegister(instr->result()));
     switch (elements_kind) {
@@ -3023,7 +2943,6 @@ Operand LCodeGen::BuildFastArrayOperand(
     if (constant_value & 0xF0000000) {
       Abort(kArrayIndexConstantValueTooBig);
     }
-
     return Operand(elements_pointer_reg,
                    (constant_value << shift_size) + offset);
   } else {
@@ -3640,1135 +3559,6 @@ void LCodeGen::DoMathPowHalf(LMathPowHalf* instr) {
   __ bind(&done);
 }
 
-void LCodeGen::DoNullarySIMDOperation(LNullarySIMDOperation* instr) {
-  switch (instr->op()) {
-    case kFloat32x4Zero: {
-      XMMRegister result_reg = ToFloat32x4Register(instr->result());
-      __ xorps(result_reg, result_reg);
-      return;
-    }
-    case kInt32x4Zero: {
-      XMMRegister result_reg = ToInt32x4Register(instr->result());
-      __ xorps(result_reg, result_reg);
-      return;
-    }
-    default:
-      UNREACHABLE();
-      return;
-  }
-}
-
-void LCodeGen::DoUnarySIMDOperation(LUnarySIMDOperation* instr) {
-  uint8_t select = 0;
-  switch (instr->op()) {
-    case kFloat32x4Check: {
-      XMMRegister input_reg = ToFloat32x4Register(instr->value());
-      XMMRegister result_reg = ToFloat32x4Register(instr->result());
-      if (!result_reg.is(input_reg)) {
-        __ movaps(result_reg, input_reg);
-      }
-      return;
-    }
-    case kInt32x4Check: {
-      XMMRegister input_reg = ToInt32x4Register(instr->value());
-      XMMRegister result_reg = ToInt32x4Register(instr->result());
-      if (!result_reg.is(input_reg)) {
-        __ movaps(result_reg, input_reg);
-      }
-      return;
-    }
-    case kSIMD128Change: {
-      Comment(
-          ";;; deoptimize: can not perform representation change"
-          "for float32x4 or int32x4");
-      DeoptimizeIf(no_condition, instr, Deoptimizer::kForcedDeoptToRuntime);
-      return;
-    }
-    case kFloat32x4Abs:
-    case kFloat32x4Neg:
-    case kFloat32x4RecipApprox:
-    case kFloat32x4RecipSqrtApprox:
-    case kFloat32x4Sqrt: {
-      DCHECK(instr->value()->Equals(instr->result()));
-      DCHECK(instr->hydrogen()->value()->representation().IsFloat32x4());
-      XMMRegister input_reg = ToFloat32x4Register(instr->value());
-      switch (instr->op()) {
-        case kFloat32x4Abs:
-          __ absps(input_reg);
-          break;
-        case kFloat32x4Neg:
-          __ negateps(input_reg);
-          break;
-        case kFloat32x4RecipApprox:
-          __ rcpps(input_reg, input_reg);
-          break;
-        case kFloat32x4RecipSqrtApprox:
-          __ rsqrtps(input_reg, input_reg);
-          break;
-        case kFloat32x4Sqrt:
-          __ sqrtps(input_reg, input_reg);
-          break;
-        default:
-          UNREACHABLE();
-          break;
-      }
-      return;
-    }
-    case kInt32x4Not:
-    case kInt32x4Neg: {
-      DCHECK(instr->hydrogen()->value()->representation().IsInt32x4());
-      XMMRegister input_reg = ToInt32x4Register(instr->value());
-      switch (instr->op()) {
-        case kInt32x4Not:
-          __ notps(input_reg);
-          break;
-        case kInt32x4Neg:
-          __ pnegd(input_reg);
-          break;
-        default:
-          UNREACHABLE();
-          break;
-      }
-      return;
-    }
-    case kFloat32x4BitsToInt32x4:
-    case kFloat32x4ToInt32x4: {
-      DCHECK(instr->hydrogen()->value()->representation().IsFloat32x4());
-      XMMRegister input_reg = ToFloat32x4Register(instr->value());
-      XMMRegister result_reg = ToInt32x4Register(instr->result());
-      if (instr->op() == kFloat32x4BitsToInt32x4) {
-        if (!result_reg.is(input_reg)) {
-          __ movaps(result_reg, input_reg);
-        }
-      } else {
-        DCHECK(instr->op() == kFloat32x4ToInt32x4);
-        __ cvtps2dq(result_reg, input_reg);
-      }
-      return;
-    }
-    case kInt32x4BitsToFloat32x4:
-    case kInt32x4ToFloat32x4: {
-      DCHECK(instr->hydrogen()->value()->representation().IsInt32x4());
-      XMMRegister input_reg = ToInt32x4Register(instr->value());
-      XMMRegister result_reg = ToFloat32x4Register(instr->result());
-      if (instr->op() == kInt32x4BitsToFloat32x4) {
-        if (!result_reg.is(input_reg)) {
-          __ movaps(result_reg, input_reg);
-        }
-      } else {
-        DCHECK(instr->op() == kInt32x4ToFloat32x4);
-        __ cvtdq2ps(result_reg, input_reg);
-      }
-      return;
-    }
-    case kFloat32x4Splat: {
-      DCHECK(instr->hydrogen()->value()->representation().IsDouble());
-      XMMRegister input_reg = ToDoubleRegister(instr->value());
-      XMMRegister result_reg = ToFloat32x4Register(instr->result());
-      XMMRegister xmm_scratch = double_scratch0();
-      __ xorps(xmm_scratch, xmm_scratch);
-      __ cvtsd2ss(xmm_scratch, input_reg);
-      __ shufps(xmm_scratch, xmm_scratch, 0x0);
-      __ movaps(result_reg, xmm_scratch);
-      return;
-    }
-    case kInt32x4Splat: {
-      DCHECK(instr->hydrogen()->value()->representation().IsInteger32());
-      Register input_reg = ToRegister(instr->value());
-      XMMRegister result_reg = ToInt32x4Register(instr->result());
-      __ movd(result_reg, input_reg);
-      __ shufps(result_reg, result_reg, 0x0);
-      return;
-    }
-    case kInt32x4GetSignMask: {
-      DCHECK(instr->hydrogen()->value()->representation().IsInt32x4());
-      XMMRegister input_reg = ToInt32x4Register(instr->value());
-      Register result = ToRegister(instr->result());
-      __ movmskps(result, input_reg);
-      return;
-    }
-    case kFloat32x4GetSignMask: {
-      DCHECK(instr->hydrogen()->value()->representation().IsFloat32x4());
-      XMMRegister input_reg = ToFloat32x4Register(instr->value());
-      Register result = ToRegister(instr->result());
-      __ movmskps(result, input_reg);
-      return;
-    }
-    case kFloat32x4GetW:
-      select++;
-    case kFloat32x4GetZ:
-      select++;
-    case kFloat32x4GetY:
-      select++;
-    case kFloat32x4GetX: {
-      DCHECK(instr->hydrogen()->value()->representation().IsFloat32x4());
-      XMMRegister input_reg = ToFloat32x4Register(instr->value());
-      XMMRegister result = ToDoubleRegister(instr->result());
-      XMMRegister xmm_scratch = result.is(input_reg) ? xmm0 : result;
-
-      if (select == 0x0) {
-        __ xorps(xmm_scratch, xmm_scratch);
-        __ cvtss2sd(xmm_scratch, input_reg);
-        if (!xmm_scratch.is(result)) {
-          __ movaps(result, xmm_scratch);
-        }
-      } else {
-        __ pshufd(xmm_scratch, input_reg, select);
-        if (!xmm_scratch.is(result)) {
-          __ xorps(result, result);
-        }
-        __ cvtss2sd(result, xmm_scratch);
-      }
-      return;
-    }
-    case kBool32x4AnyTrue: {
-      DCHECK(instr->hydrogen()->value()->representation().IsBool32x4());
-      XMMRegister input_reg = ToBool32x4Register(instr->value());
-      Register result = ToRegister(instr->result());
-      __ movmskps(result, input_reg);
-      Label false_value, done;
-      __ testl(result, result);
-      __ j(zero, &false_value, Label::kNear);
-      __ LoadRoot(result, Heap::kTrueValueRootIndex);
-      __ jmp(&done, Label::kNear);
-      __ bind(&false_value);
-      __ LoadRoot(result, Heap::kFalseValueRootIndex);
-      __ bind(&done);
-      return;
-    }
-    case kBool32x4AllTrue: {
-      DCHECK(instr->hydrogen()->value()->representation().IsBool32x4());
-      XMMRegister input_reg = ToBool32x4Register(instr->value());
-      Register result = ToRegister(instr->result());
-      __ movmskps(result, input_reg);
-      Label true_value, done;
-      __ xorl(result, Immediate(0xF));
-      __ j(zero, &true_value, Label::kNear);
-      __ LoadRoot(result, Heap::kFalseValueRootIndex);
-      __ jmp(&done, Label::kNear);
-      __ bind(&true_value);
-      __ LoadRoot(result, Heap::kTrueValueRootIndex);
-      __ bind(&done);
-      return;
-    }
-    case kInt32x4GetX:
-    case kInt32x4GetY:
-    case kInt32x4GetZ:
-    case kInt32x4GetW:
-    case kInt32x4GetFlagX:
-    case kInt32x4GetFlagY:
-    case kInt32x4GetFlagZ:
-    case kInt32x4GetFlagW: {
-      DCHECK(instr->hydrogen()->value()->representation().IsInt32x4());
-      bool flag = false;
-      switch (instr->op()) {
-        case kInt32x4GetFlagX:
-          flag = true;
-        case kInt32x4GetX:
-          break;
-        case kInt32x4GetFlagY:
-          flag = true;
-        case kInt32x4GetY:
-          select = 0x1;
-          break;
-        case kInt32x4GetFlagZ:
-          flag = true;
-        case kInt32x4GetZ:
-          select = 0x2;
-          break;
-        case kInt32x4GetFlagW:
-          flag = true;
-        case kInt32x4GetW:
-          select = 0x3;
-          break;
-        default:
-          UNREACHABLE();
-      }
-
-      XMMRegister input_reg = ToInt32x4Register(instr->value());
-      Register result = ToRegister(instr->result());
-      if (select == 0x0) {
-        __ movd(result, input_reg);
-      } else {
-        if (CpuFeatures::IsSupported(SSE4_1)) {
-          CpuFeatureScope scope(masm(), SSE4_1);
-          __ extractps(result, input_reg, select);
-        } else {
-          XMMRegister xmm_scratch = xmm0;
-          __ pshufd(xmm_scratch, input_reg, select);
-          __ movd(result, xmm_scratch);
-        }
-      }
-
-      if (flag) {
-        Label false_value, done;
-        __ testl(result, result);
-        __ j(zero, &false_value, Label::kNear);
-        __ LoadRoot(result, Heap::kTrueValueRootIndex);
-        __ jmp(&done, Label::kNear);
-        __ bind(&false_value);
-        __ LoadRoot(result, Heap::kFalseValueRootIndex);
-        __ bind(&done);
-      }
-      return;
-    }
-    default:
-      UNREACHABLE();
-      return;
-  }
-}
-
-#define DCHECK_EXTRACTLANE(TYPE)                                  \
-  DCHECK(instr->hydrogen()->left()->representation().Is##TYPE()); \
-  DCHECK(instr->hydrogen()->right()->representation().IsInteger32());
-
-void LCodeGen::DoBinarySIMDOperation(LBinarySIMDOperation* instr) {
-  uint8_t imm8 = 0;  // for with operation
-  switch (instr->op()) {
-    case kFloat32x4ExtractLane: {
-      DCHECK_EXTRACTLANE(Float32x4);
-      Condition cc = never;
-      if (instr->hydrogen()->right()->IsConstant() &&
-          HConstant::cast(instr->hydrogen()->right())->HasInteger32Value()) {
-        uint32_t right = ToInteger32(LConstantOperand::cast(instr->right()));
-        DCHECK((right >= 0) && (right <= 3));
-        XMMRegister left_reg = ToFloat32x4Register(instr->left());
-        XMMRegister result = ToDoubleRegister(instr->result());
-        XMMRegister xmm_scratch = result.is(left_reg) ? xmm0 : result;
-        imm8 = right;
-        if (imm8 == 0x0) {
-          __ xorps(xmm_scratch, xmm_scratch);
-          __ cvtss2sd(xmm_scratch, left_reg);
-          __ movaps(result, xmm_scratch);
-        } else {
-          __ pshufd(xmm_scratch, left_reg, imm8);
-          __ cvtss2sd(result, xmm_scratch);
-        }
-      } else {
-        cc = no_condition;
-        Comment(";;; deoptimize: non-constant selector for extractLane");
-      }
-      DeoptimizeIf(cc, instr, Deoptimizer::kForcedDeoptToRuntime);
-      return;
-    }
-    case kInt32x4ExtractLane: {
-      DCHECK_EXTRACTLANE(Int32x4);
-      Condition cc = never;
-      if (instr->hydrogen()->right()->IsConstant() &&
-          HConstant::cast(instr->hydrogen()->right())->HasInteger32Value()) {
-        uint32_t right = ToInteger32(LConstantOperand::cast(instr->right()));
-        DCHECK((right >= 0) && (right <= 3));
-        XMMRegister left_reg = ToInt32x4Register(instr->left());
-        Register result = ToRegister(instr->result());
-        imm8 = right;
-        if (imm8 == 0x0) {
-          __ movd(result, left_reg);
-        } else {
-          if (CpuFeatures::IsSupported(SSE4_1)) {
-            CpuFeatureScope scope(masm(), SSE4_1);
-            __ extractps(result, left_reg, imm8);
-          } else {
-            XMMRegister xmm_scratch = xmm0;
-            __ pshufd(xmm_scratch, left_reg, imm8);
-            __ movd(result, xmm_scratch);
-          }
-        }
-      } else {
-        Comment(";;; deoptimize: non-constant selector for extractLane");
-        cc = no_condition;
-      }
-      DeoptimizeIf(cc, instr, Deoptimizer::kForcedDeoptToRuntime);
-      return;
-    }
-    case kBool32x4ExtractLane: {
-      DCHECK_EXTRACTLANE(Bool32x4);
-      Condition cc = never;
-      if (instr->hydrogen()->right()->IsConstant() &&
-          HConstant::cast(instr->hydrogen()->right())->HasInteger32Value()) {
-        uint32_t right = ToInteger32(LConstantOperand::cast(instr->right()));
-        DCHECK((right >= 0) && (right <= 3));
-        XMMRegister left_reg = ToBool32x4Register(instr->left());
-        Register result = ToRegister(instr->result());
-        imm8 = right;
-        if (imm8 == 0x0) {
-          __ movd(result, left_reg);
-        } else {
-          if (CpuFeatures::IsSupported(SSE4_1)) {
-            CpuFeatureScope scope(masm(), SSE4_1);
-            __ extractps(result, left_reg, imm8);
-          } else {
-            XMMRegister xmm_scratch = xmm0;
-            __ pshufd(xmm_scratch, left_reg, imm8);
-            __ movd(result, xmm_scratch);
-          }
-        }
-        {
-          Label false_value, done;
-          __ testl(result, result);
-          __ j(zero, &false_value, Label::kNear);
-          __ LoadRoot(result, Heap::kTrueValueRootIndex);
-          __ jmp(&done, Label::kNear);
-          __ bind(&false_value);
-          __ LoadRoot(result, Heap::kFalseValueRootIndex);
-          __ bind(&done);
-        }
-      } else {
-        Comment(";;; deoptimize: non-constant selector for extractLane");
-        cc = no_condition;
-      }
-      DeoptimizeIf(cc, instr, Deoptimizer::kForcedDeoptToRuntime);
-      return;
-    }
-    case kFloat32x4Add:
-    case kFloat32x4Sub:
-    case kFloat32x4Mul:
-    case kFloat32x4Div:
-    case kFloat32x4Min:
-    case kFloat32x4Max: {
-      DCHECK(instr->left()->Equals(instr->result()));
-      DCHECK(instr->hydrogen()->left()->representation().IsFloat32x4());
-      DCHECK(instr->hydrogen()->right()->representation().IsFloat32x4());
-      XMMRegister left_reg = ToFloat32x4Register(instr->left());
-      XMMRegister right_reg = ToFloat32x4Register(instr->right());
-      switch (instr->op()) {
-        case kFloat32x4Add:
-          __ addps(left_reg, right_reg);
-          break;
-        case kFloat32x4Sub:
-          __ subps(left_reg, right_reg);
-          break;
-        case kFloat32x4Mul:
-          __ mulps(left_reg, right_reg);
-          break;
-        case kFloat32x4Div:
-          __ divps(left_reg, right_reg);
-          break;
-        case kFloat32x4Min:
-          __ minps(left_reg, right_reg);
-          break;
-        case kFloat32x4Max:
-          __ maxps(left_reg, right_reg);
-          break;
-        default:
-          UNREACHABLE();
-          break;
-      }
-      return;
-    }
-    case kFloat32x4Shuffle: {
-      DCHECK(instr->left()->Equals(instr->result()));
-      DCHECK(instr->hydrogen()->left()->representation().IsFloat32x4());
-      Condition cc = never;
-      if (instr->hydrogen()->right()->IsConstant() &&
-          HConstant::cast(instr->hydrogen()->right())->HasInteger32Value()) {
-        int32_t value = ToInteger32(LConstantOperand::cast(instr->right()));
-        uint8_t select = static_cast<uint8_t>(value & 0xFF);
-        XMMRegister left_reg = ToFloat32x4Register(instr->left());
-        __ shufps(left_reg, left_reg, select);
-      } else {
-        Comment(";;; deoptimize: non-constant selector for shuffle");
-        cc = no_condition;
-      }
-      DeoptimizeIf(cc, instr, Deoptimizer::kForcedDeoptToRuntime);
-      return;
-    }
-    case kInt32x4Shuffle: {
-      DCHECK(instr->left()->Equals(instr->result()));
-      DCHECK(instr->hydrogen()->left()->representation().IsInt32x4());
-      Condition cc = never;
-      if (instr->hydrogen()->right()->IsConstant() &&
-          HConstant::cast(instr->hydrogen()->right())->HasInteger32Value()) {
-        int32_t value = ToInteger32(LConstantOperand::cast(instr->right()));
-        uint8_t select = static_cast<uint8_t>(value & 0xFF);
-        XMMRegister left_reg = ToInt32x4Register(instr->left());
-        __ pshufd(left_reg, left_reg, select);
-      } else {
-        Comment(";;; deoptimize: non-constant selector for shuffle");
-        cc = no_condition;
-      }
-      DeoptimizeIf(cc, instr, Deoptimizer::kForcedDeoptToRuntime);
-      return;
-    }
-    case kInt32x4ShiftLeft:
-    case kInt32x4ShiftRightArithmetic: {
-      DCHECK(instr->left()->Equals(instr->result()));
-      DCHECK(instr->hydrogen()->left()->representation().IsInt32x4());
-      if (instr->hydrogen()->right()->IsConstant() &&
-          HConstant::cast(instr->hydrogen()->right())->HasInteger32Value()) {
-        int32_t value = ToInteger32(LConstantOperand::cast(instr->right()));
-        uint8_t shift = static_cast<uint8_t>(value & 0xFF);
-        XMMRegister left_reg = ToInt32x4Register(instr->left());
-        switch (instr->op()) {
-          case kInt32x4ShiftLeft:
-            __ pslld(left_reg, shift);
-            break;
-          case kInt32x4ShiftRightArithmetic:
-            __ psrad(left_reg, shift);
-            break;
-          default:
-            UNREACHABLE();
-        }
-        return;
-      } else {
-        XMMRegister left_reg = ToInt32x4Register(instr->left());
-        Register shift = ToRegister(instr->right());
-        XMMRegister xmm_scratch = double_scratch0();
-        __ movd(xmm_scratch, shift);
-        switch (instr->op()) {
-          case kInt32x4ShiftLeft:
-            __ pslld(left_reg, xmm_scratch);
-            break;
-          case kInt32x4ShiftRightArithmetic:
-            __ psrad(left_reg, xmm_scratch);
-            break;
-          default:
-            UNREACHABLE();
-        }
-        return;
-      }
-    }
-    case kFloat32x4LessThan:
-    case kFloat32x4LessThanOrEqual:
-    case kFloat32x4Equal:
-    case kFloat32x4NotEqual:
-    case kFloat32x4GreaterThanOrEqual:
-    case kFloat32x4GreaterThan: {
-      DCHECK(instr->hydrogen()->left()->representation().IsFloat32x4());
-      DCHECK(instr->hydrogen()->right()->representation().IsFloat32x4());
-      XMMRegister left_reg = ToFloat32x4Register(instr->left());
-      XMMRegister right_reg = ToFloat32x4Register(instr->right());
-      XMMRegister result_reg = ToBool32x4Register(instr->result());
-      switch (instr->op()) {
-        case kFloat32x4LessThan:
-          if (result_reg.is(left_reg)) {
-            __ cmpltps(result_reg, right_reg);
-          } else if (result_reg.is(right_reg)) {
-            __ cmpnltps(result_reg, left_reg);
-          } else {
-            __ movaps(result_reg, left_reg);
-            __ cmpltps(result_reg, right_reg);
-          }
-          break;
-        case kFloat32x4LessThanOrEqual:
-          if (result_reg.is(left_reg)) {
-            __ cmpleps(result_reg, right_reg);
-          } else if (result_reg.is(right_reg)) {
-            __ cmpnleps(result_reg, left_reg);
-          } else {
-            __ movaps(result_reg, left_reg);
-            __ cmpleps(result_reg, right_reg);
-          }
-          break;
-        case kFloat32x4Equal:
-          if (result_reg.is(left_reg)) {
-            __ cmpeqps(result_reg, right_reg);
-          } else if (result_reg.is(right_reg)) {
-            __ cmpeqps(result_reg, left_reg);
-          } else {
-            __ movaps(result_reg, left_reg);
-            __ cmpeqps(result_reg, right_reg);
-          }
-          break;
-        case kFloat32x4NotEqual:
-          if (result_reg.is(left_reg)) {
-            __ cmpneqps(result_reg, right_reg);
-          } else if (result_reg.is(right_reg)) {
-            __ cmpneqps(result_reg, left_reg);
-          } else {
-            __ movaps(result_reg, left_reg);
-            __ cmpneqps(result_reg, right_reg);
-          }
-          break;
-        case kFloat32x4GreaterThanOrEqual:
-          if (result_reg.is(left_reg)) {
-            __ cmpnltps(result_reg, right_reg);
-          } else if (result_reg.is(right_reg)) {
-            __ cmpltps(result_reg, left_reg);
-          } else {
-            __ movaps(result_reg, left_reg);
-            __ cmpnltps(result_reg, right_reg);
-          }
-          break;
-        case kFloat32x4GreaterThan:
-          if (result_reg.is(left_reg)) {
-            __ cmpnleps(result_reg, right_reg);
-          } else if (result_reg.is(right_reg)) {
-            __ cmpleps(result_reg, left_reg);
-          } else {
-            __ movaps(result_reg, left_reg);
-            __ cmpnleps(result_reg, right_reg);
-          }
-          break;
-        default:
-          UNREACHABLE();
-          break;
-      }
-      return;
-    }
-    case kInt32x4And:
-    case kInt32x4Or:
-    case kInt32x4Xor:
-    case kInt32x4Add:
-    case kInt32x4Sub:
-    case kInt32x4Mul:
-    case kInt32x4GreaterThan:
-    case kInt32x4Equal:
-    case kInt32x4LessThan: {
-      DCHECK(instr->left()->Equals(instr->result()));
-      DCHECK(instr->hydrogen()->left()->representation().IsInt32x4());
-      DCHECK(instr->hydrogen()->right()->representation().IsInt32x4());
-      XMMRegister left_reg = ToInt32x4Register(instr->left());
-      XMMRegister right_reg = ToInt32x4Register(instr->right());
-      switch (instr->op()) {
-        case kInt32x4And:
-          __ andps(left_reg, right_reg);
-          break;
-        case kInt32x4Or:
-          __ orps(left_reg, right_reg);
-          break;
-        case kInt32x4Xor:
-          __ xorps(left_reg, right_reg);
-          break;
-        case kInt32x4Add:
-          __ paddd(left_reg, right_reg);
-          break;
-        case kInt32x4Sub:
-          __ psubd(left_reg, right_reg);
-          break;
-        case kInt32x4Mul:
-          if (CpuFeatures::IsSupported(SSE4_1)) {
-            CpuFeatureScope scope(masm(), SSE4_1);
-            __ pmulld(left_reg, right_reg);
-          } else {
-            // The algorithm is from
-            // http://stackoverflow.com/questions/10500766/sse-multiplication-of-4-32-bit-integers
-            XMMRegister xmm_scratch = xmm0;
-            __ movaps(xmm_scratch, left_reg);
-            __ pmuludq(left_reg, right_reg);
-            __ psrldq(xmm_scratch, 4);
-            __ psrldq(right_reg, 4);
-            __ pmuludq(xmm_scratch, right_reg);
-            __ pshufd(left_reg, left_reg, 8);
-            __ pshufd(xmm_scratch, xmm_scratch, 8);
-            __ punpackldq(left_reg, xmm_scratch);
-          }
-          break;
-        case kInt32x4GreaterThan:
-          __ pcmpgtd(left_reg, right_reg);
-          break;
-        case kInt32x4Equal:
-          __ pcmpeqd(left_reg, right_reg);
-          break;
-        case kInt32x4LessThan: {
-          XMMRegister xmm_scratch = xmm0;
-          __ movaps(xmm_scratch, right_reg);
-          __ pcmpgtd(xmm_scratch, left_reg);
-          __ movaps(left_reg, xmm_scratch);
-          break;
-        }
-        default:
-          UNREACHABLE();
-          break;
-      }
-      return;
-    }
-    default:
-      UNREACHABLE();
-      return;
-  }
-}
-
-void LCodeGen::DoTernarySIMDOperation(LTernarySIMDOperation* instr) {
-  uint8_t imm8 = 0;
-  switch (instr->op()) {
-    case kFloat32x4Select: {
-      DCHECK(instr->hydrogen()->first()->representation().IsBool32x4());
-      DCHECK(instr->hydrogen()->second()->representation().IsFloat32x4());
-      DCHECK(instr->hydrogen()->third()->representation().IsFloat32x4());
-
-      XMMRegister mask_reg = ToBool32x4Register(instr->first());
-      XMMRegister left_reg = ToFloat32x4Register(instr->second());
-      XMMRegister right_reg = ToFloat32x4Register(instr->third());
-      XMMRegister result_reg = ToFloat32x4Register(instr->result());
-      XMMRegister temp_reg = xmm0;
-
-      // Copy mask.
-      __ movaps(temp_reg, mask_reg);
-      // Invert it.
-      __ notps(temp_reg);
-      // temp_reg = temp_reg & falseValue.
-      __ andps(temp_reg, right_reg);
-
-      if (!result_reg.is(mask_reg)) {
-        if (result_reg.is(left_reg)) {
-          // result_reg = result_reg & trueValue.
-          __ andps(result_reg, mask_reg);
-          // out = result_reg | temp_reg.
-          __ orps(result_reg, temp_reg);
-        } else {
-          __ movaps(result_reg, mask_reg);
-          // result_reg = result_reg & trueValue.
-          __ andps(result_reg, left_reg);
-          // out = result_reg | temp_reg.
-          __ orps(result_reg, temp_reg);
-        }
-      } else {
-        // result_reg = result_reg & trueValue.
-        __ andps(result_reg, left_reg);
-        // out = result_reg | temp_reg.
-        __ orps(result_reg, temp_reg);
-      }
-      return;
-    }
-    case kInt32x4Select: {
-      DCHECK(instr->hydrogen()->first()->representation().IsBool32x4());
-      DCHECK(instr->hydrogen()->second()->representation().IsInt32x4());
-      DCHECK(instr->hydrogen()->third()->representation().IsInt32x4());
-
-      XMMRegister mask_reg = ToBool32x4Register(instr->first());
-      XMMRegister left_reg = ToInt32x4Register(instr->second());
-      XMMRegister right_reg = ToInt32x4Register(instr->third());
-      XMMRegister result_reg = ToInt32x4Register(instr->result());
-      XMMRegister temp_reg = double_scratch0();
-
-      // Copy mask.
-      __ movaps(temp_reg, mask_reg);
-      // Invert it.
-      __ notps(temp_reg);
-      // temp_reg = temp_reg & falseValue.
-      __ andps(temp_reg, right_reg);
-
-      if (!result_reg.is(mask_reg)) {
-        if (result_reg.is(left_reg)) {
-          // result_reg = result_reg & trueValue.
-          __ andps(result_reg, mask_reg);
-          // out = result_reg | temp_reg.
-          __ orps(result_reg, temp_reg);
-        } else {
-          __ movaps(result_reg, mask_reg);
-          // result_reg = result_reg & trueValue.
-          __ andps(result_reg, left_reg);
-          // out = result_reg | temp_reg.
-          __ orps(result_reg, temp_reg);
-        }
-      } else {
-        // result_reg = result_reg & trueValue.
-        __ andps(result_reg, left_reg);
-        // out = result_reg | temp_reg.
-        __ orps(result_reg, temp_reg);
-      }
-      return;
-    }
-    case kFloat32x4ReplaceLane: {
-      DCHECK(instr->first()->Equals(instr->result()));
-      DCHECK(instr->hydrogen()->first()->representation().IsFloat32x4());
-      DCHECK(instr->hydrogen()->second()->representation().IsInteger32());
-      DCHECK(instr->hydrogen()->third()->representation().IsDouble());
-      Condition cc = never;
-      if (instr->hydrogen()->second()->IsConstant() &&
-          HConstant::cast(instr->hydrogen()->second())->HasInteger32Value()) {
-        int32_t x = ToInteger32(LConstantOperand::cast(instr->second()));
-        DCHECK((x >= 0) && (x <= 3));
-        switch (x) {
-          case 3:
-            imm8++;
-          case 2:
-            imm8++;
-          case 1:
-            imm8++;
-          case 0:
-            break;
-        }
-        XMMRegister result_reg = ToFloat32x4Register(instr->first());
-        XMMRegister value_reg = ToDoubleRegister(instr->third());
-        XMMRegister xmm_scratch = xmm0;
-        __ xorps(xmm_scratch, xmm_scratch);
-        __ cvtsd2ss(xmm_scratch, value_reg);
-        if (CpuFeatures::IsSupported(SSE4_1)) {
-          imm8 = imm8 << 4;
-          CpuFeatureScope scope(masm(), SSE4_1);
-          __ insertps(result_reg, xmm_scratch, imm8);
-        } else {
-          __ subq(rsp, Immediate(kFloat32x4Size));
-          __ movups(Operand(rsp, 0), result_reg);
-          __ movss(Operand(rsp, imm8 * kFloatSize), xmm_scratch);
-          __ movups(result_reg, Operand(rsp, 0));
-          __ addq(rsp, Immediate(kFloat32x4Size));
-        }
-      } else {
-        Comment(";;; deoptimize: non-constant selector for replacetLane");
-        cc = no_condition;
-      }
-      DeoptimizeIf(cc, instr, Deoptimizer::kForcedDeoptToRuntime);
-      return;
-    }
-    case kInt32x4ReplaceLane: {
-      DCHECK(instr->first()->Equals(instr->result()));
-      DCHECK(instr->hydrogen()->first()->representation().IsInt32x4());
-      DCHECK(instr->hydrogen()->second()->representation().IsInteger32());
-      DCHECK(instr->hydrogen()->third()->representation().IsInteger32());
-      Condition cc = never;
-      if (instr->hydrogen()->second()->IsConstant() &&
-          HConstant::cast(instr->hydrogen()->second())->HasInteger32Value()) {
-        int32_t x = ToInteger32(LConstantOperand::cast(instr->second()));
-        DCHECK((x >= 0) && (x <= 4));
-        switch (x) {
-          case 3:
-            imm8++;
-          case 2:
-            imm8++;
-          case 1:
-            imm8++;
-          case 0:
-            break;
-        }
-        XMMRegister result_reg = ToInt32x4Register(instr->first());
-        Register value_reg = ToRegister(instr->third());
-        if (CpuFeatures::IsSupported(SSE4_1)) {
-          CpuFeatureScope scope(masm(), SSE4_1);
-          __ pinsrd(result_reg, value_reg, imm8);
-        } else {
-          __ subq(rsp, Immediate(kInt32x4Size));
-          __ movdqu(Operand(rsp, 0), result_reg);
-          __ movl(Operand(rsp, imm8 * kFloatSize), value_reg);
-          __ movdqu(result_reg, Operand(rsp, 0));
-          __ addq(rsp, Immediate(kInt32x4Size));
-        }
-      } else {
-        Comment(";;; deoptimize: non-constant selector for replacetLane");
-        cc = no_condition;
-      }
-      DeoptimizeIf(cc, instr, Deoptimizer::kForcedDeoptToRuntime);
-      return;
-    }
-    default:
-      UNREACHABLE();
-      return;
-  }
-}
-
-void LCodeGen::DoQuarternarySIMDOperation(LQuarternarySIMDOperation* instr) {
-  switch (instr->op()) {
-    case kFloat32x4Constructor: {
-      DCHECK(instr->hydrogen()->x()->representation().IsDouble());
-      DCHECK(instr->hydrogen()->y()->representation().IsDouble());
-      DCHECK(instr->hydrogen()->z()->representation().IsDouble());
-      DCHECK(instr->hydrogen()->w()->representation().IsDouble());
-      XMMRegister x_reg = ToDoubleRegister(instr->x());
-      XMMRegister y_reg = ToDoubleRegister(instr->y());
-      XMMRegister z_reg = ToDoubleRegister(instr->z());
-      XMMRegister w_reg = ToDoubleRegister(instr->w());
-      XMMRegister result_reg = ToFloat32x4Register(instr->result());
-      XMMRegister xmm_scratch = double_scratch0();
-      __ subq(rsp, Immediate(kFloat32x4Size));
-      __ xorps(xmm_scratch, xmm_scratch);
-      __ cvtsd2ss(xmm_scratch, x_reg);
-      __ movss(Operand(rsp, 0 * kFloatSize), xmm_scratch);
-      __ xorps(xmm_scratch, xmm_scratch);
-      __ cvtsd2ss(xmm_scratch, y_reg);
-      __ movss(Operand(rsp, 1 * kFloatSize), xmm_scratch);
-      __ xorps(xmm_scratch, xmm_scratch);
-      __ cvtsd2ss(xmm_scratch, z_reg);
-      __ movss(Operand(rsp, 2 * kFloatSize), xmm_scratch);
-      __ xorps(xmm_scratch, xmm_scratch);
-      __ cvtsd2ss(xmm_scratch, w_reg);
-      __ movss(Operand(rsp, 3 * kFloatSize), xmm_scratch);
-      __ movups(result_reg, Operand(rsp, 0 * kFloatSize));
-      __ addq(rsp, Immediate(kFloat32x4Size));
-      return;
-    }
-    case kInt32x4Constructor: {
-      DCHECK(instr->hydrogen()->x()->representation().IsInteger32());
-      DCHECK(instr->hydrogen()->y()->representation().IsInteger32());
-      DCHECK(instr->hydrogen()->z()->representation().IsInteger32());
-      DCHECK(instr->hydrogen()->w()->representation().IsInteger32());
-      Register x_reg = ToRegister(instr->x());
-      Register y_reg = ToRegister(instr->y());
-      Register z_reg = ToRegister(instr->z());
-      Register w_reg = ToRegister(instr->w());
-      XMMRegister result_reg = ToInt32x4Register(instr->result());
-      __ subq(rsp, Immediate(kInt32x4Size));
-      __ movl(Operand(rsp, 0 * kInt32Size), x_reg);
-      __ movl(Operand(rsp, 1 * kInt32Size), y_reg);
-      __ movl(Operand(rsp, 2 * kInt32Size), z_reg);
-      __ movl(Operand(rsp, 3 * kInt32Size), w_reg);
-      __ movups(result_reg, Operand(rsp, 0 * kInt32Size));
-      __ addq(rsp, Immediate(kInt32x4Size));
-      return;
-    }
-    case kBool32x4Constructor: {
-      DCHECK(instr->hydrogen()->x()->representation().IsTagged());
-      DCHECK(instr->hydrogen()->y()->representation().IsTagged());
-      DCHECK(instr->hydrogen()->z()->representation().IsTagged());
-      DCHECK(instr->hydrogen()->w()->representation().IsTagged());
-      DCHECK(instr->hydrogen()->x()->type().IsBoolean());
-      DCHECK(instr->hydrogen()->y()->type().IsBoolean());
-      DCHECK(instr->hydrogen()->z()->type().IsBoolean());
-      DCHECK(instr->hydrogen()->w()->type().IsBoolean());
-
-      Register x_reg = ToRegister(instr->x());
-      Register y_reg = ToRegister(instr->y());
-      Register z_reg = ToRegister(instr->z());
-      Register w_reg = ToRegister(instr->w());
-      XMMRegister result_reg = ToBool32x4Register(instr->result());
-
-      Immediate neg(-1);
-      Label done_x, done_y, done_z, done_w;
-
-      __ xorps(result_reg, result_reg);
-      __ subq(rsp, Immediate(kBool32x4Size));
-      __ movups(Operand(rsp, 0 * kBool32Size), result_reg);
-
-      __ CompareRoot(x_reg, Heap::kTrueValueRootIndex);
-      __ j(not_equal, &done_x, Label::kNear);
-      __ movl(Operand(rsp, 0 * kBool32Size), neg);
-      __ jmp(&done_x, Label::kNear);
-      __ bind(&done_x);
-
-      __ CompareRoot(y_reg, Heap::kTrueValueRootIndex);
-      __ j(not_equal, &done_y, Label::kNear);
-      __ movl(Operand(rsp, 1 * kBool32Size), neg);
-      __ jmp(&done_y, Label::kNear);
-      __ bind(&done_y);
-
-      __ CompareRoot(z_reg, Heap::kTrueValueRootIndex);
-      __ j(not_equal, &done_z, Label::kNear);
-      __ movl(Operand(rsp, 2 * kBool32Size), neg);
-      __ jmp(&done_z, Label::kNear);
-      __ bind(&done_z);
-
-      __ CompareRoot(w_reg, Heap::kTrueValueRootIndex);
-      __ j(not_equal, &done_w, Label::kNear);
-      __ movl(Operand(rsp, 3 * kBool32Size), neg);
-      __ jmp(&done_w, Label::kNear);
-      __ bind(&done_w);
-
-      __ movups(result_reg, Operand(rsp, 0 * kBool32Size));
-      __ addq(rsp, Immediate(kBool32x4Size));
-      return;
-    }
-    default:
-      UNREACHABLE();
-      return;
-  }
-}
-
-static uint8_t ComputeShuffleSelect(uint32_t x, uint32_t y, uint32_t z,
-                                    uint32_t w) {
-  DCHECK(x < 4 && y < 4 && z < 4 && w < 4);
-  uint32_t r =
-      static_cast<uint8_t>(((w << 6) | (z << 4) | (y << 2) | (x << 0)) & 0xFF);
-  return r;
-}
-
-void LCodeGen::DoQuinarySIMDOperation(LQuinarySIMDOperation* instr) {
-  switch (instr->op()) {
-    case kFloat32x4Swizzle: {
-      DCHECK(instr->a0()->Equals(instr->result()));
-      DCHECK(instr->hydrogen()->a0()->representation().IsFloat32x4());
-      Condition cc = never;
-      if ((instr->hydrogen()->a1()->IsConstant() &&
-           HConstant::cast(instr->hydrogen()->a1())->HasInteger32Value()) &&
-          (instr->hydrogen()->a2()->IsConstant() &&
-           HConstant::cast(instr->hydrogen()->a2())->HasInteger32Value()) &&
-          (instr->hydrogen()->a3()->IsConstant() &&
-           HConstant::cast(instr->hydrogen()->a3())->HasInteger32Value()) &&
-          (instr->hydrogen()->a4()->IsConstant() &&
-           HConstant::cast(instr->hydrogen()->a4())->HasInteger32Value())) {
-        int32_t x = ToInteger32(LConstantOperand::cast(instr->a1()));
-        int32_t y = ToInteger32(LConstantOperand::cast(instr->a2()));
-        int32_t z = ToInteger32(LConstantOperand::cast(instr->a3()));
-        int32_t w = ToInteger32(LConstantOperand::cast(instr->a4()));
-        uint8_t select = ComputeShuffleSelect(x, y, z, w);
-        XMMRegister left_reg = ToFloat32x4Register(instr->a0());
-        __ shufps(left_reg, left_reg, select);
-      } else {
-        Comment(";;; deoptimize: non-constant selector for swizzle");
-        cc = no_condition;
-      }
-      DeoptimizeIf(cc, instr, Deoptimizer::kForcedDeoptToRuntime);
-      return;
-    }
-    case kInt32x4Swizzle: {
-      DCHECK(instr->a0()->Equals(instr->result()));
-      DCHECK(instr->hydrogen()->a0()->representation().IsInt32x4());
-      Condition cc = never;
-      if ((instr->hydrogen()->a1()->IsConstant() &&
-           HConstant::cast(instr->hydrogen()->a1())->HasInteger32Value()) &&
-          (instr->hydrogen()->a2()->IsConstant() &&
-           HConstant::cast(instr->hydrogen()->a2())->HasInteger32Value()) &&
-          (instr->hydrogen()->a3()->IsConstant() &&
-           HConstant::cast(instr->hydrogen()->a3())->HasInteger32Value()) &&
-          (instr->hydrogen()->a4()->IsConstant() &&
-           HConstant::cast(instr->hydrogen()->a4())->HasInteger32Value())) {
-        int32_t x = ToInteger32(LConstantOperand::cast(instr->a1()));
-        int32_t y = ToInteger32(LConstantOperand::cast(instr->a2()));
-        int32_t z = ToInteger32(LConstantOperand::cast(instr->a3()));
-        int32_t w = ToInteger32(LConstantOperand::cast(instr->a4()));
-        uint8_t select = ComputeShuffleSelect(x, y, z, w);
-        XMMRegister left_reg = ToInt32x4Register(instr->a0());
-        __ pshufd(left_reg, left_reg, select);
-      } else {
-        Comment(";;; deoptimize: non-constant selector for shuffle");
-        cc = no_condition;
-      }
-      DeoptimizeIf(cc, instr, Deoptimizer::kForcedDeoptToRuntime);
-      return;
-    }
-    default:
-      UNREACHABLE();
-      return;
-  }
-}
-
-void LCodeGen::DoSenarySIMDOperation(LSenarySIMDOperation* instr) {
-  switch (instr->op()) {
-    case kFloat32x4Shuffle:
-    case kInt32x4Shuffle: {
-      Condition cc = never;
-      DCHECK(instr->a0()->Equals(instr->result()));
-      if (instr->op() == kFloat32x4Shuffle) {
-        DCHECK(instr->hydrogen()->a0()->representation().IsFloat32x4());
-        DCHECK(instr->hydrogen()->a1()->representation().IsFloat32x4());
-      } else {
-        DCHECK(instr->hydrogen()->a0()->representation().IsInt32x4());
-        DCHECK(instr->hydrogen()->a1()->representation().IsInt32x4());
-      }
-
-      if ((instr->hydrogen()->a2()->IsConstant() &&
-           HConstant::cast(instr->hydrogen()->a2())->HasInteger32Value()) &&
-          (instr->hydrogen()->a3()->IsConstant() &&
-           HConstant::cast(instr->hydrogen()->a3())->HasInteger32Value()) &&
-          (instr->hydrogen()->a4()->IsConstant() &&
-           HConstant::cast(instr->hydrogen()->a4())->HasInteger32Value()) &&
-          (instr->hydrogen()->a5()->IsConstant() &&
-           HConstant::cast(instr->hydrogen()->a5())->HasInteger32Value())) {
-        int32_t x = ToInteger32(LConstantOperand::cast(instr->a2()));
-        int32_t y = ToInteger32(LConstantOperand::cast(instr->a3()));
-        int32_t z = ToInteger32(LConstantOperand::cast(instr->a4()));
-        int32_t w = ToInteger32(LConstantOperand::cast(instr->a5()));
-        XMMRegister lhs, rhs;
-        if (instr->op() == kFloat32x4Shuffle) {
-          lhs = ToFloat32x4Register(instr->a0());
-          rhs = ToFloat32x4Register(instr->a1());
-        } else {
-          lhs = ToInt32x4Register(instr->a0());
-          rhs = ToInt32x4Register(instr->a1());
-        }
-        XMMRegister temp = xmm0;
-
-        uint32_t num_lanes_from_lhs = (x < 4) + (y < 4) + (z < 4) + (w < 4);
-        if (num_lanes_from_lhs == 4) {
-          uint8_t select = ComputeShuffleSelect(x, y, z, w);
-          __ shufps(lhs, lhs, select);
-        } else if (num_lanes_from_lhs == 0) {
-          x -= 4;
-          y -= 4;
-          z -= 4;
-          w -= 4;
-          uint8_t select = ComputeShuffleSelect(x, y, z, w);
-          __ movaps(lhs, rhs);
-          __ shufps(lhs, lhs, select);
-        } else if (num_lanes_from_lhs == 3) {
-          uint8_t first_select = 0xFF;
-          uint8_t second_select = 0xFF;
-          if (x < 4 && y < 4) {
-            if (w >= 4) {
-              w -= 4;
-              // T = (Rw Rw Lz Lz) = shufps(firstMask, lhs, rhs)
-              first_select = ComputeShuffleSelect(w, w, z, z);
-              // (Lx Ly Lz Rw) = (Lx Ly Tz Tx) = shufps(secondMask, T, lhs)
-              second_select = ComputeShuffleSelect(x, y, 2, 0);
-            } else {
-              DCHECK(z >= 4);
-              z -= 4;
-              // T = (Rz Rz Lw Lw) = shufps(firstMask, lhs, rhs)
-              first_select = ComputeShuffleSelect(z, z, w, w);
-              // (Lx Ly Rz Lw) = (Lx Ly Tx Tz) = shufps(secondMask, T, lhs)
-              second_select = ComputeShuffleSelect(x, y, 0, 2);
-            }
-
-            __ movaps(temp, rhs);
-            __ shufps(temp, lhs, first_select);
-            __ shufps(lhs, temp, second_select);
-          }
-
-          DCHECK(z < 4 && w < 4);
-          if (z < 4 && w < 4) {
-            if (y >= 4) {
-              y -= 4;
-              // T = (Ry Ry Lx Lx) = shufps(firstMask, lhs, rhs)
-              first_select = ComputeShuffleSelect(y, y, x, x);
-              // (Lx Ry Lz Lw) = (Tz Tx Lz Lw) = shufps(secondMask, lhs, T)
-              second_select = ComputeShuffleSelect(2, 0, z, w);
-            } else {
-              DCHECK(x >= 4);
-              x -= 4;
-              // T = (Rx Rx Ly Ly) = shufps(firstMask, lhs, rhs)
-              first_select = ComputeShuffleSelect(x, x, y, y);
-              // (Rx Ly Lz Lw) = (Tx Tz Lz Lw) = shufps(secondMask, lhs, T)
-              second_select = ComputeShuffleSelect(0, 2, z, w);
-            }
-
-            __ movaps(temp, rhs);
-            __ shufps(temp, lhs, first_select);
-            __ shufps(temp, lhs, second_select);
-            __ movaps(lhs, temp);
-          }
-        } else if (num_lanes_from_lhs == 2) {
-          if (x < 4 && y < 4) {
-            uint8_t select = ComputeShuffleSelect(x, y, z % 4, w % 4);
-            __ shufps(lhs, rhs, select);
-          } else if (z < 4 && w < 4) {
-            uint8_t select = ComputeShuffleSelect(x % 4, y % 4, z, w);
-            __ movaps(temp, rhs);
-            __ shufps(temp, lhs, select);
-            __ movaps(lhs, temp);
-          } else {
-            // In two shufps, for the most generic case:
-            uint8_t first_select[4], second_select[4];
-            uint32_t i = 0, j = 2, k = 0;
-
-#define COMPUTE_SELECT(lane)    \
-  if (lane >= 4) {              \
-    first_select[j] = lane % 4; \
-    second_select[k++] = j++;   \
-  } else {                      \
-    first_select[i] = lane;     \
-    second_select[k++] = i++;   \
-  }
-
-            COMPUTE_SELECT(x)
-            COMPUTE_SELECT(y)
-            COMPUTE_SELECT(z)
-            COMPUTE_SELECT(w)
-#undef COMPUTE_SELECT
-
-            DCHECK(i == 2 && j == 4 && k == 4);
-
-            int8_t select;
-            select = ComputeShuffleSelect(first_select[0], first_select[1],
-                                          first_select[2], first_select[3]);
-            __ shufps(lhs, rhs, select);
-
-            select = ComputeShuffleSelect(second_select[0], second_select[1],
-                                          second_select[2], second_select[3]);
-            __ shufps(lhs, lhs, select);
-          }
-        }
-      } else {
-        Comment(";;; deoptimize: non-constant selector for shuffle");
-        cc = no_condition;
-      }
-      DeoptimizeIf(cc, instr, Deoptimizer::kForcedDeoptToRuntime);
-      return;
-    }
-
-    default:
-      UNREACHABLE();
-      return;
-  }
-}
 
 void LCodeGen::DoPower(LPower* instr) {
   Representation exponent_type = instr->hydrogen()->right()->representation();
@@ -5199,20 +3989,12 @@ void LCodeGen::DoStoreKeyedExternalArray(LStoreKeyed* instr) {
     Representation key_representation =
         instr->hydrogen()->key()->representation();
     if (ExternalArrayOpRequiresTemp(key_representation, elements_kind)) {
-      if (!HandleExternalArrayOpRequiresPreScale(key, key_representation,
-                                                 elements_kind))
-        __ SmiToInteger64(key_reg, key_reg);
+      __ SmiToInteger64(key_reg, key_reg);
     } else if (instr->hydrogen()->IsDehoisted()) {
       // Sign extend key because it could be a 32 bit negative value
       // and the dehoisted address computation happens in 64 bits
       __ movsxlq(key_reg, key_reg);
     }
-  } else if (kPointerSize == kInt64Size && !key->IsConstantOperand()) {
-    Representation key_representation =
-        instr->hydrogen()->key()->representation();
-    if (ExternalArrayOpRequiresTemp(key_representation, elements_kind))
-      HandleExternalArrayOpRequiresPreScale(key, key_representation,
-                                            elements_kind);
   }
   Operand operand(BuildFastArrayOperand(
       instr->elements(),
@@ -5227,8 +4009,6 @@ void LCodeGen::DoStoreKeyedExternalArray(LStoreKeyed* instr) {
     __ Movss(operand, value);
   } else if (elements_kind == FLOAT64_ELEMENTS) {
     __ Movsd(operand, ToDoubleRegister(instr->value()));
-  } else if (IsSIMD128ElementsKind(elements_kind)) {
-    __ movups(operand, ToSIMD128Register(instr->value()));
   } else {
     Register value(ToRegister(instr->value()));
     switch (elements_kind) {
@@ -5848,81 +4628,6 @@ void LCodeGen::DoDeferredNumberTagD(LNumberTagD* instr) {
   __ movp(reg, kScratchRegister);
 }
 
-void LCodeGen::DoDeferredSIMD128ToTagged(LSIMD128ToTagged* instr,
-                                         Runtime::FunctionId id) {
-  // TODO(3095996): Get rid of this. For now, we need to make the
-  // result register contain a valid pointer because it is already
-  // contained in the register pointer map.
-  Register reg = ToRegister(instr->result());
-  __ Move(reg, Smi::FromInt(0));
-
-  {
-    PushSafepointRegistersScope scope(this);
-    __ movp(rsi, Operand(rbp, StandardFrameConstants::kContextOffset));
-    __ CallRuntimeSaveDoubles(id);
-    RecordSafepointWithRegisters(instr->pointer_map(), 0,
-                                 Safepoint::kNoLazyDeopt);
-    __ movp(kScratchRegister, rax);
-  }
-  __ movp(reg, kScratchRegister);
-}
-
-template <InstanceType I, class T, Runtime::FunctionId D>
-void LCodeGen::HandleSIMD128ToTagged(LSIMD128ToTagged* instr) {
-  class DeferredSIMD128ToTagged final : public LDeferredCode {
-   public:
-    DeferredSIMD128ToTagged(LCodeGen* codegen, LSIMD128ToTagged* instr,
-                            Runtime::FunctionId id)
-        : LDeferredCode(codegen), instr_(instr), id_(id) {}
-    void Generate() override {
-      codegen()->DoDeferredSIMD128ToTagged(instr_, id_);
-    }
-    LInstruction* instr() override { return instr_; }
-
-   private:
-    LSIMD128ToTagged* instr_;
-    Runtime::FunctionId id_;
-  };
-
-  XMMRegister input_reg = ToSIMD128Register(instr->value());
-  Register reg = ToRegister(instr->result());
-  Register tmp = ToRegister(instr->temp());
-  Register tmp2 = ToRegister(instr->temp2());
-  Register tmp3 = ToRegister(instr->temp3());
-
-  DeferredSIMD128ToTagged* deferred = new (zone())
-      DeferredSIMD128ToTagged(this, instr, static_cast<Runtime::FunctionId>(D));
-  if (FLAG_inline_new) {
-    if (I == FLOAT32x4_TYPE) {
-      __ AllocateFloat32x4(reg, tmp, tmp2, tmp3, deferred->entry());
-    } else if (I == BOOL32x4_TYPE) {
-      __ AllocateBool32x4(reg, tmp, tmp2, tmp3, deferred->entry());
-    } else if (I == INT32x4_TYPE) {
-      __ AllocateInt32x4(reg, tmp, tmp2, tmp3, deferred->entry());
-    }
-  } else {
-    __ jmp(deferred->entry());
-  }
-  __ bind(deferred->exit());
-
-  // load the value to SIMD object.
-  __ movups(FieldOperand(reg, T::kValueOffset), input_reg);
-}
-
-void LCodeGen::DoSIMD128ToTagged(LSIMD128ToTagged* instr) {
-  if (instr->value()->IsFloat32x4Register()) {
-    HandleSIMD128ToTagged<FLOAT32x4_TYPE, Float32x4,
-                          Runtime::kAllocateFloat32x4>(instr);
-  } else if (instr->value()->IsBool32x4Register()) {
-    DCHECK(instr->value()->IsBool32x4Register());
-    HandleSIMD128ToTagged<BOOL32x4_TYPE, Bool32x4, Runtime::kAllocateBool32x4>(
-        instr);
-  } else {
-    DCHECK(instr->value()->IsInt32x4Register());
-    HandleSIMD128ToTagged<INT32x4_TYPE, Int32x4, Runtime::kAllocateInt32x4>(
-        instr);
-  }
-}
 
 void LCodeGen::DoSmiTag(LSmiTag* instr) {
   HChange* hchange = instr->hydrogen();
@@ -6113,36 +4818,6 @@ void LCodeGen::DoNumberUntagD(LNumberUntagD* instr) {
   EmitNumberUntagD(instr, input_reg, result_reg, mode);
 }
 
-template <InstanceType I, class T>
-void LCodeGen::HandleTaggedToSIMD128(LTaggedToSIMD128* instr) {
-  LOperand* input = instr->value();
-  DCHECK(input->IsRegister());
-  LOperand* result = instr->result();
-  DCHECK(result->IsSIMD128Register());
-
-  Register input_reg = ToRegister(input);
-  XMMRegister result_reg = ToSIMD128Register(result);
-
-  __ testp(input_reg, Immediate(kSmiTagMask));
-  DeoptimizeIf(zero, instr, Deoptimizer::kSmi);
-  __ CmpObjectType(input_reg, SIMD128_VALUE_TYPE, kScratchRegister);
-  DeoptimizeIf(not_equal, instr, Deoptimizer::kNotASIMD128);
-
-  // Load value to SIMD register.
-  __ movups(result_reg, FieldOperand(input_reg, T::kValueOffset));
-}
-
-void LCodeGen::DoTaggedToSIMD128(LTaggedToSIMD128* instr) {
-  if (instr->representation().IsFloat32x4()) {
-    HandleTaggedToSIMD128<FLOAT32x4_TYPE, Float32x4>(instr);
-  } else if (instr->representation().IsBool32x4()) {
-    DCHECK(instr->representation().IsBool32x4());
-    HandleTaggedToSIMD128<BOOL32x4_TYPE, Bool32x4>(instr);
-  } else {
-    DCHECK(instr->representation().IsInt32x4());
-    HandleTaggedToSIMD128<INT32x4_TYPE, Int32x4>(instr);
-  }
-}
 
 void LCodeGen::DoDoubleToI(LDoubleToI* instr) {
   LOperand* input = instr->value();
diff --git a/src/crankshaft/x64/lithium-codegen-x64.h b/src/crankshaft/x64/lithium-codegen-x64.h
index a0d4e99655..c586ef59af 100644
--- a/src/crankshaft/x64/lithium-codegen-x64.h
+++ b/src/crankshaft/x64/lithium-codegen-x64.h
@@ -55,10 +55,6 @@ class LCodeGen: public LCodeGenBase {
   // Support for converting LOperands to assembler types.
   Register ToRegister(LOperand* op) const;
   XMMRegister ToDoubleRegister(LOperand* op) const;
-  XMMRegister ToFloat32x4Register(LOperand* op) const;
-  XMMRegister ToBool32x4Register(LOperand* op) const;
-  XMMRegister ToInt32x4Register(LOperand* op) const;
-  XMMRegister ToSIMD128Register(LOperand* op) const;
   bool IsInteger32Constant(LConstantOperand* op) const;
   bool IsExternalConstant(LConstantOperand* op) const;
   bool IsDehoistedKeyConstant(LConstantOperand* op) const;
@@ -101,15 +97,8 @@ class LCodeGen: public LCodeGenBase {
   void DoDeferredLoadMutableDouble(LLoadFieldByIndex* instr,
                                    Register object,
                                    Register index);
-  void DoDeferredSIMD128ToTagged(LSIMD128ToTagged* instr,
-                                 Runtime::FunctionId id);
 
-  template <InstanceType I, class T>
-  void HandleTaggedToSIMD128(LTaggedToSIMD128* instr);
-  template <InstanceType I, class T, Runtime::FunctionId F>
-  void HandleSIMD128ToTagged(LSIMD128ToTagged* instr);
-
-  // Parallel move support.
+// Parallel move support.
   void DoParallelMove(LParallelMove* move);
   void DoGap(LGap* instr);
 
@@ -235,7 +224,6 @@ class LCodeGen: public LCodeGenBase {
 
   Register ToRegister(int index) const;
   XMMRegister ToDoubleRegister(int index) const;
-  XMMRegister ToSIMD128Register(int index) const;
   Operand BuildFastArrayOperand(
       LOperand* elements_pointer,
       LOperand* key,
@@ -302,9 +290,6 @@ class LCodeGen: public LCodeGenBase {
 
   void EnsureSpaceForLazyDeopt(int space_needed) override;
   void DoLoadKeyedExternalArray(LLoadKeyed* instr);
-  bool HandleExternalArrayOpRequiresPreScale(LOperand* key,
-                                             Representation key_representation,
-                                             ElementsKind elements_kind);
   void DoLoadKeyedFixedDoubleArray(LLoadKeyed* instr);
   void DoLoadKeyedFixedArray(LLoadKeyed* instr);
   void DoStoreKeyedExternalArray(LStoreKeyed* instr);
diff --git a/src/crankshaft/x64/lithium-gap-resolver-x64.cc b/src/crankshaft/x64/lithium-gap-resolver-x64.cc
index 04e504d538..94dffb333a 100644
--- a/src/crankshaft/x64/lithium-gap-resolver-x64.cc
+++ b/src/crankshaft/x64/lithium-gap-resolver-x64.cc
@@ -226,23 +226,6 @@ void LGapResolver::EmitMove(int index) {
       __ Movsd(kScratchDoubleReg, src);
       __ Movsd(cgen_->ToOperand(destination), kScratchDoubleReg);
     }
-  } else if (source->IsSIMD128Register()) {
-    XMMRegister src = cgen_->ToSIMD128Register(source);
-    if (destination->IsSIMD128Register()) {
-      __ movaps(cgen_->ToSIMD128Register(destination), src);
-    } else {
-      DCHECK(destination->IsSIMD128StackSlot());
-      __ movups(cgen_->ToOperand(destination), src);
-    }
-  } else if (source->IsSIMD128StackSlot()) {
-    Operand src = cgen_->ToOperand(source);
-    if (destination->IsSIMD128Register()) {
-      __ movups(cgen_->ToSIMD128Register(destination), src);
-    } else {
-      DCHECK(destination->IsSIMD128StackSlot());
-      __ movups(xmm0, src);
-      __ movups(cgen_->ToOperand(destination), xmm0);
-    }
   } else {
     UNREACHABLE();
   }
@@ -286,19 +269,6 @@ void LGapResolver::EmitSwap(int index) {
     __ Movsd(dst, kScratchDoubleReg);
     __ movp(src, kScratchRegister);
 
-  } else if ((source->IsSIMD128StackSlot() &&
-              destination->IsSIMD128StackSlot())) {
-    // Swap two XMM stack slots.
-    STATIC_ASSERT(kSIMD128Size == 2 * kDoubleSize);
-    Operand src = cgen_->ToOperand(source);
-    Operand dst = cgen_->ToOperand(destination);
-    __ movups(xmm0, src);
-    __ movq(kScratchRegister, dst);
-    __ movq(src, kScratchRegister);
-    __ movq(kScratchRegister, Operand(dst, kDoubleSize));
-    __ movq(Operand(src, kDoubleSize), kScratchRegister);
-    __ movups(dst, xmm0);
-
   } else if (source->IsDoubleRegister() && destination->IsDoubleRegister()) {
     // Swap two double registers.
     XMMRegister source_reg = cgen_->ToDoubleRegister(source);
@@ -307,14 +277,6 @@ void LGapResolver::EmitSwap(int index) {
     __ Movapd(source_reg, destination_reg);
     __ Movapd(destination_reg, kScratchDoubleReg);
 
-  } else if (source->IsSIMD128Register() && destination->IsSIMD128Register()) {
-    // Swap two XMM registers.
-    XMMRegister source_reg = cgen_->ToSIMD128Register(source);
-    XMMRegister destination_reg = cgen_->ToSIMD128Register(destination);
-    __ movaps(xmm0, source_reg);
-    __ movaps(source_reg, destination_reg);
-    __ movaps(destination_reg, xmm0);
-
   } else if (source->IsDoubleRegister() || destination->IsDoubleRegister()) {
     // Swap a double register and a double stack slot.
     DCHECK((source->IsDoubleRegister() && destination->IsDoubleStackSlot()) ||
@@ -329,18 +291,6 @@ void LGapResolver::EmitSwap(int index) {
     __ Movsd(reg, other_operand);
     __ Movsd(other_operand, kScratchDoubleReg);
 
-  } else if (source->IsSIMD128Register() || destination->IsSIMD128Register()) {
-    // Swap a xmm register and a xmm stack slot.
-    DCHECK((source->IsSIMD128Register() && destination->IsSIMD128StackSlot()) ||
-           (source->IsSIMD128StackSlot() && destination->IsSIMD128Register()));
-    XMMRegister reg = cgen_->ToSIMD128Register(
-        source->IsSIMD128Register() ? source : destination);
-    LOperand* other = source->IsSIMD128Register() ? destination : source;
-    DCHECK(other->IsSIMD128StackSlot());
-    Operand other_operand = cgen_->ToOperand(other);
-    __ movups(xmm0, other_operand);
-    __ movups(other_operand, reg);
-    __ movaps(reg, xmm0);
   } else {
     // No other combinations are possible.
     UNREACHABLE();
diff --git a/src/crankshaft/x64/lithium-x64.cc b/src/crankshaft/x64/lithium-x64.cc
index 5cc71ac437..01b9918d31 100644
--- a/src/crankshaft/x64/lithium-x64.cc
+++ b/src/crankshaft/x64/lithium-x64.cc
@@ -321,23 +321,6 @@ int LPlatformChunk::GetNextSpillIndex(RegisterKind kind) {
     // TODO(haitao): make sure rbp is aligned at 8-byte boundary for x32 port.
     current_frame_slots_ |= 1;
   }
-
-  switch (kind) {
-    case GENERAL_REGISTERS:
-      return current_frame_slots_++;
-    case DOUBLE_REGISTERS:
-      return current_frame_slots_++;
-    case FLOAT32x4_REGISTERS:
-    case BOOL32x4_REGISTERS:
-    case INT32x4_REGISTERS: {
-      current_frame_slots_++;
-      return current_frame_slots_++;
-    }
-    default:
-      UNREACHABLE();
-      return -1;
-  }
-
   return current_frame_slots_++;
 }
 
@@ -347,20 +330,11 @@ LOperand* LPlatformChunk::GetNextSpillSlot(RegisterKind kind) {
   // Alternatively, at some point, start using half-size
   // stack slots for int32 values.
   int index = GetNextSpillIndex(kind);
-  switch (kind) {
-    case GENERAL_REGISTERS:
-      return LStackSlot::Create(index, zone());
-    case DOUBLE_REGISTERS:
-      return LDoubleStackSlot::Create(index, zone());
-    case FLOAT32x4_REGISTERS:
-      return LFloat32x4StackSlot::Create(index, zone());
-    case BOOL32x4_REGISTERS:
-      return LBool32x4StackSlot::Create(index, zone());
-    case INT32x4_REGISTERS:
-      return LInt32x4StackSlot::Create(index, zone());
-    default:
-      UNREACHABLE();
-      return NULL;
+  if (kind == DOUBLE_REGISTERS) {
+    return LDoubleStackSlot::Create(index, zone());
+  } else {
+    DCHECK(kind == GENERAL_REGISTERS);
+    return LStackSlot::Create(index, zone());
   }
 }
 
@@ -1233,234 +1207,6 @@ LInstruction* LChunkBuilder::DoMathPowHalf(HUnaryMathOperation* instr) {
   return DefineSameAsFirst(result);
 }
 
-const char* LNullarySIMDOperation::Mnemonic() const {
-  switch (op()) {
-#define SIMD_NULLARY_OPERATION_CASE_ITEM(module, function, name, p4) \
-  case k##name:                                                      \
-    return #module "-" #function;
-    SIMD_NULLARY_OPERATIONS(SIMD_NULLARY_OPERATION_CASE_ITEM)
-#undef SIMD_NULLARY_OPERATION_CASE_ITEM
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-LInstruction* LChunkBuilder::DoNullarySIMDOperation(
-    HNullarySIMDOperation* instr) {
-  LNullarySIMDOperation* result =
-      new (zone()) LNullarySIMDOperation(instr->op());
-  switch (instr->op()) {
-#define SIMD_NULLARY_OPERATION_CASE_ITEM(module, function, name, p4) \
-  case k##name:
-    SIMD_NULLARY_OPERATIONS(SIMD_NULLARY_OPERATION_CASE_ITEM)
-#undef SIMD_NULLARY_OPERATION_CASE_ITEM
-    return DefineAsRegister(result);
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-const char* LUnarySIMDOperation::Mnemonic() const {
-  switch (op()) {
-    case kSIMD128Change:
-      return "SIMD128-change";
-#define SIMD_UNARY_OPERATION_CASE_ITEM(module, function, name, p4, p5) \
-  case k##name:                                                        \
-    return #module "-" #function;
-      SIMD_UNARY_OPERATIONS(SIMD_UNARY_OPERATION_CASE_ITEM)
-      SIMD_UNARY_OPERATIONS_FOR_PROPERTY_ACCESS(SIMD_UNARY_OPERATION_CASE_ITEM)
-#undef SIMD_UNARY_OPERATION_CASE_ITEM
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-LInstruction* LChunkBuilder::DoUnarySIMDOperation(HUnarySIMDOperation* instr) {
-  LOperand* input = UseRegisterAtStart(instr->value());
-  LUnarySIMDOperation* result =
-      new (zone()) LUnarySIMDOperation(input, instr->op());
-  switch (instr->op()) {
-    case kSIMD128Change:
-      return AssignEnvironment(DefineAsRegister(result));
-    case kFloat32x4Abs:
-    case kFloat32x4Neg:
-    case kFloat32x4RecipApprox:
-    case kFloat32x4RecipSqrtApprox:
-    case kFloat32x4Sqrt:
-    case kInt32x4Neg:
-    case kInt32x4Not:
-      return DefineSameAsFirst(result);
-    case kFloat32x4Check:
-    case kInt32x4Check:
-    case kFloat32x4BitsToInt32x4:
-    case kFloat32x4ToInt32x4:
-    case kInt32x4BitsToFloat32x4:
-    case kInt32x4ToFloat32x4:
-    case kFloat32x4Splat:
-    case kInt32x4Splat:
-    case kFloat32x4GetSignMask:
-    case kFloat32x4GetX:
-    case kFloat32x4GetY:
-    case kFloat32x4GetZ:
-    case kFloat32x4GetW:
-    case kInt32x4GetSignMask:
-    case kInt32x4GetX:
-    case kInt32x4GetY:
-    case kInt32x4GetZ:
-    case kInt32x4GetW:
-    case kBool32x4AnyTrue:
-    case kBool32x4AllTrue:
-    case kInt32x4GetFlagX:
-    case kInt32x4GetFlagY:
-    case kInt32x4GetFlagZ:
-    case kInt32x4GetFlagW:
-      return DefineAsRegister(result);
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-const char* LBinarySIMDOperation::Mnemonic() const {
-  switch (op()) {
-#define SIMD_BINARY_OPERATION_CASE_ITEM(module, function, name, p4, p5, p6) \
-  case k##name:                                                             \
-    return #module "-" #function;
-    SIMD_BINARY_OPERATIONS(SIMD_BINARY_OPERATION_CASE_ITEM)
-#undef SIMD_BINARY_OPERATION_CASE_ITEM
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-LInstruction* LChunkBuilder::DoBinarySIMDOperation(
-    HBinarySIMDOperation* instr) {
-  switch (instr->op()) {
-    case kFloat32x4Add:
-    case kFloat32x4Div:
-    case kFloat32x4Max:
-    case kFloat32x4Min:
-    case kFloat32x4Mul:
-    case kFloat32x4Sub:
-    case kInt32x4Add:
-    case kInt32x4And:
-    case kInt32x4Mul:
-    case kInt32x4Or:
-    case kInt32x4Sub:
-    case kInt32x4Xor:
-    case kInt32x4GreaterThan:
-    case kInt32x4Equal:
-    case kInt32x4LessThan: {
-      LOperand* left = UseRegisterAtStart(instr->left());
-      LOperand* right = UseRegisterAtStart(instr->right());
-      LBinarySIMDOperation* result =
-          new (zone()) LBinarySIMDOperation(left, right, instr->op());
-      return DefineSameAsFirst(result);
-    }
-    case kFloat32x4ExtractLane:
-    case kFloat32x4Shuffle:
-    case kBool32x4ExtractLane:
-    case kInt32x4Shuffle:
-    case kInt32x4ShiftLeft:
-    case kInt32x4ExtractLane:
-    case kInt32x4ShiftRightArithmetic: {
-      LOperand* left = UseRegisterAtStart(instr->left());
-      LOperand* right = UseOrConstant(instr->right());
-      LBinarySIMDOperation* result =
-          new (zone()) LBinarySIMDOperation(left, right, instr->op());
-      if (instr->op() == kFloat32x4ExtractLane ||
-          instr->op() == kBool32x4ExtractLane ||
-          instr->op() == kInt32x4ExtractLane)
-        return AssignEnvironment(DefineAsRegister(result));
-      else
-        return AssignEnvironment(DefineSameAsFirst(result));
-    }
-    case kFloat32x4LessThan:
-    case kFloat32x4LessThanOrEqual:
-    case kFloat32x4Equal:
-    case kFloat32x4NotEqual:
-    case kFloat32x4GreaterThanOrEqual:
-    case kFloat32x4GreaterThan: {
-      LOperand* left = UseRegisterAtStart(instr->left());
-      LOperand* right = UseRegisterAtStart(instr->right());
-      LBinarySIMDOperation* result =
-          new (zone()) LBinarySIMDOperation(left, right, instr->op());
-      return DefineAsRegister(result);
-    }
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-const char* LTernarySIMDOperation::Mnemonic() const {
-  switch (op()) {
-#define SIMD_TERNARY_OPERATION_CASE_ITEM(module, function, name, p4, p5, p6, \
-                                         p7)                                 \
-  case k##name:                                                              \
-    return #module "-" #function;
-    SIMD_TERNARY_OPERATIONS(SIMD_TERNARY_OPERATION_CASE_ITEM)
-#undef SIMD_TERNARY_OPERATION_CASE_ITEM
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-LInstruction* LChunkBuilder::DoTernarySIMDOperation(
-    HTernarySIMDOperation* instr) {
-  LOperand* first = UseRegisterAtStart(instr->first());
-  LOperand* second = UseRegisterAtStart(instr->second());
-  LOperand* third = UseRegisterAtStart(instr->third());
-  LTernarySIMDOperation* result =
-      new (zone()) LTernarySIMDOperation(first, second, third, instr->op());
-  switch (instr->op()) {
-    case kFloat32x4Select:
-    case kInt32x4Select: {
-      return DefineAsRegister(result);
-    }
-    case kFloat32x4ReplaceLane:
-    case kInt32x4ReplaceLane: {
-      LOperand* second = UseOrConstant(instr->second());
-      LOperand* third = UseRegisterAtStart(instr->third());
-      LTernarySIMDOperation* result =
-          new (zone()) LTernarySIMDOperation(first, second, third, instr->op());
-      return AssignEnvironment(DefineSameAsFirst(result));
-    }
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-const char* LQuarternarySIMDOperation::Mnemonic() const {
-  switch (op()) {
-#define SIMD_QUARTERNARY_OPERATION_CASE_ITEM(module, function, name, p4, p5, \
-                                             p6, p7, p8)                     \
-  case k##name:                                                              \
-    return #module "-" #function;
-    SIMD_QUARTERNARY_OPERATIONS(SIMD_QUARTERNARY_OPERATION_CASE_ITEM)
-#undef SIMD_QUARTERNARY_OPERATION_CASE_ITEM
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-LInstruction* LChunkBuilder::DoQuarternarySIMDOperation(
-    HQuarternarySIMDOperation* instr) {
-  LOperand* x = UseRegisterAtStart(instr->x());
-  LOperand* y = UseRegisterAtStart(instr->y());
-  LOperand* z = UseRegisterAtStart(instr->z());
-  LOperand* w = UseRegisterAtStart(instr->w());
-  LQuarternarySIMDOperation* result =
-      new (zone()) LQuarternarySIMDOperation(x, y, z, w, instr->op());
-  return DefineAsRegister(result);
-}
 
 LInstruction* LChunkBuilder::DoCallNewArray(HCallNewArray* instr) {
   LOperand* context = UseFixed(instr->context(), rsi);
@@ -2071,11 +1817,6 @@ LInstruction* LChunkBuilder::DoChange(HChange* instr) {
       LInstruction* result = DefineAsRegister(new(zone()) LNumberUntagD(value));
       if (!val->representation().IsSmi()) result = AssignEnvironment(result);
       return result;
-    } else if (to.IsSIMD128()) {
-      LOperand* value = UseRegister(instr->value());
-      LOperand* temp = TempRegister();
-      LTaggedToSIMD128* res = new (zone()) LTaggedToSIMD128(value, temp, to);
-      return AssignEnvironment(DefineAsRegister(res));
     } else if (to.IsSmi()) {
       LOperand* value = UseRegister(val);
       if (val->type().IsSmi()) {
@@ -2151,19 +1892,6 @@ LInstruction* LChunkBuilder::DoChange(HChange* instr) {
         return DefineAsRegister(new(zone()) LInteger32ToDouble(value));
       }
     }
-  } else if (from.IsSIMD128()) {
-    DCHECK(to.IsTagged());
-    info()->MarkAsDeferredCalling();
-    LOperand* value = UseRegister(instr->value());
-    LOperand* temp = TempRegister();
-    LOperand* temp2 = TempRegister();
-    LOperand* temp3 = TempRegister();
-
-    // Make sure that temp and result_temp are different registers.
-    LUnallocated* result_temp = TempRegister();
-    LSIMD128ToTagged* result =
-        new (zone()) LSIMD128ToTagged(value, temp, temp2, temp3);
-    return AssignPointerMap(Define(result, result_temp));
   }
   UNREACHABLE();
   return NULL;
@@ -2851,59 +2579,6 @@ LInstruction* LChunkBuilder::DoLoadFieldByIndex(HLoadFieldByIndex* instr) {
   return AssignPointerMap(result);
 }
 
-const char* LQuinarySIMDOperation::Mnemonic() const {
-  switch (op()) {
-#define SIMD_QUINARY_OPERATION_CASE_ITEM(module, function, name, p4, p5, p6, \
-                                         p7, p8, p9)                         \
-  case k##name:                                                              \
-    return #module "-" #function;
-    SIMD_QUINARY_OPERATIONS(SIMD_QUINARY_OPERATION_CASE_ITEM)
-#undef SIMD_QUINARY_OPERATION_CASE_ITEM
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-LInstruction* LChunkBuilder::DoQuinarySIMDOperation(
-    HQuinarySIMDOperation* instr) {
-  LOperand* a0 = UseRegisterAtStart(instr->a0());
-  LOperand* a1 = UseOrConstant(instr->a1());
-  LOperand* a2 = UseOrConstant(instr->a2());
-  LOperand* a3 = UseOrConstant(instr->a3());
-  LOperand* a4 = UseOrConstant(instr->a4());
-  LQuinarySIMDOperation* result =
-      new (zone()) LQuinarySIMDOperation(a0, a1, a2, a3, a4, instr->op());
-  return AssignEnvironment(DefineSameAsFirst(result));
-}
-
-const char* LSenarySIMDOperation::Mnemonic() const {
-  switch (op()) {
-#define SIMD_SENARY_OPERATION_CASE_ITEM(module, function, name, p4, p5, p6, \
-                                        p7, p8, p9, p10)                    \
-  case k##name:                                                             \
-    return #module "-" #function;
-    SIMD_SENARY_OPERATIONS(SIMD_SENARY_OPERATION_CASE_ITEM)
-#undef SIMD_SENARY_OPERATION_CASE_ITEM
-    default:
-      UNREACHABLE();
-      return NULL;
-  }
-}
-
-LInstruction* LChunkBuilder::DoSenarySIMDOperation(
-    HSenarySIMDOperation* instr) {
-  LOperand* a0 = UseRegisterAtStart(instr->a0());
-  LOperand* a1 = UseRegisterAtStart(instr->a1());
-  LOperand* a2 = UseOrConstant(instr->a2());
-  LOperand* a3 = UseOrConstant(instr->a3());
-  LOperand* a4 = UseOrConstant(instr->a4());
-  LOperand* a5 = UseOrConstant(instr->a5());
-  LSenarySIMDOperation* result =
-      new (zone()) LSenarySIMDOperation(a0, a1, a2, a3, a4, a5, instr->op());
-  return AssignEnvironment(DefineSameAsFirst(result));
-}
-
 }  // namespace internal
 }  // namespace v8
 
diff --git a/src/crankshaft/x64/lithium-x64.h b/src/crankshaft/x64/lithium-x64.h
index 6d705838e3..623421cbfb 100644
--- a/src/crankshaft/x64/lithium-x64.h
+++ b/src/crankshaft/x64/lithium-x64.h
@@ -112,21 +112,12 @@ class LCodeGen;
   V(MaybeGrowElements)                       \
   V(ModByConstI)                             \
   V(ModByPowerOf2I)                          \
-  V(NullarySIMDOperation)                    \
-  V(UnarySIMDOperation)                      \
-  V(BinarySIMDOperation)                     \
-  V(TernarySIMDOperation)                    \
-  V(QuarternarySIMDOperation)                \
-  V(QuinarySIMDOperation)                    \
-  V(SenarySIMDOperation)                     \
   V(ModI)                                    \
   V(MulI)                                    \
   V(NumberTagD)                              \
-  V(SIMD128ToTagged)                         \
   V(NumberTagI)                              \
   V(NumberTagU)                              \
   V(NumberUntagD)                            \
-  V(TaggedToSIMD128)                         \
   V(OsrEntry)                                \
   V(Parameter)                               \
   V(Power)                                   \
@@ -969,204 +960,6 @@ class LMathPowHalf final : public LTemplateInstruction<1, 1, 0> {
   DECLARE_CONCRETE_INSTRUCTION(MathPowHalf, "math-pow-half")
 };
 
-class LNullarySIMDOperation final : public LTemplateInstruction<1, 0, 0> {
- public:
-  explicit LNullarySIMDOperation(BuiltinFunctionId op) : op_(op) {}
-
-  BuiltinFunctionId op() const { return op_; }
-
-  Opcode opcode() const override { return LInstruction::kNullarySIMDOperation; }
-  void CompileToNative(LCodeGen* generator) override;
-  const char* Mnemonic() const override;
-  static LNullarySIMDOperation* cast(LInstruction* instr) {
-    DCHECK(instr->IsNullarySIMDOperation());
-    return reinterpret_cast<LNullarySIMDOperation*>(instr);
-  }
-
-  DECLARE_HYDROGEN_ACCESSOR(NullarySIMDOperation)
-
- private:
-  BuiltinFunctionId op_;
-};
-
-class LUnarySIMDOperation final : public LTemplateInstruction<1, 1, 0> {
- public:
-  LUnarySIMDOperation(LOperand* value, BuiltinFunctionId op) : op_(op) {
-    inputs_[0] = value;
-  }
-
-  LOperand* value() { return inputs_[0]; }
-  BuiltinFunctionId op() const { return op_; }
-
-  Opcode opcode() const override { return LInstruction::kUnarySIMDOperation; }
-  void CompileToNative(LCodeGen* generator) override;
-  const char* Mnemonic() const override;
-  static LUnarySIMDOperation* cast(LInstruction* instr) {
-    DCHECK(instr->IsUnarySIMDOperation());
-    return reinterpret_cast<LUnarySIMDOperation*>(instr);
-  }
-
-  DECLARE_HYDROGEN_ACCESSOR(UnarySIMDOperation)
-
- private:
-  BuiltinFunctionId op_;
-};
-
-class LBinarySIMDOperation final : public LTemplateInstruction<1, 2, 0> {
- public:
-  LBinarySIMDOperation(LOperand* left, LOperand* right, BuiltinFunctionId op)
-      : op_(op) {
-    inputs_[0] = left;
-    inputs_[1] = right;
-  }
-
-  LOperand* left() { return inputs_[0]; }
-  LOperand* right() { return inputs_[1]; }
-  BuiltinFunctionId op() const { return op_; }
-
-  Opcode opcode() const override { return LInstruction::kBinarySIMDOperation; }
-  void CompileToNative(LCodeGen* generator) override;
-  const char* Mnemonic() const override;
-  static LBinarySIMDOperation* cast(LInstruction* instr) {
-    DCHECK(instr->IsBinarySIMDOperation());
-    return reinterpret_cast<LBinarySIMDOperation*>(instr);
-  }
-
-  DECLARE_HYDROGEN_ACCESSOR(BinarySIMDOperation)
-
- private:
-  BuiltinFunctionId op_;
-};
-
-class LTernarySIMDOperation final : public LTemplateInstruction<1, 3, 0> {
- public:
-  LTernarySIMDOperation(LOperand* first, LOperand* second, LOperand* third,
-                        BuiltinFunctionId op)
-      : op_(op) {
-    inputs_[0] = first;
-    inputs_[1] = second;
-    inputs_[2] = third;
-  }
-
-  LOperand* first() { return inputs_[0]; }
-  LOperand* second() { return inputs_[1]; }
-  LOperand* third() { return inputs_[2]; }
-  BuiltinFunctionId op() const { return op_; }
-
-  Opcode opcode() const override { return LInstruction::kTernarySIMDOperation; }
-  void CompileToNative(LCodeGen* generator) override;
-  const char* Mnemonic() const override;
-  static LTernarySIMDOperation* cast(LInstruction* instr) {
-    DCHECK(instr->IsTernarySIMDOperation());
-    return reinterpret_cast<LTernarySIMDOperation*>(instr);
-  }
-
-  DECLARE_HYDROGEN_ACCESSOR(TernarySIMDOperation)
-
- private:
-  BuiltinFunctionId op_;
-};
-
-class LQuarternarySIMDOperation final : public LTemplateInstruction<1, 4, 0> {
- public:
-  LQuarternarySIMDOperation(LOperand* x, LOperand* y, LOperand* z, LOperand* w,
-                            BuiltinFunctionId op)
-      : op_(op) {
-    inputs_[0] = x;
-    inputs_[1] = y;
-    inputs_[2] = z;
-    inputs_[3] = w;
-  }
-
-  LOperand* x() { return inputs_[0]; }
-  LOperand* y() { return inputs_[1]; }
-  LOperand* z() { return inputs_[2]; }
-  LOperand* w() { return inputs_[3]; }
-  BuiltinFunctionId op() const { return op_; }
-
-  Opcode opcode() const override {
-    return LInstruction::kQuarternarySIMDOperation;
-  }
-  void CompileToNative(LCodeGen* generator) override;
-  const char* Mnemonic() const override;
-  static LQuarternarySIMDOperation* cast(LInstruction* instr) {
-    DCHECK(instr->IsQuarternarySIMDOperation());
-    return reinterpret_cast<LQuarternarySIMDOperation*>(instr);
-  }
-
-  DECLARE_HYDROGEN_ACCESSOR(QuarternarySIMDOperation)
-
- private:
-  BuiltinFunctionId op_;
-};
-
-class LQuinarySIMDOperation final : public LTemplateInstruction<1, 5, 0> {
- public:
-  LQuinarySIMDOperation(LOperand* a0, LOperand* a1, LOperand* a2, LOperand* a3,
-                        LOperand* a4, BuiltinFunctionId op)
-      : op_(op) {
-    inputs_[0] = a0;
-    inputs_[1] = a1;
-    inputs_[2] = a2;
-    inputs_[3] = a3;
-    inputs_[4] = a4;
-  }
-
-  LOperand* a0() { return inputs_[0]; }
-  LOperand* a1() { return inputs_[1]; }
-  LOperand* a2() { return inputs_[2]; }
-  LOperand* a3() { return inputs_[3]; }
-  LOperand* a4() { return inputs_[4]; }
-  BuiltinFunctionId op() const { return op_; }
-
-  Opcode opcode() const override { return LInstruction::kQuinarySIMDOperation; }
-  void CompileToNative(LCodeGen* generator) override;
-  const char* Mnemonic() const override;
-  static LQuinarySIMDOperation* cast(LInstruction* instr) {
-    DCHECK(instr->IsQuinarySIMDOperation());
-    return reinterpret_cast<LQuinarySIMDOperation*>(instr);
-  }
-
-  DECLARE_HYDROGEN_ACCESSOR(QuinarySIMDOperation)
-
- private:
-  BuiltinFunctionId op_;
-};
-
-class LSenarySIMDOperation final : public LTemplateInstruction<1, 6, 0> {
- public:
-  LSenarySIMDOperation(LOperand* a0, LOperand* a1, LOperand* a2, LOperand* a3,
-                       LOperand* a4, LOperand* a5, BuiltinFunctionId op)
-      : op_(op) {
-    inputs_[0] = a0;
-    inputs_[1] = a1;
-    inputs_[2] = a2;
-    inputs_[3] = a3;
-    inputs_[4] = a4;
-    inputs_[5] = a5;
-  }
-
-  LOperand* a0() { return inputs_[0]; }
-  LOperand* a1() { return inputs_[1]; }
-  LOperand* a2() { return inputs_[2]; }
-  LOperand* a3() { return inputs_[3]; }
-  LOperand* a4() { return inputs_[4]; }
-  LOperand* a5() { return inputs_[5]; }
-  BuiltinFunctionId op() const { return op_; }
-
-  Opcode opcode() const override { return LInstruction::kSenarySIMDOperation; }
-  void CompileToNative(LCodeGen* generator) override;
-  const char* Mnemonic() const override;
-  static LSenarySIMDOperation* cast(LInstruction* instr) {
-    DCHECK(instr->IsSenarySIMDOperation());
-    return reinterpret_cast<LSenarySIMDOperation*>(instr);
-  }
-
-  DECLARE_HYDROGEN_ACCESSOR(SenarySIMDOperation)
-
- private:
-  BuiltinFunctionId op_;
-};
 
 class LCmpObjectEqAndBranch final : public LControlInstruction<2, 0> {
  public:
@@ -1741,13 +1534,6 @@ class LLoadRoot final : public LTemplateInstruction<1, 0, 0> {
   Heap::RootListIndex index() const { return hydrogen()->index(); }
 };
 
-inline static bool ExternalArrayOpRequiresPreScale(
-    Representation key_representation, ElementsKind kind) {
-  int shift_size = ElementsKindToShiftSize(kind);
-  return SmiValuesAre31Bits() && key_representation.IsSmi()
-             ? shift_size > static_cast<int>(maximal_scale_factor) + kSmiTagSize
-             : shift_size > static_cast<int>(maximal_scale_factor);
-}
 
 inline static bool ExternalArrayOpRequiresTemp(
     Representation key_representation,
@@ -1755,10 +1541,9 @@ inline static bool ExternalArrayOpRequiresTemp(
   // Operations that require the key to be divided by two to be converted into
   // an index cannot fold the scale operation into a load and need an extra
   // temp register to do the work.
-  return ExternalArrayOpRequiresPreScale(key_representation, elements_kind) ||
-         (SmiValuesAre31Bits() && key_representation.IsSmi() &&
-          (elements_kind == UINT8_ELEMENTS || elements_kind == INT8_ELEMENTS ||
-           elements_kind == UINT8_CLAMPED_ELEMENTS));
+  return SmiValuesAre31Bits() && key_representation.IsSmi() &&
+         (elements_kind == UINT8_ELEMENTS || elements_kind == INT8_ELEMENTS ||
+          elements_kind == UINT8_CLAMPED_ELEMENTS);
 }
 
 
@@ -2115,24 +1900,6 @@ class LNumberTagD final : public LTemplateInstruction<1, 1, 1> {
   DECLARE_HYDROGEN_ACCESSOR(Change)
 };
 
-class LSIMD128ToTagged final : public LTemplateInstruction<1, 1, 3> {
- public:
-  explicit LSIMD128ToTagged(LOperand* value, LOperand* temp, LOperand* temp2,
-                            LOperand* temp3) {
-    inputs_[0] = value;
-    temps_[0] = temp;
-    temps_[1] = temp2;
-    temps_[2] = temp3;
-  }
-
-  LOperand* value() { return inputs_[0]; }
-  LOperand* temp() { return temps_[0]; }
-  LOperand* temp2() { return temps_[1]; }
-  LOperand* temp3() { return temps_[2]; }
-
-  DECLARE_CONCRETE_INSTRUCTION(SIMD128ToTagged, "simd128-tag")
-  DECLARE_HYDROGEN_ACCESSOR(Change)
-};
 
 // Sometimes truncating conversion from a tagged value to an int32.
 class LDoubleToI final : public LTemplateInstruction<1, 1, 0> {
@@ -2206,25 +1973,6 @@ class LNumberUntagD final : public LTemplateInstruction<1, 1, 0> {
   DECLARE_HYDROGEN_ACCESSOR(Change);
 };
 
-class LTaggedToSIMD128 final : public LTemplateInstruction<1, 1, 1> {
- public:
-  explicit LTaggedToSIMD128(LOperand* value, LOperand* temp,
-                            Representation representation)
-      : representation_(representation) {
-    inputs_[0] = value;
-    temps_[0] = temp;
-  }
-
-  LOperand* value() { return inputs_[0]; }
-  LOperand* temp() { return temps_[0]; }
-  Representation representation() const { return representation_; }
-
-  DECLARE_CONCRETE_INSTRUCTION(TaggedToSIMD128, "simd128-untag")
-  DECLARE_HYDROGEN_ACCESSOR(Change);
-
- private:
-  Representation representation_;
-};
 
 class LSmiUntag final : public LTemplateInstruction<1, 1, 0> {
  public:
diff --git a/src/deoptimizer.cc b/src/deoptimizer.cc
index 2f6833457a..4cf41a9f27 100644
--- a/src/deoptimizer.cc
+++ b/src/deoptimizer.cc
@@ -2054,9 +2054,6 @@ void Deoptimizer::DoComputeCompiledStubFrame(TranslatedFrame* translated_frame,
   // Copy the double registers from the input into the output frame.
   CopyDoubleRegisters(output_frame);
 
-  // Copy the simd128 registers from the input into the output frame.
-  CopySIMD128Registers(output_frame);
-
   // Fill registers containing handler and number of parameters.
   SetPlatformCompiledStubRegisters(output_frame, &descriptor);
 
@@ -2466,10 +2463,6 @@ void Translation::StoreDoubleRegister(DoubleRegister reg) {
   buffer_->Add(reg.code(), zone());
 }
 
-void Translation::StoreSIMD128Register(SIMD128Register reg, Opcode opcode) {
-  buffer_->Add(opcode, zone());
-  buffer_->Add(reg.code(), zone());
-}
 
 void Translation::StoreStackSlot(int index) {
   buffer_->Add(STACK_SLOT, zone());
@@ -2504,10 +2497,6 @@ void Translation::StoreDoubleStackSlot(int index) {
   buffer_->Add(index, zone());
 }
 
-void Translation::StoreSIMD128StackSlot(int index, Opcode opcode) {
-  buffer_->Add(opcode, zone());
-  buffer_->Add(index, zone());
-}
 
 void Translation::StoreLiteral(int literal_id) {
   buffer_->Add(LITERAL, zone());
@@ -2544,18 +2533,12 @@ int Translation::NumberOfOperandsFor(Opcode opcode) {
     case BOOL_REGISTER:
     case FLOAT_REGISTER:
     case DOUBLE_REGISTER:
-    case FLOAT32x4_REGISTER:
-    case INT32x4_REGISTER:
-    case BOOL32x4_REGISTER:
     case STACK_SLOT:
     case INT32_STACK_SLOT:
     case UINT32_STACK_SLOT:
     case BOOL_STACK_SLOT:
     case FLOAT_STACK_SLOT:
     case DOUBLE_STACK_SLOT:
-    case FLOAT32x4_STACK_SLOT:
-    case INT32x4_STACK_SLOT:
-    case BOOL32x4_STACK_SLOT:
     case LITERAL:
     case COMPILED_STUB_FRAME:
     case TAIL_CALLER_FRAME:
@@ -2861,30 +2844,6 @@ TranslatedValue TranslatedValue::NewDouble(TranslatedState* container,
 }
 
 
-// static
-TranslatedValue TranslatedValue::NewFloat32x4(TranslatedState* container,
-                                              float32x4_value_t value) {
-  TranslatedValue slot(container, kFloat32x4);
-  slot.float32x4_value_ = value;
-  return slot;
-}
-
-// static
-TranslatedValue TranslatedValue::NewInt32x4(TranslatedState* container,
-                                            int32x4_value_t value) {
-  TranslatedValue slot(container, kInt32x4);
-  slot.int32x4_value_ = value;
-  return slot;
-}
-
-// static
-TranslatedValue TranslatedValue::NewBool32x4(TranslatedState* container,
-                                             bool32x4_value_t value) {
-  TranslatedValue slot(container, kBool32x4);
-  slot.bool32x4_value_ = value;
-  return slot;
-}
-
 // static
 TranslatedValue TranslatedValue::NewInt32(TranslatedState* container,
                                           int32_t value) {
@@ -2957,20 +2916,6 @@ double TranslatedValue::double_value() const {
   return double_value_;
 }
 
-float32x4_value_t TranslatedValue::float32x4_value() const {
-  DCHECK_EQ(kFloat32x4, kind());
-  return float32x4_value_;
-}
-
-int32x4_value_t TranslatedValue::int32x4_value() const {
-  DCHECK_EQ(kInt32x4, kind());
-  return int32x4_value_;
-}
-
-bool32x4_value_t TranslatedValue::bool32x4_value() const {
-  DCHECK_EQ(kBool32x4, kind());
-  return bool32x4_value_;
-}
 
 int TranslatedValue::object_length() const {
   DCHECK(kind() == kArgumentsObject || kind() == kCapturedObject);
@@ -3044,10 +2989,7 @@ Handle<Object> TranslatedValue::GetValue() {
     case TranslatedValue::kUInt32:
     case TranslatedValue::kBoolBit:
     case TranslatedValue::kFloat:
-    case TranslatedValue::kDouble:
-    case TranslatedValue::kFloat32x4:
-    case TranslatedValue::kInt32x4:
-    case TranslatedValue::kBool32x4: {
+    case TranslatedValue::kDouble: {
       MaterializeSimple();
       return value_.ToHandleChecked();
     }
@@ -3096,28 +3038,6 @@ void TranslatedValue::MaterializeSimple() {
       value_ = Handle<Object>(isolate()->factory()->NewNumber(double_value()));
       return;
 
-    case kFloat32x4:
-      value_ = Handle<Object>(
-          isolate()->factory()->NewFloat32x4(float32x4_value().storage));
-      return;
-    case kInt32x4:
-      value_ = Handle<Object>(
-          isolate()->factory()->NewInt32x4(int32x4_value().storage));
-      return;
-    case kBool32x4:
-      bool input[4];
-      for (int i = 0; i < 4; i++) {
-        switch (bool32x4_value().storage[i]) {
-          case 0:
-            input[i] = false;
-            break;
-          case -1:
-            input[i] = true;
-            break;
-        }
-      }
-      value_ = Handle<Object>(isolate()->factory()->NewBool32x4(input));
-      return;
     case kCapturedObject:
     case kDuplicatedObject:
     case kArgumentsObject:
@@ -3392,18 +3312,12 @@ TranslatedFrame TranslatedState::CreateNextTranslatedFrame(
     case Translation::BOOL_REGISTER:
     case Translation::FLOAT_REGISTER:
     case Translation::DOUBLE_REGISTER:
-    case Translation::FLOAT32x4_REGISTER:
-    case Translation::INT32x4_REGISTER:
-    case Translation::BOOL32x4_REGISTER:
     case Translation::STACK_SLOT:
     case Translation::INT32_STACK_SLOT:
     case Translation::UINT32_STACK_SLOT:
     case Translation::BOOL_STACK_SLOT:
     case Translation::FLOAT_STACK_SLOT:
     case Translation::DOUBLE_STACK_SLOT:
-    case Translation::FLOAT32x4_STACK_SLOT:
-    case Translation::INT32x4_STACK_SLOT:
-    case Translation::BOOL32x4_STACK_SLOT:
     case Translation::LITERAL:
       break;
   }
@@ -3553,58 +3467,6 @@ TranslatedValue TranslatedState::CreateNextTranslatedValue(
       return TranslatedValue::NewDouble(this, value);
     }
 
-    case Translation::FLOAT32x4_REGISTER:
-    case Translation::BOOL32x4_REGISTER:
-    case Translation::INT32x4_REGISTER: {
-      int input_reg = iterator->Next();
-      if (registers == nullptr) return TranslatedValue::NewInvalid(this);
-      simd128_value_t value = registers->GetSIMD128Register(input_reg);
-      if (trace_file != nullptr) {
-        if (opcode == Translation::FLOAT32x4_REGISTER) {
-          float32x4_value_t x4 = value.f4;
-          PrintF(trace_file, "float32x4(%e, %e, %e, %e) ; %s\n", x4.storage[0],
-                 x4.storage[1], x4.storage[2], x4.storage[3],
-#if V8_TARGET_ARCH_IA32 || V8_TARGET_ARCH_X64
-                 RegisterConfiguration::Crankshaft()->GetSimd128RegisterName(
-                     input_reg));
-#else
-                 "Target hasn't no method toString()");
-#endif
-        } else if (opcode == Translation::BOOL32x4_REGISTER) {
-          bool32x4_value_t x4 = value.b4;
-          PrintF(trace_file, "bool32x4(%u, %u, %u, %u) ; %s\n", x4.storage[0],
-                 x4.storage[1], x4.storage[2], x4.storage[3],
-#if V8_TARGET_ARCH_IA32 || V8_TARGET_ARCH_X64
-                 RegisterConfiguration::Crankshaft()->GetSimd128RegisterName(
-                     input_reg));
-#else
-                 "Target hasn't no method toString()");
-#endif
-        } else {
-          DCHECK(opcode == Translation::INT32x4_REGISTER);
-          int32x4_value_t x4 = value.i4;
-          PrintF(trace_file, "int32x4(%u, %u, %u, %u) ; %s\n", x4.storage[0],
-                 x4.storage[1], x4.storage[2], x4.storage[3],
-#if V8_TARGET_ARCH_IA32 || V8_TARGET_ARCH_X64
-                 RegisterConfiguration::Crankshaft()->GetSimd128RegisterName(
-                     input_reg));
-#else
-                 "Target hasn't no method toString()");
-#endif
-        }
-      }
-      if (opcode == Translation::FLOAT32x4_REGISTER) {
-        float32x4_value_t x4 = value.f4;
-        return TranslatedValue::NewFloat32x4(this, x4);
-      } else if (opcode == Translation::BOOL32x4_REGISTER) {
-        bool32x4_value_t x4 = value.b4;
-        return TranslatedValue::NewBool32x4(this, x4);
-      } else {
-        int32x4_value_t x4 = value.i4;
-        return TranslatedValue::NewInt32x4(this, x4);
-      }
-    }
-
     case Translation::STACK_SLOT: {
       int slot_offset =
           OptimizedFrame::StackSlotOffsetRelativeToFp(iterator->Next());
@@ -3673,43 +3535,6 @@ TranslatedValue TranslatedState::CreateNextTranslatedValue(
       return TranslatedValue::NewDouble(this, value);
     }
 
-    case Translation::FLOAT32x4_STACK_SLOT:
-    case Translation::BOOL32x4_STACK_SLOT:
-    case Translation::INT32x4_STACK_SLOT: {
-      int slot_offset =
-          OptimizedFrame::StackSlotOffsetRelativeToFp(iterator->Next());
-      simd128_value_t value = read_simd128_value(fp, slot_offset);
-      if (trace_file != nullptr) {
-        if (opcode == Translation::FLOAT32x4_STACK_SLOT) {
-          float32x4_value_t x4 = value.f4;
-          PrintF(trace_file, "float32x4(%e, %e, %e, %e) ; [sp + %d]\n",
-                 x4.storage[0], x4.storage[1], x4.storage[2], x4.storage[3],
-                 slot_offset);
-        } else if (opcode == Translation::BOOL32x4_STACK_SLOT) {
-          bool32x4_value_t x4 = value.b4;
-          PrintF(trace_file, "bool32x4(%u, %u, %u, %u) ; [sp + %d]\n",
-                 x4.storage[0], x4.storage[1], x4.storage[2], x4.storage[3],
-                 slot_offset);
-        } else {
-          DCHECK(opcode == Translation::INT32x4_STACK_SLOT);
-          int32x4_value_t x4 = value.i4;
-          PrintF(trace_file, "int32x4(%u, %u, %u, %u) ; [sp + %d]\n",
-                 x4.storage[0], x4.storage[1], x4.storage[2], x4.storage[3],
-                 slot_offset);
-        }
-      }
-      if (opcode == Translation::FLOAT32x4_STACK_SLOT) {
-        float32x4_value_t x4 = value.f4;
-        return TranslatedValue::NewFloat32x4(this, x4);
-      } else if (opcode == Translation::BOOL32x4_STACK_SLOT) {
-        bool32x4_value_t x4 = value.b4;
-        return TranslatedValue::NewBool32x4(this, x4);
-      } else {
-        int32x4_value_t x4 = value.i4;
-        return TranslatedValue::NewInt32x4(this, x4);
-      }
-    }
-
     case Translation::LITERAL: {
       int literal_index = iterator->Next();
       Object* value = literal_array->get(literal_index);
@@ -3847,10 +3672,7 @@ Handle<Object> TranslatedState::MaterializeAt(int frame_index,
     case TranslatedValue::kUInt32:
     case TranslatedValue::kBoolBit:
     case TranslatedValue::kFloat:
-    case TranslatedValue::kDouble:
-    case TranslatedValue::kFloat32x4:
-    case TranslatedValue::kBool32x4:
-    case TranslatedValue::kInt32x4: {
+    case TranslatedValue::kDouble: {
       slot->MaterializeSimple();
       Handle<Object> value = slot->GetValue();
       if (value->IsMutableHeapNumber()) {
diff --git a/src/deoptimizer.h b/src/deoptimizer.h
index 57efa9b5c9..db204066ca 100644
--- a/src/deoptimizer.h
+++ b/src/deoptimizer.h
@@ -18,11 +18,6 @@ class DeoptimizedFrameInfo;
 class TranslatedState;
 class RegisterValues;
 
-static inline simd128_value_t read_simd128_value(Address p, int slot_offset) {
-  Address address = p + slot_offset;
-  return *reinterpret_cast<simd128_value_t*>(address);
-}
-
 class TranslatedValue {
  public:
   // Allocation-less getter of the value.
@@ -46,9 +41,6 @@ class TranslatedValue {
     kBoolBit,
     kFloat,
     kDouble,
-    kFloat32x4,
-    kInt32x4,
-    kBool32x4,
     kCapturedObject,    // Object captured by the escape analysis.
                         // The number of nested objects can be obtained
                         // with the DeferredObjectLength() method
@@ -75,12 +67,6 @@ class TranslatedValue {
   static TranslatedValue NewInt32(TranslatedState* container, int32_t value);
   static TranslatedValue NewUInt32(TranslatedState* container, uint32_t value);
   static TranslatedValue NewBool(TranslatedState* container, uint32_t value);
-  static TranslatedValue NewFloat32x4(TranslatedState* container,
-                                      float32x4_value_t value);
-  static TranslatedValue NewInt32x4(TranslatedState* container,
-                                    int32x4_value_t value);
-  static TranslatedValue NewBool32x4(TranslatedState* container,
-                                     bool32x4_value_t value);
   static TranslatedValue NewTagged(TranslatedState* container, Object* literal);
   static TranslatedValue NewInvalid(TranslatedState* container);
 
@@ -113,12 +99,6 @@ class TranslatedValue {
     float float_value_;
     // kind is kDouble
     double double_value_;
-    // Kind is kFloat32x4
-    float32x4_value_t float32x4_value_;
-    // Kind is kBool32x4
-    bool32x4_value_t bool32x4_value_;
-    // Kind is kInt32x4
-    int32x4_value_t int32x4_value_;
     // kind is kDuplicatedObject or kArgumentsObject or kCapturedObject.
     MaterializedObjectInfo materialization_info_;
   };
@@ -129,9 +109,6 @@ class TranslatedValue {
   uint32_t uint32_value() const;
   float float_value() const;
   double double_value() const;
-  float32x4_value_t float32x4_value() const;
-  int32x4_value_t int32x4_value() const;
-  bool32x4_value_t bool32x4_value() const;
   int object_length() const;
   int object_index() const;
 };
@@ -389,7 +366,6 @@ class OptimizedFunctionVisitor BASE_EMBEDDED {
     "non-strict elements in KeyedLoadGenericStub")                             \
   V(kNotADateObject, "not a date object")                                      \
   V(kNotAHeapNumber, "not a heap number")                                      \
-  V(kNotASIMD128, "not a simd128 value")                                       \
   V(kNotAHeapNumberUndefinedBoolean, "not a heap number/undefined/true/false") \
   V(kNotAHeapNumberUndefined, "not a heap number/undefined")                   \
   V(kNotAJavaScriptObject, "not a JavaScript object")                          \
@@ -702,10 +678,6 @@ class Deoptimizer : public Malloced {
   // from the input frame's double registers.
   void CopyDoubleRegisters(FrameDescription* output_frame);
 
-  // Fill the given output frame's simd128 registers with the original values
-  // from the input frame's simd128 registers.
-  void CopySIMD128Registers(FrameDescription* output_frame);
-
   Isolate* isolate_;
   JSFunction* function_;
   Code* compiled_code_;
@@ -776,9 +748,10 @@ class RegisterValues {
     return float_registers_[n];
   }
 
-  double GetDoubleRegister(unsigned n) const;
-
-  simd128_value_t GetSIMD128Register(unsigned n) const;
+  double GetDoubleRegister(unsigned n) const {
+    DCHECK(n < arraysize(double_registers_));
+    return double_registers_[n];
+  }
 
   void SetRegister(unsigned n, intptr_t value) {
     DCHECK(n < arraysize(registers_));
@@ -790,16 +763,14 @@ class RegisterValues {
     float_registers_[n] = value;
   }
 
-  void SetDoubleRegister(unsigned n, double value);
-
-  void SetSIMD128Register(unsigned n, simd128_value_t value);
+  void SetDoubleRegister(unsigned n, double value) {
+    DCHECK(n < arraysize(double_registers_));
+    double_registers_[n] = value;
+  }
 
   intptr_t registers_[Register::kNumRegisters];
   float float_registers_[FloatRegister::kMaxNumRegisters];
   double double_registers_[DoubleRegister::kMaxNumRegisters];
-#if V8_TARGET_ARCH_IA32 || V8_TARGET_ARCH_X64 || V8_TARGET_ARCH_ARM
-  simd128_value_t simd128_registers_[SIMD128Register::kMaxNumRegisters];
-#endif
 };
 
 
@@ -858,10 +829,6 @@ class FrameDescription {
     return register_values_.GetDoubleRegister(n);
   }
 
-  simd128_value_t GetSIMD128Register(unsigned n) const {
-    return register_values_.GetSIMD128Register(n);
-  }
-
   void SetRegister(unsigned n, intptr_t value) {
     register_values_.SetRegister(n, value);
   }
@@ -870,10 +837,6 @@ class FrameDescription {
     register_values_.SetDoubleRegister(n, value);
   }
 
-  void SetSIMD128Register(unsigned n, simd128_value_t value) {
-    register_values_.SetSIMD128Register(n, value);
-  }
-
   intptr_t GetTop() const { return top_; }
   void SetTop(intptr_t top) { top_ = top; }
 
@@ -906,9 +869,9 @@ class FrameDescription {
     return OFFSET_OF(FrameDescription, register_values_.registers_);
   }
 
-  static int double_registers_offset();
-
-  static int simd128_registers_offset();
+  static int double_registers_offset() {
+    return OFFSET_OF(FrameDescription, register_values_.double_registers_);
+  }
 
   static int frame_size_offset() {
     return offsetof(FrameDescription, frame_size_);
@@ -1032,18 +995,12 @@ class TranslationIterator BASE_EMBEDDED {
   V(BOOL_REGISTER)                 \
   V(FLOAT_REGISTER)                \
   V(DOUBLE_REGISTER)               \
-  V(FLOAT32x4_REGISTER)            \
-  V(BOOL32x4_REGISTER)             \
-  V(INT32x4_REGISTER)              \
   V(STACK_SLOT)                    \
   V(INT32_STACK_SLOT)              \
   V(UINT32_STACK_SLOT)             \
   V(BOOL_STACK_SLOT)               \
   V(FLOAT_STACK_SLOT)              \
   V(DOUBLE_STACK_SLOT)             \
-  V(FLOAT32x4_STACK_SLOT)          \
-  V(BOOL32x4_STACK_SLOT)           \
-  V(INT32x4_STACK_SLOT)            \
   V(LITERAL)
 
 class Translation BASE_EMBEDDED {
@@ -1086,14 +1043,12 @@ class Translation BASE_EMBEDDED {
   void StoreBoolRegister(Register reg);
   void StoreFloatRegister(FloatRegister reg);
   void StoreDoubleRegister(DoubleRegister reg);
-  void StoreSIMD128Register(SIMD128Register reg, Opcode opcode);
   void StoreStackSlot(int index);
   void StoreInt32StackSlot(int index);
   void StoreUint32StackSlot(int index);
   void StoreBoolStackSlot(int index);
   void StoreFloatStackSlot(int index);
   void StoreDoubleStackSlot(int index);
-  void StoreSIMD128StackSlot(int index, Opcode opcode);
   void StoreLiteral(int literal_id);
   void StoreArgumentsObject(bool args_known, int args_index, int args_length);
   void StoreJSFrameFunction();
diff --git a/src/elements-kind.h b/src/elements-kind.h
index 321ec376a3..3ebc9ad287 100644
--- a/src/elements-kind.h
+++ b/src/elements-kind.h
@@ -137,7 +137,6 @@ inline bool IsDoubleOrFloatElementsKind(ElementsKind kind) {
   return IsFastDoubleElementsKind(kind) || IsFixedFloatElementsKind(kind);
 }
 
-inline bool IsSIMD128ElementsKind(ElementsKind kind) { return false; }
 
 inline bool IsFastSmiOrObjectElementsKind(ElementsKind kind) {
   return kind == FAST_SMI_ELEMENTS ||
diff --git a/src/factory.cc b/src/factory.cc
index bd4656ef8f..96091573bb 100644
--- a/src/factory.cc
+++ b/src/factory.cc
@@ -1137,16 +1137,6 @@ Handle<HeapNumber> Factory::NewHeapNumber(double value,
 }
 
 
-#define SIMD128_NEW_DEF(TYPE, Type, type, lane_count, lane_type)               \
-  Handle<Type> Factory::New##Type(lane_type lanes[lane_count],                 \
-                                  PretenureFlag pretenure) {                   \
-    CALL_HEAP_FUNCTION(                                                        \
-        isolate(), isolate()->heap()->Allocate##Type(lanes, pretenure), Type); \
-  }
-SIMD128_TYPES(SIMD128_NEW_DEF)
-#undef SIMD128_NEW_DEF
-
-
 Handle<Object> Factory::NewError(Handle<JSFunction> constructor,
                                  MessageTemplate::Template template_index,
                                  Handle<Object> arg0, Handle<Object> arg1,
diff --git a/src/factory.h b/src/factory.h
index f8b91a913d..eb60c940a9 100644
--- a/src/factory.h
+++ b/src/factory.h
@@ -376,12 +376,6 @@ class Factory final {
                                    MutableMode mode = IMMUTABLE,
                                    PretenureFlag pretenure = NOT_TENURED);
 
-#define SIMD128_NEW_DECL(TYPE, Type, type, lane_count, lane_type) \
-  Handle<Type> New##Type(lane_type lanes[lane_count],             \
-                         PretenureFlag pretenure = NOT_TENURED);
-  SIMD128_TYPES(SIMD128_NEW_DECL)
-#undef SIMD128_NEW_DECL
-
   // These objects are used by the api to create env-independent data
   // structures in the heap.
   inline Handle<JSObject> NewNeanderObject() {
diff --git a/src/flag-definitions.h b/src/flag-definitions.h
index e3dcf2910e..7bc46be88b 100644
--- a/src/flag-definitions.h
+++ b/src/flag-definitions.h
@@ -201,7 +201,6 @@ DEFINE_IMPLICATION(es_staging, move_object_start)
   V(harmony_array_prototype_values, "harmony Array.prototype.values")   \
   V(harmony_function_sent, "harmony function.sent")                     \
   V(harmony_sharedarraybuffer, "harmony sharedarraybuffer")             \
-  V(harmony_simd, "harmony simd")                                       \
   V(harmony_explicit_tailcalls, "harmony explicit tail calls")          \
   V(harmony_do_expressions, "harmony do-expressions")                   \
   V(harmony_restrictive_generators,                                     \
@@ -498,7 +497,6 @@ DEFINE_BOOL(wasm_loop_assignment_analysis, true,
             "perform loop assignment analysis for WASM")
 
 DEFINE_BOOL(validate_asm, false, "validate asm.js modules before compiling")
-DEFINE_BOOL(enable_simd_asmjs, false, "enable SIMD.js in asm.js stdlib")
 
 DEFINE_BOOL(dump_wasm_module, false, "dump WASM module bytes")
 DEFINE_STRING(dump_wasm_module_path, NULL, "directory to dump wasm modules to")
diff --git a/src/full-codegen/arm/full-codegen-arm.cc b/src/full-codegen/arm/full-codegen-arm.cc
index 73e4750295..05f3a192c8 100644
--- a/src/full-codegen/arm/full-codegen-arm.cc
+++ b/src/full-codegen/arm/full-codegen-arm.cc
@@ -3502,16 +3502,6 @@ void FullCodeGenerator::EmitLiteralCompareTypeof(Expression* expr,
     __ ldrb(r1, FieldMemOperand(r0, Map::kBitFieldOffset));
     __ tst(r1, Operand((1 << Map::kIsCallable) | (1 << Map::kIsUndetectable)));
     Split(eq, if_true, if_false, fall_through);
-// clang-format off
-#define SIMD128_TYPE(TYPE, Type, type, lane_count, lane_type)   \
-  } else if (String::Equals(check, factory->type##_string())) { \
-    __ JumpIfSmi(r0, if_false);                                 \
-    __ ldr(r0, FieldMemOperand(r0, HeapObject::kMapOffset));    \
-    __ CompareRoot(r0, Heap::k##Type##MapRootIndex);            \
-    Split(eq, if_true, if_false, fall_through);
-  SIMD128_TYPES(SIMD128_TYPE)
-#undef SIMD128_TYPE
-    // clang-format on
   } else {
     if (if_false != fall_through) __ jmp(if_false);
   }
diff --git a/src/globals.h b/src/globals.h
index 186c6e0a74..a31f2374bd 100644
--- a/src/globals.h
+++ b/src/globals.h
@@ -98,22 +98,6 @@ typedef byte* Address;
 // -----------------------------------------------------------------------------
 // Constants
 
-struct float32x4_value_t {
-  float storage[4];
-};
-struct int32x4_value_t {
-  int32_t storage[4];
-};
-struct bool32x4_value_t {
-  int32_t storage[4];
-};
-union simd128_value_t {
-  double d[2];
-  float32x4_value_t f4;
-  int32x4_value_t i4;
-  bool32x4_value_t b4;
-};
-
 const int KB = 1024;
 const int MB = KB * KB;
 const int GB = KB * KB * KB;
@@ -131,20 +115,15 @@ const int kMinUInt16 = 0;
 const uint32_t kMaxUInt32 = 0xFFFFFFFFu;
 const int kMinUInt32 = 0;
 
-const int kCharSize = sizeof(char);                    // NOLINT
-const int kShortSize = sizeof(short);                  // NOLINT
-const int kIntSize = sizeof(int);                      // NOLINT
-const int kInt32Size = sizeof(int32_t);                // NOLINT
-const int kBool32Size = sizeof(int32_t);               // NOLINT
-const int kInt64Size = sizeof(int64_t);                // NOLINT
-const int kDoubleSize = sizeof(double);                // NOLINT
-const int kFloatSize = sizeof(float);                  // NOLINT
-const int kFloat32x4Size = sizeof(float32x4_value_t);  // NOLINT
-const int kBool32x4Size = sizeof(bool32x4_value_t);    // NOLINT
-const int kInt32x4Size = sizeof(int32x4_value_t);      // NOLINT
-const int kSIMD128Size = sizeof(simd128_value_t);      // NOLINT
-const int kIntptrSize = sizeof(intptr_t);              // NOLINT
-const int kPointerSize = sizeof(void*);                // NOLINT
+const int kCharSize      = sizeof(char);      // NOLINT
+const int kShortSize     = sizeof(short);     // NOLINT
+const int kIntSize       = sizeof(int);       // NOLINT
+const int kInt32Size     = sizeof(int32_t);   // NOLINT
+const int kInt64Size     = sizeof(int64_t);   // NOLINT
+const int kFloatSize     = sizeof(float);     // NOLINT
+const int kDoubleSize    = sizeof(double);    // NOLINT
+const int kIntptrSize    = sizeof(intptr_t);  // NOLINT
+const int kPointerSize   = sizeof(void*);     // NOLINT
 #if V8_TARGET_ARCH_X64 && V8_TARGET_ARCH_32_BIT
 const int kRegisterSize  = kPointerSize + kPointerSize;
 #else
diff --git a/src/heap/heap.cc b/src/heap/heap.cc
index 2bb74c0b55..373703b241 100644
--- a/src/heap/heap.cc
+++ b/src/heap/heap.cc
@@ -1992,8 +1992,6 @@ int Heap::GetMaximumFillToAlign(AllocationAlignment alignment) {
     case kDoubleAligned:
     case kDoubleUnaligned:
       return kDoubleSize - kPointerSize;
-    case kSimd128Unaligned:
-      return kSimd128Size - kPointerSize;
     default:
       UNREACHABLE();
   }
@@ -2007,10 +2005,6 @@ int Heap::GetFillToAlign(Address address, AllocationAlignment alignment) {
     return kPointerSize;
   if (alignment == kDoubleUnaligned && (offset & kDoubleAlignmentMask) == 0)
     return kDoubleSize - kPointerSize;  // No fill if double is always aligned.
-  if (alignment == kSimd128Unaligned) {
-    return (kSimd128Size - (static_cast<int>(offset) + kPointerSize)) &
-           kSimd128AlignmentMask;
-  }
   return 0;
 }
 
@@ -2304,11 +2298,6 @@ bool Heap::CreateInitialMaps() {
                  mutable_heap_number)
     ALLOCATE_PRIMITIVE_MAP(SYMBOL_TYPE, Symbol::kSize, symbol,
                            Context::SYMBOL_FUNCTION_INDEX)
-#define ALLOCATE_SIMD128_MAP(TYPE, Type, type, lane_count, lane_type) \
-  ALLOCATE_PRIMITIVE_MAP(SIMD128_VALUE_TYPE, Type::kSize, type,       \
-                         Context::TYPE##_FUNCTION_INDEX)
-    SIMD128_TYPES(ALLOCATE_SIMD128_MAP)
-#undef ALLOCATE_SIMD128_MAP
     ALLOCATE_MAP(FOREIGN_TYPE, Foreign::kSize, foreign)
 
     ALLOCATE_PRIMITIVE_MAP(ODDBALL_TYPE, Oddball::kSize, boolean,
@@ -2463,31 +2452,6 @@ AllocationResult Heap::AllocateHeapNumber(double value, MutableMode mode,
   return result;
 }
 
-#define SIMD_ALLOCATE_DEFINITION(TYPE, Type, type, lane_count, lane_type) \
-  AllocationResult Heap::Allocate##Type(lane_type lanes[lane_count],      \
-                                        PretenureFlag pretenure) {        \
-    int size = Type::kSize;                                               \
-    STATIC_ASSERT(Type::kSize <= Page::kMaxRegularHeapObjectSize);        \
-                                                                          \
-    AllocationSpace space = SelectSpace(pretenure);                       \
-                                                                          \
-    HeapObject* result = nullptr;                                         \
-    {                                                                     \
-      AllocationResult allocation =                                       \
-          AllocateRaw(size, space, kSimd128Unaligned);                    \
-      if (!allocation.To(&result)) return allocation;                     \
-    }                                                                     \
-                                                                          \
-    result->set_map_no_write_barrier(type##_map());                       \
-    Type* instance = Type::cast(result);                                  \
-    for (int i = 0; i < lane_count; i++) {                                \
-      instance->set_lane(i, lanes[i]);                                    \
-    }                                                                     \
-    return result;                                                        \
-  }
-SIMD128_TYPES(SIMD_ALLOCATE_DEFINITION)
-#undef SIMD_ALLOCATE_DEFINITION
-
 
 AllocationResult Heap::AllocateCell(Object* value) {
   int size = Cell::kSize;
diff --git a/src/heap/heap.h b/src/heap/heap.h
index 46f4e3885d..ed6c7b6da8 100644
--- a/src/heap/heap.h
+++ b/src/heap/heap.h
@@ -130,16 +130,6 @@ using v8::MemoryPressureLevel;
   V(Map, fixed_float32_array_map, FixedFloat32ArrayMap)                        \
   V(Map, fixed_float64_array_map, FixedFloat64ArrayMap)                        \
   V(Map, fixed_uint8_clamped_array_map, FixedUint8ClampedArrayMap)             \
-  V(Map, float32x4_map, Float32x4Map)                                          \
-  V(Map, int32x4_map, Int32x4Map)                                              \
-  V(Map, uint32x4_map, Uint32x4Map)                                            \
-  V(Map, bool32x4_map, Bool32x4Map)                                            \
-  V(Map, int16x8_map, Int16x8Map)                                              \
-  V(Map, uint16x8_map, Uint16x8Map)                                            \
-  V(Map, bool16x8_map, Bool16x8Map)                                            \
-  V(Map, int8x16_map, Int8x16Map)                                              \
-  V(Map, uint8x16_map, Uint8x16Map)                                            \
-  V(Map, bool8x16_map, Bool8x16Map)                                            \
   /* Canonical empty values */                                                 \
   V(ByteArray, empty_byte_array, EmptyByteArray)                               \
   V(FixedTypedArrayBase, empty_fixed_uint8_array, EmptyFixedUint8Array)        \
@@ -256,16 +246,6 @@ using v8::MemoryPressureLevel;
   V(MetaMap)                            \
   V(HeapNumberMap)                      \
   V(MutableHeapNumberMap)               \
-  V(Float32x4Map)                       \
-  V(Int32x4Map)                         \
-  V(Uint32x4Map)                        \
-  V(Bool32x4Map)                        \
-  V(Int16x8Map)                         \
-  V(Uint16x8Map)                        \
-  V(Bool16x8Map)                        \
-  V(Int8x16Map)                         \
-  V(Uint8x16Map)                        \
-  V(Bool8x16Map)                        \
   V(NativeContextMap)                   \
   V(FixedArrayMap)                      \
   V(CodeMap)                            \
@@ -1838,13 +1818,6 @@ class Heap {
   AllocateHeapNumber(double value, MutableMode mode = IMMUTABLE,
                      PretenureFlag pretenure = NOT_TENURED);
 
-// Allocates SIMD values from the given lane values.
-#define SIMD_ALLOCATE_DECLARATION(TYPE, Type, type, lane_count, lane_type) \
-  AllocationResult Allocate##Type(lane_type lanes[lane_count],             \
-                                  PretenureFlag pretenure = NOT_TENURED);
-  SIMD128_TYPES(SIMD_ALLOCATE_DECLARATION)
-#undef SIMD_ALLOCATE_DECLARATION
-
   // Allocates a byte array of the specified length
   MUST_USE_RESULT AllocationResult
   AllocateByteArray(int length, PretenureFlag pretenure = NOT_TENURED);
diff --git a/src/heap/objects-visiting.cc b/src/heap/objects-visiting.cc
index 83e2e1c820..6cd8e5c840 100644
--- a/src/heap/objects-visiting.cc
+++ b/src/heap/objects-visiting.cc
@@ -138,7 +138,6 @@ StaticVisitorBase::VisitorId StaticVisitorBase::GetVisitorId(
     case FOREIGN_TYPE:
     case HEAP_NUMBER_TYPE:
     case MUTABLE_HEAP_NUMBER_TYPE:
-    case SIMD128_VALUE_TYPE:
       return GetVisitorIdForSize(kVisitDataObject, kVisitDataObjectGeneric,
                                  instance_size, has_unboxed_fields);
 
diff --git a/src/ia32/assembler-ia32-inl.h b/src/ia32/assembler-ia32-inl.h
index 76121610dd..2120a90e0c 100644
--- a/src/ia32/assembler-ia32-inl.h
+++ b/src/ia32/assembler-ia32-inl.h
@@ -46,7 +46,7 @@ namespace v8 {
 namespace internal {
 
 bool CpuFeatures::SupportsCrankshaft() { return true; }
-bool CpuFeatures::SupportsSIMD128InCrankshaft() { return true; }
+
 
 static const byte kCallOpcode = 0xE8;
 static const int kNoCodeAgeSequenceLength = 5;
diff --git a/src/ia32/assembler-ia32.cc b/src/ia32/assembler-ia32.cc
index 295cc19e05..925ae48c5e 100644
--- a/src/ia32/assembler-ia32.cc
+++ b/src/ia32/assembler-ia32.cc
@@ -270,50 +270,6 @@ Operand::Operand(Register index,
   set_dispr(disp, rmode);
 }
 
-Operand::Operand(const Operand& operand, int32_t offset) {
-  DCHECK(operand.len_ >= 1);
-  // Operand encodes REX ModR/M [SIB] [Disp].
-  byte modrm = operand.buf_[0];
-  DCHECK(modrm < 0xC0);  // Disallow mode 3 (register target).
-  bool has_sib = ((modrm & 0x07) == 0x04);
-  byte mode = modrm & 0xC0;
-  int disp_offset = has_sib ? 2 : 1;
-  int base_reg = (has_sib ? operand.buf_[1] : modrm) & 0x07;
-  // Mode 0 with rbp/r13 as ModR/M or SIB base register always has a 32-bit
-  // displacement.
-  bool is_baseless = (mode == 0) && (base_reg == 0x05);  // No base or RIP base.
-  int32_t disp_value = 0;
-  if (mode == 0x80 || is_baseless) {
-    // Mode 2 or mode 0 with rbp/r13 as base: Word displacement.
-    disp_value = *bit_cast<const int32_t*>(&operand.buf_[disp_offset]);
-  } else if (mode == 0x40) {
-    // Mode 1: Byte displacement.
-    disp_value = static_cast<signed char>(operand.buf_[disp_offset]);
-  }
-
-  // Write new operand with same registers, but with modified displacement.
-  DCHECK(offset >= 0 ? disp_value + offset >= disp_value
-                     : disp_value + offset < disp_value);  // No overflow.
-  disp_value += offset;
-  if (!is_int8(disp_value) || is_baseless) {
-    // Need 32 bits of displacement, mode 2 or mode 1 with register rbp/r13.
-    buf_[0] = (modrm & 0x3f) | (is_baseless ? 0x00 : 0x80);
-    len_ = disp_offset + 4;
-    Memory::int32_at(&buf_[disp_offset]) = disp_value;
-  } else if (disp_value != 0 || (base_reg == 0x05)) {
-    // Need 8 bits of displacement.
-    buf_[0] = (modrm & 0x3f) | 0x40;  // Mode 1.
-    len_ = disp_offset + 1;
-    buf_[disp_offset] = static_cast<byte>(disp_value);
-  } else {
-    // Need no displacement.
-    buf_[0] = (modrm & 0x3f);  // Mode 0.
-    len_ = disp_offset;
-  }
-  if (has_sib) {
-    buf_[1] = operand.buf_[1];
-  }
-}
 
 bool Operand::is_reg(Register reg) const {
   return ((buf_[0] & 0xF8) == 0xC0)  // addressing mode is register only.
@@ -2249,13 +2205,6 @@ void Assembler::xorpd(XMMRegister dst, XMMRegister src) {
   emit_sse_operand(dst, src);
 }
 
-void Assembler::xorpd(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x66);
-  EMIT(0x0F);
-  EMIT(0x57);
-  emit_sse_operand(dst, src);
-}
 
 void Assembler::andps(XMMRegister dst, const Operand& src) {
   EnsureSpace ensure_space(this);
@@ -2312,37 +2261,6 @@ void Assembler::divps(XMMRegister dst, const Operand& src) {
   emit_sse_operand(dst, src);
 }
 
-void Assembler::addpd(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x66);
-  EMIT(0x0F);
-  EMIT(0x58);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::subpd(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x66);
-  EMIT(0x0F);
-  EMIT(0x5C);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::mulpd(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x66);
-  EMIT(0x0F);
-  EMIT(0x59);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::divpd(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x66);
-  EMIT(0x0F);
-  EMIT(0x5E);
-  emit_sse_operand(dst, src);
-}
 
 void Assembler::sqrtsd(XMMRegister dst, const Operand& src) {
   EnsureSpace ensure_space(this);
@@ -2361,13 +2279,6 @@ void Assembler::andpd(XMMRegister dst, XMMRegister src) {
   emit_sse_operand(dst, src);
 }
 
-void Assembler::andpd(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x66);
-  EMIT(0x0F);
-  EMIT(0x54);
-  emit_sse_operand(dst, src);
-}
 
 void Assembler::orpd(XMMRegister dst, XMMRegister src) {
   EnsureSpace ensure_space(this);
@@ -2474,13 +2385,6 @@ void Assembler::minsd(XMMRegister dst, const Operand& src) {
   emit_sse_operand(dst, src);
 }
 
-void Assembler::pcmpgtd(XMMRegister dst, XMMRegister src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x66);
-  EMIT(0x0F);
-  EMIT(0x66);
-  emit_sse_operand(dst, src);
-}
 
 void Assembler::cmpltsd(XMMRegister dst, XMMRegister src) {
   EnsureSpace ensure_space(this);
@@ -2499,33 +2403,6 @@ void Assembler::movaps(XMMRegister dst, XMMRegister src) {
   emit_sse_operand(dst, src);
 }
 
-void Assembler::movlhps(XMMRegister dst, XMMRegister src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x0F);
-  EMIT(0x16);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::movhlps(XMMRegister dst, XMMRegister src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x0F);
-  EMIT(0x12);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::movups(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x0F);
-  EMIT(0x10);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::movups(const Operand& dst, XMMRegister src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x0F);
-  EMIT(0x11);
-  emit_sse_operand(src, dst);
-}
 
 void Assembler::shufps(XMMRegister dst, XMMRegister src, byte imm8) {
   DCHECK(is_uint8(imm8));
@@ -2536,15 +2413,6 @@ void Assembler::shufps(XMMRegister dst, XMMRegister src, byte imm8) {
   EMIT(imm8);
 }
 
-void Assembler::shufpd(XMMRegister dst, XMMRegister src, byte imm8) {
-  DCHECK(is_uint8(imm8));
-  EnsureSpace ensure_space(this);
-  EMIT(0x66);
-  EMIT(0x0F);
-  EMIT(0xC6);
-  emit_sse_operand(dst, src);
-  EMIT(imm8);
-}
 
 void Assembler::movdqa(const Operand& dst, XMMRegister src) {
   EnsureSpace ensure_space(this);
@@ -2628,21 +2496,6 @@ void Assembler::movss(XMMRegister dst, const Operand& src) {
   emit_sse_operand(dst, src);
 }
 
-void Assembler::movq(const Operand& dst, XMMRegister src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x66);
-  EMIT(0x0F);
-  EMIT(0xD6);  // store
-  emit_sse_operand(src, dst);
-}
-
-void Assembler::movq(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0xF3);
-  EMIT(0x0F);
-  EMIT(0x7E);  // load
-  emit_sse_operand(dst, src);
-}
 
 void Assembler::movd(XMMRegister dst, const Operand& src) {
   EnsureSpace ensure_space(this);
@@ -2751,38 +2604,6 @@ void Assembler::psllq(XMMRegister dst, XMMRegister src) {
   emit_sse_operand(dst, src);
 }
 
-void Assembler::pslld(XMMRegister dst, XMMRegister src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x66);
-  EMIT(0x0F);
-  EMIT(0xF2);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::psrld(XMMRegister dst, XMMRegister src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x66);
-  EMIT(0x0F);
-  EMIT(0xD2);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::psrad(XMMRegister reg, int8_t shift) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x66);
-  EMIT(0x0F);
-  EMIT(0x72);
-  emit_sse_operand(esp, reg);  // esp == 4
-  EMIT(shift);
-}
-
-void Assembler::psrad(XMMRegister dst, XMMRegister src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x66);
-  EMIT(0x0F);
-  EMIT(0xE2);
-  emit_sse_operand(dst, src);
-}
 
 void Assembler::psrlq(XMMRegister reg, int8_t shift) {
   EnsureSpace ensure_space(this);
@@ -2802,14 +2623,6 @@ void Assembler::psrlq(XMMRegister dst, XMMRegister src) {
   emit_sse_operand(dst, src);
 }
 
-void Assembler::psrldq(XMMRegister dst, int8_t shift) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x66);
-  EMIT(0x0F);
-  EMIT(0x73);
-  emit_sse_operand(ebx, dst);  // ebx == 3
-  EMIT(shift);
-}
 
 void Assembler::pshufd(XMMRegister dst, XMMRegister src, uint8_t shuffle) {
   EnsureSpace ensure_space(this);
@@ -2853,12 +2666,6 @@ void Assembler::addss(XMMRegister dst, const Operand& src) {
   emit_sse_operand(dst, src);
 }
 
-void Assembler::minps(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x0F);
-  EMIT(0x5D);
-  emit_sse_operand(dst, src);
-}
 
 void Assembler::subss(XMMRegister dst, const Operand& src) {
   EnsureSpace ensure_space(this);
@@ -2868,12 +2675,6 @@ void Assembler::subss(XMMRegister dst, const Operand& src) {
   emit_sse_operand(dst, src);
 }
 
-void Assembler::maxps(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x0F);
-  EMIT(0x5F);
-  emit_sse_operand(dst, src);
-}
 
 void Assembler::mulss(XMMRegister dst, const Operand& src) {
   EnsureSpace ensure_space(this);
@@ -2883,13 +2684,6 @@ void Assembler::mulss(XMMRegister dst, const Operand& src) {
   emit_sse_operand(dst, src);
 }
 
-void Assembler::minpd(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x66);
-  EMIT(0x0F);
-  EMIT(0x5D);
-  emit_sse_operand(dst, src);
-}
 
 void Assembler::divss(XMMRegister dst, const Operand& src) {
   EnsureSpace ensure_space(this);
@@ -2908,13 +2702,6 @@ void Assembler::sqrtss(XMMRegister dst, const Operand& src) {
   emit_sse_operand(dst, src);
 }
 
-void Assembler::maxpd(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x66);
-  EMIT(0x0F);
-  EMIT(0x5F);
-  emit_sse_operand(dst, src);
-}
 
 void Assembler::ucomiss(XMMRegister dst, const Operand& src) {
   EnsureSpace ensure_space(this);
@@ -2932,12 +2719,6 @@ void Assembler::maxss(XMMRegister dst, const Operand& src) {
   emit_sse_operand(dst, src);
 }
 
-void Assembler::rcpps(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x0F);
-  EMIT(0x53);
-  emit_sse_operand(dst, src);
-}
 
 void Assembler::minss(XMMRegister dst, const Operand& src) {
   EnsureSpace ensure_space(this);
@@ -2947,42 +2728,6 @@ void Assembler::minss(XMMRegister dst, const Operand& src) {
   emit_sse_operand(dst, src);
 }
 
-void Assembler::rsqrtps(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x0F);
-  EMIT(0x52);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::sqrtps(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x0F);
-  EMIT(0x51);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::sqrtpd(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x66);
-  EMIT(0x0F);
-  EMIT(0x51);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::cvtdq2ps(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x0F);
-  EMIT(0x5B);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::paddd(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x66);
-  EMIT(0x0F);
-  EMIT(0xFE);
-  emit_sse_operand(dst, src);
-}
 
 // AVX instructions
 void Assembler::vfmasd(byte op, XMMRegister dst, XMMRegister src1,
@@ -3105,91 +2850,6 @@ void Assembler::rorx(Register dst, const Operand& src, byte imm8) {
   EMIT(imm8);
 }
 
-void Assembler::psubd(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x66);
-  EMIT(0x0F);
-  EMIT(0xFA);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::pmulld(XMMRegister dst, const Operand& src) {
-  DCHECK(IsEnabled(SSE4_1));
-  EnsureSpace ensure_space(this);
-  EMIT(0x66);
-  EMIT(0x0F);
-  EMIT(0x38);
-  EMIT(0x40);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::pmuludq(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x66);
-  EMIT(0x0F);
-  EMIT(0xF4);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::punpackldq(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x66);
-  EMIT(0x0F);
-  EMIT(0x62);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::cvtps2dq(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x66);
-  EMIT(0x0F);
-  EMIT(0x5B);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::cmpps(XMMRegister dst, XMMRegister src, int8_t cmp) {
-  EnsureSpace ensure_space(this);
-  EMIT(0x0F);
-  EMIT(0xC2);
-  emit_sse_operand(dst, src);
-  EMIT(cmp);
-}
-
-void Assembler::cmpeqps(XMMRegister dst, XMMRegister src) {
-  cmpps(dst, src, 0x0);
-}
-
-void Assembler::cmpltps(XMMRegister dst, XMMRegister src) {
-  cmpps(dst, src, 0x1);
-}
-
-void Assembler::cmpleps(XMMRegister dst, XMMRegister src) {
-  cmpps(dst, src, 0x2);
-}
-
-void Assembler::cmpneqps(XMMRegister dst, XMMRegister src) {
-  cmpps(dst, src, 0x4);
-}
-
-void Assembler::cmpnltps(XMMRegister dst, XMMRegister src) {
-  cmpps(dst, src, 0x5);
-}
-
-void Assembler::cmpnleps(XMMRegister dst, XMMRegister src) {
-  cmpps(dst, src, 0x6);
-}
-
-void Assembler::insertps(XMMRegister dst, XMMRegister src, byte imm8) {
-  DCHECK(CpuFeatures::IsSupported(SSE4_1));
-  DCHECK(is_uint8(imm8));
-  EnsureSpace ensure_space(this);
-  EMIT(0x66);
-  EMIT(0x0F);
-  EMIT(0x3A);
-  EMIT(0x21);
-  emit_sse_operand(dst, src);
-  EMIT(imm8);
-}
 
 void Assembler::emit_sse_operand(XMMRegister reg, const Operand& adr) {
   Register ireg = { reg.code() };
diff --git a/src/ia32/assembler-ia32.h b/src/ia32/assembler-ia32.h
index e1ba9e5763..4e542d72c9 100644
--- a/src/ia32/assembler-ia32.h
+++ b/src/ia32/assembler-ia32.h
@@ -189,38 +189,37 @@ DOUBLE_REGISTERS(DECLARE_REGISTER)
 #undef DECLARE_REGISTER
 const DoubleRegister no_double_reg = {DoubleRegister::kCode_no_reg};
 
-typedef DoubleRegister SIMD128Register;
-
 enum Condition {
   // any value < 0 is considered no_condition
-  no_condition = -1,
-
-  overflow = 0,
-  no_overflow = 1,
-  below = 2,
-  above_equal = 3,
-  equal = 4,
-  not_equal = 5,
-  below_equal = 6,
-  above = 7,
-  negative = 8,
-  positive = 9,
-  parity_even = 10,
-  parity_odd = 11,
-  less = 12,
+  no_condition  = -1,
+
+  overflow      =  0,
+  no_overflow   =  1,
+  below         =  2,
+  above_equal   =  3,
+  equal         =  4,
+  not_equal     =  5,
+  below_equal   =  6,
+  above         =  7,
+  negative      =  8,
+  positive      =  9,
+  parity_even   = 10,
+  parity_odd    = 11,
+  less          = 12,
   greater_equal = 13,
-  less_equal = 14,
-  greater = 15,
-  never = 17,
+  less_equal    = 14,
+  greater       = 15,
+
   // aliases
-  carry = below,
-  not_carry = above_equal,
-  zero = equal,
-  not_zero = not_equal,
-  sign = negative,
-  not_sign = positive
+  carry         = below,
+  not_carry     = above_equal,
+  zero          = equal,
+  not_zero      = not_equal,
+  sign          = negative,
+  not_sign      = positive
 };
 
+
 // Returns the equivalent of !cc.
 // Negation of the default no_condition (-1) results in a non-default
 // no_condition value (-2). As long as tests for no_condition check
@@ -313,13 +312,13 @@ enum ScaleFactor {
   times_2 = 1,
   times_4 = 2,
   times_8 = 3,
-  maximal_scale_factor = times_8,
   times_int_size = times_4,
   times_half_pointer_size = times_2,
   times_pointer_size = times_4,
   times_twice_pointer_size = times_8
 };
 
+
 class Operand BASE_EMBEDDED {
  public:
   // reg
@@ -356,11 +355,6 @@ class Operand BASE_EMBEDDED {
                    RelocInfo::INTERNAL_REFERENCE);
   }
 
-  // Offset from existing memory operand.
-  // Offset is added to existing displacement as 32-bit signed values and
-  // this must not overflow.
-  Operand(const Operand& base, int32_t offset);
-
   static Operand StaticVariable(const ExternalReference& ext) {
     return Operand(reinterpret_cast<int32_t>(ext.address()),
                    RelocInfo::EXTERNAL_REFERENCE);
@@ -965,12 +959,7 @@ class Assembler : public AssemblerBase {
   void ucomiss(XMMRegister dst, XMMRegister src) { ucomiss(dst, Operand(src)); }
   void ucomiss(XMMRegister dst, const Operand& src);
   void movaps(XMMRegister dst, XMMRegister src);
-  void movlhps(XMMRegister dst, XMMRegister src);
-  void movhlps(XMMRegister dst, XMMRegister src);
-  void movups(XMMRegister dst, const Operand& src);
-  void movups(const Operand& dst, XMMRegister src);
   void shufps(XMMRegister dst, XMMRegister src, byte imm8);
-  void shufpd(XMMRegister dst, XMMRegister src, byte imm8);
 
   void maxss(XMMRegister dst, XMMRegister src) { maxss(dst, Operand(src)); }
   void maxss(XMMRegister dst, const Operand& src);
@@ -992,63 +981,6 @@ class Assembler : public AssemblerBase {
   void mulps(XMMRegister dst, XMMRegister src) { mulps(dst, Operand(src)); }
   void divps(XMMRegister dst, const Operand& src);
   void divps(XMMRegister dst, XMMRegister src) { divps(dst, Operand(src)); }
-  void minps(XMMRegister dst, XMMRegister src) { minps(dst, Operand(src)); }
-  void minps(XMMRegister dst, const Operand& src);
-  void maxps(XMMRegister dst, XMMRegister src) { maxps(dst, Operand(src)); }
-  void maxps(XMMRegister dst, const Operand& src);
-  void rcpps(XMMRegister dst, XMMRegister src) { rcpps(dst, Operand(src)); }
-  void rcpps(XMMRegister dst, const Operand& src);
-  void rsqrtps(XMMRegister dst, XMMRegister src) { rsqrtps(dst, Operand(src)); }
-  void rsqrtps(XMMRegister dst, const Operand& src);
-  void sqrtps(XMMRegister dst, XMMRegister src) { sqrtps(dst, Operand(src)); }
-  void sqrtps(XMMRegister dst, const Operand& src);
-  void sqrtpd(XMMRegister dst, XMMRegister src) { sqrtpd(dst, Operand(src)); }
-  void sqrtpd(XMMRegister dst, const Operand& src);
-
-  void addpd(XMMRegister dst, const Operand& src);
-  void addpd(XMMRegister dst, XMMRegister src) { addpd(dst, Operand(src)); }
-  void subpd(XMMRegister dst, const Operand& src);
-  void subpd(XMMRegister dst, XMMRegister src) { subpd(dst, Operand(src)); }
-  void mulpd(XMMRegister dst, const Operand& src);
-  void mulpd(XMMRegister dst, XMMRegister src) { mulpd(dst, Operand(src)); }
-  void divpd(XMMRegister dst, const Operand& src);
-  void divpd(XMMRegister dst, XMMRegister src) { divpd(dst, Operand(src)); }
-  void minpd(XMMRegister dst, XMMRegister src) { minpd(dst, Operand(src)); }
-  void minpd(XMMRegister dst, const Operand& src);
-  void maxpd(XMMRegister dst, XMMRegister src) { maxpd(dst, Operand(src)); }
-  void maxpd(XMMRegister dst, const Operand& src);
-
-  void cvtdq2ps(XMMRegister dst, const Operand& src);
-  void cmpps(XMMRegister dst, XMMRegister src, int8_t cmp);
-  void cmpeqps(XMMRegister dst, XMMRegister src);
-  void cmpltps(XMMRegister dst, XMMRegister src);
-  void cmpleps(XMMRegister dst, XMMRegister src);
-  void cmpneqps(XMMRegister dst, XMMRegister src);
-  void cmpnltps(XMMRegister dst, XMMRegister src);
-  void cmpnleps(XMMRegister dst, XMMRegister src);
-
-  // SSE 2, introduced by SIMD
-  void paddd(XMMRegister dst, XMMRegister src) { paddd(dst, Operand(src)); }
-  void paddd(XMMRegister dst, const Operand& src);
-  void psubd(XMMRegister dst, XMMRegister src) { psubd(dst, Operand(src)); }
-  void psubd(XMMRegister dst, const Operand& src);
-  void pmuludq(XMMRegister dst, XMMRegister src) { pmuludq(dst, Operand(src)); }
-  void pmuludq(XMMRegister dst, const Operand& src);
-  void punpackldq(XMMRegister dst, XMMRegister src) {
-    punpackldq(dst, Operand(src));
-  }
-  void punpackldq(XMMRegister dst, const Operand& src);
-  void cvtps2dq(XMMRegister dst, XMMRegister src) {
-    cvtps2dq(dst, Operand(src));
-  }
-  void cvtps2dq(XMMRegister dst, const Operand& src);
-  void cvtdq2ps(XMMRegister dst, XMMRegister src) {
-    cvtdq2ps(dst, Operand(src));
-  }
-  // SSE 4.1, introduced by SIMD
-  void insertps(XMMRegister dst, XMMRegister src, byte imm8);
-  void pmulld(XMMRegister dst, XMMRegister src) { pmulld(dst, Operand(src)); }
-  void pmulld(XMMRegister dst, const Operand& src);
 
   // SSE2 instructions
   void cvttss2si(Register dst, const Operand& src);
@@ -1082,12 +1014,10 @@ class Assembler : public AssemblerBase {
   void divsd(XMMRegister dst, XMMRegister src) { divsd(dst, Operand(src)); }
   void divsd(XMMRegister dst, const Operand& src);
   void xorpd(XMMRegister dst, XMMRegister src);
-  void xorpd(XMMRegister dst, const Operand& src);
   void sqrtsd(XMMRegister dst, XMMRegister src) { sqrtsd(dst, Operand(src)); }
   void sqrtsd(XMMRegister dst, const Operand& src);
 
   void andpd(XMMRegister dst, XMMRegister src);
-  void andpd(XMMRegister dst, const Operand& src);
   void orpd(XMMRegister dst, XMMRegister src);
 
   void ucomisd(XMMRegister dst, XMMRegister src) { ucomisd(dst, Operand(src)); }
@@ -1101,7 +1031,6 @@ class Assembler : public AssemblerBase {
 
   void cmpltsd(XMMRegister dst, XMMRegister src);
   void pcmpeqd(XMMRegister dst, XMMRegister src);
-  void pcmpgtd(XMMRegister dst, XMMRegister src);
 
   void punpckldq(XMMRegister dst, XMMRegister src);
   void punpckhdq(XMMRegister dst, XMMRegister src);
@@ -1135,8 +1064,6 @@ class Assembler : public AssemblerBase {
   void movss(XMMRegister dst, const Operand& src);
   void movss(const Operand& dst, XMMRegister src);
   void movss(XMMRegister dst, XMMRegister src) { movss(dst, Operand(src)); }
-  void movq(XMMRegister dst, const Operand& src);
-  void movq(const Operand& dst, XMMRegister src);
   void extractps(Register dst, XMMRegister src, byte imm8);
 
   void pand(XMMRegister dst, XMMRegister src);
@@ -1148,13 +1075,8 @@ class Assembler : public AssemblerBase {
   void psrld(XMMRegister reg, int8_t shift);
   void psllq(XMMRegister reg, int8_t shift);
   void psllq(XMMRegister dst, XMMRegister src);
-  void pslld(XMMRegister dst, XMMRegister src);
-  void psrld(XMMRegister dst, XMMRegister src);
-  void psrad(XMMRegister reg, int8_t shift);
-  void psrad(XMMRegister dst, XMMRegister src);
   void psrlq(XMMRegister reg, int8_t shift);
   void psrlq(XMMRegister dst, XMMRegister src);
-  void psrldq(XMMRegister dst, int8_t shift);
   void pshufd(XMMRegister dst, XMMRegister src, uint8_t shuffle);
   void pextrd(Register dst, XMMRegister src, int8_t offset) {
     pextrd(Operand(dst), src, offset);
diff --git a/src/ia32/deoptimizer-ia32.cc b/src/ia32/deoptimizer-ia32.cc
index fb1267e5d5..c14a2a1e2e 100644
--- a/src/ia32/deoptimizer-ia32.cc
+++ b/src/ia32/deoptimizer-ia32.cc
@@ -178,12 +178,11 @@ void Deoptimizer::SetPlatformCompiledStubRegisters(
   output_frame->SetRegister(ebx.code(), handler);
 }
 
-void Deoptimizer::CopyDoubleRegisters(FrameDescription* output_frame) {}
 
-void Deoptimizer::CopySIMD128Registers(FrameDescription* output_frame) {
+void Deoptimizer::CopyDoubleRegisters(FrameDescription* output_frame) {
   for (int i = 0; i < XMMRegister::kMaxNumRegisters; ++i) {
-    simd128_value_t xmm_value = input_->GetSIMD128Register(i);
-    output_frame->SetSIMD128Register(i, xmm_value);
+    double double_value = input_->GetDoubleRegister(i);
+    output_frame->SetDoubleRegister(i, double_value);
   }
 }
 
@@ -195,14 +194,14 @@ void Deoptimizer::TableEntryGenerator::Generate() {
   // Save all general purpose registers before messing with them.
   const int kNumberOfRegisters = Register::kNumRegisters;
 
-  const int kXMMRegsSize = kSIMD128Size * XMMRegister::kMaxNumRegisters;
-  __ sub(esp, Immediate(kXMMRegsSize));
+  const int kDoubleRegsSize = kDoubleSize * XMMRegister::kMaxNumRegisters;
+  __ sub(esp, Immediate(kDoubleRegsSize));
   const RegisterConfiguration* config = RegisterConfiguration::Crankshaft();
   for (int i = 0; i < config->num_allocatable_double_registers(); ++i) {
     int code = config->GetAllocatableDoubleCode(i);
     XMMRegister xmm_reg = XMMRegister::from_code(code);
-    int offset = code * kSIMD128Size;
-    __ movups(Operand(esp, offset), xmm_reg);
+    int offset = code * kDoubleSize;
+    __ movsd(Operand(esp, offset), xmm_reg);
   }
 
   __ pushad();
@@ -210,8 +209,8 @@ void Deoptimizer::TableEntryGenerator::Generate() {
   ExternalReference c_entry_fp_address(Isolate::kCEntryFPAddress, isolate());
   __ mov(Operand::StaticVariable(c_entry_fp_address), ebp);
 
-  const int kSavedRegistersAreaSize =
-      kNumberOfRegisters * kPointerSize + kXMMRegsSize;
+  const int kSavedRegistersAreaSize = kNumberOfRegisters * kPointerSize +
+                                      kDoubleRegsSize;
 
   // Get the bailout id from the stack.
   __ mov(ebx, Operand(esp, kSavedRegistersAreaSize));
@@ -254,14 +253,14 @@ void Deoptimizer::TableEntryGenerator::Generate() {
     __ pop(Operand(ebx, offset));
   }
 
-  int xmm_regs_offset = FrameDescription::simd128_registers_offset();
+  int double_regs_offset = FrameDescription::double_registers_offset();
   // Fill in the double input registers.
   for (int i = 0; i < config->num_allocatable_double_registers(); ++i) {
     int code = config->GetAllocatableDoubleCode(i);
-    int dst_offset = code * kSIMD128Size + xmm_regs_offset;
-    int src_offset = code * kSIMD128Size;
-    __ movups(xmm0, Operand(esp, src_offset));
-    __ movups(Operand(ebx, dst_offset), xmm0);
+    int dst_offset = code * kDoubleSize + double_regs_offset;
+    int src_offset = code * kDoubleSize;
+    __ movsd(xmm0, Operand(esp, src_offset));
+    __ movsd(Operand(ebx, dst_offset), xmm0);
   }
 
   // Clear FPU all exceptions.
@@ -270,7 +269,7 @@ void Deoptimizer::TableEntryGenerator::Generate() {
   __ fnclex();
 
   // Remove the bailout id, return address and the double registers.
-  __ add(esp, Immediate(kXMMRegsSize + 2 * kPointerSize));
+  __ add(esp, Immediate(kDoubleRegsSize + 2 * kPointerSize));
 
   // Compute a pointer to the unwinding limit in register ecx; that is
   // the first stack slot not part of the input frame.
@@ -333,8 +332,8 @@ void Deoptimizer::TableEntryGenerator::Generate() {
   for (int i = 0; i < config->num_allocatable_double_registers(); ++i) {
     int code = config->GetAllocatableDoubleCode(i);
     XMMRegister xmm_reg = XMMRegister::from_code(code);
-    int src_offset = code * kSIMD128Size + xmm_regs_offset;
-    __ movups(xmm_reg, Operand(ebx, src_offset));
+    int src_offset = code * kDoubleSize + double_regs_offset;
+    __ movsd(xmm_reg, Operand(ebx, src_offset));
   }
 
   // Push state, pc, and continuation from the last output frame.
@@ -386,33 +385,6 @@ void FrameDescription::SetCallerConstantPool(unsigned offset, intptr_t value) {
   UNREACHABLE();
 }
 
-double RegisterValues::GetDoubleRegister(unsigned n) const {
-  DCHECK(n < arraysize(simd128_registers_));
-  return simd128_registers_[n].d[0];
-}
-
-void RegisterValues::SetDoubleRegister(unsigned n, double value) {
-  DCHECK(n < arraysize(simd128_registers_));
-  simd128_registers_[n].d[0] = value;
-}
-
-simd128_value_t RegisterValues::GetSIMD128Register(unsigned n) const {
-  DCHECK(n < arraysize(simd128_registers_));
-  return simd128_registers_[n];
-}
-
-void RegisterValues::SetSIMD128Register(unsigned n, simd128_value_t value) {
-  DCHECK(n < arraysize(simd128_registers_));
-  simd128_registers_[n] = value;
-}
-
-int FrameDescription::double_registers_offset() {
-  return OFFSET_OF(FrameDescription, register_values_.simd128_registers_);
-}
-
-int FrameDescription::simd128_registers_offset() {
-  return OFFSET_OF(FrameDescription, register_values_.simd128_registers_);
-}
 
 #undef __
 
diff --git a/src/ia32/disasm-ia32.cc b/src/ia32/disasm-ia32.cc
index 9f4fe097c1..be3530cb3d 100644
--- a/src/ia32/disasm-ia32.cc
+++ b/src/ia32/disasm-ia32.cc
@@ -1428,43 +1428,28 @@ int DisassemblerIA32::InstructionDecode(v8::internal::Vector<char> out_buffer,
             get_modrm(*data, &mod, &regop, &rm);
             AppendToBuffer("ucomiss %s,", NameOfXMMRegister(regop));
             data += PrintRightXMMOperand(data);
-          } else if (f0byte == 0x12) {
-            data += 2;
-            int mod, regop, rm;
-            get_modrm(*data, &mod, &regop, &rm);
-            AppendToBuffer("movhlps %s,%s", NameOfXMMRegister(regop),
-                           NameOfXMMRegister(rm));
-            data++;
-          } else if (f0byte == 0x16) {
-            data += 2;
-            int mod, regop, rm;
-            get_modrm(*data, &mod, &regop, &rm);
-            AppendToBuffer("movlhps %s,%s", NameOfXMMRegister(regop),
-                           NameOfXMMRegister(rm));
-            data++;
-          } else if (f0byte == 0x10) {
-            data += 2;
-            int mod, regop, rm;
-            get_modrm(*data, &mod, &regop, &rm);
-            AppendToBuffer("movups %s,", NameOfXMMRegister(regop));
-            data += PrintRightXMMOperand(data);
-          } else if (f0byte == 0x11) {
-            AppendToBuffer("movups ");
-            data += 2;
-            int mod, regop, rm;
-            get_modrm(*data, &mod, &regop, &rm);
-            data += PrintRightXMMOperand(data);
-            AppendToBuffer(",%s", NameOfXMMRegister(regop));
           } else if (f0byte >= 0x53 && f0byte <= 0x5F) {
             const char* const pseudo_op[] = {
-                "sqrtps",   "rsqrtps", "rcpps", "andps", "andnps",
-                "orps",     "xorps",   "addps", "mulps", "cvtps2pd",
-                "cvtdq2ps", "subps",   "minps", "divps", "maxps"};
+              "rcpps",
+              "andps",
+              "andnps",
+              "orps",
+              "xorps",
+              "addps",
+              "mulps",
+              "cvtps2pd",
+              "cvtdq2ps",
+              "subps",
+              "minps",
+              "divps",
+              "maxps",
+            };
 
             data += 2;
             int mod, regop, rm;
             get_modrm(*data, &mod, &regop, &rm);
-            AppendToBuffer("%s %s,", pseudo_op[f0byte - 0x51],
+            AppendToBuffer("%s %s,",
+                           pseudo_op[f0byte - 0x53],
                            NameOfXMMRegister(regop));
             data += PrintRightXMMOperand(data);
           } else if (f0byte == 0x50) {
@@ -1475,17 +1460,6 @@ int DisassemblerIA32::InstructionDecode(v8::internal::Vector<char> out_buffer,
                            NameOfCPURegister(regop),
                            NameOfXMMRegister(rm));
             data++;
-          } else if (f0byte == 0xC2) {
-            // Intel manual 2A, Table 3-11.
-            data += 2;
-            int mod, regop, rm;
-            get_modrm(*data, &mod, &regop, &rm);
-            const char* const pseudo_op[] = {
-                "cmpeqps",  "cmpltps",  "cmpleps",  "cmpunordps",
-                "cmpneqps", "cmpnltps", "cmpnleps", "cmpordps"};
-            AppendToBuffer("%s %s,%s", pseudo_op[data[1]],
-                           NameOfXMMRegister(regop), NameOfXMMRegister(rm));
-            data += 2;
           } else if (f0byte== 0xC6) {
             // shufps xmm, xmm/m128, imm8
             data += 2;
@@ -1497,12 +1471,6 @@ int DisassemblerIA32::InstructionDecode(v8::internal::Vector<char> out_buffer,
                             NameOfXMMRegister(regop),
                             static_cast<int>(imm8));
             data += 2;
-          } else if (f0byte == 0x5B) {
-            data += 2;
-            int mod, regop, rm;
-            get_modrm(*data, &mod, &regop, &rm);
-            AppendToBuffer("cvtdq2ps %s,", NameOfXMMRegister(rm));
-            data += PrintRightXMMOperand(data);
           } else if ((f0byte & 0xF0) == 0x80) {
             data += JumpConditional(data, branch_hint);
           } else if (f0byte == 0xBE || f0byte == 0xBF || f0byte == 0xB6 ||
@@ -1711,12 +1679,6 @@ int DisassemblerIA32::InstructionDecode(v8::internal::Vector<char> out_buffer,
                              NameOfXMMRegister(regop),
                              NameOfXMMRegister(rm));
               data++;
-            } else if (*data == 0x40) {
-              data++;
-              int mod, regop, rm;
-              get_modrm(*data, &mod, &regop, &rm);
-              AppendToBuffer("pmulld %s", NameOfXMMRegister(regop));
-              data += PrintRightXMMOperand(data);
             } else if (*data == 0x2A) {
               // movntdqa
               UnimplementedInstruction();
@@ -1753,14 +1715,6 @@ int DisassemblerIA32::InstructionDecode(v8::internal::Vector<char> out_buffer,
                              NameOfXMMRegister(rm),
                              static_cast<int>(imm8));
               data += 2;
-            } else if (*data == 0x21) {
-              data++;
-              int mod, regop, rm;
-              get_modrm(*data, &mod, &regop, &rm);
-              int8_t imm8 = static_cast<int8_t>(data[1]);
-              AppendToBuffer("insertps %s,%s,%d", NameOfXMMRegister(regop),
-                             NameOfXMMRegister(rm), static_cast<int>(imm8));
-              data += 2;
             } else if (*data == 0x17) {
               data++;
               int mod, regop, rm;
@@ -1806,13 +1760,6 @@ int DisassemblerIA32::InstructionDecode(v8::internal::Vector<char> out_buffer,
                            NameOfCPURegister(regop),
                            NameOfXMMRegister(rm));
             data++;
-          } else if (*data == 0x51) {
-            data++;
-            int mod, regop, rm;
-            get_modrm(*data, &mod, &regop, &rm);
-            AppendToBuffer("sqrtpd %s,%s", NameOfXMMRegister(regop),
-                           NameOfXMMRegister(rm));
-            data++;
           } else if (*data == 0x54) {
             data++;
             int mod, regop, rm;
@@ -1833,81 +1780,10 @@ int DisassemblerIA32::InstructionDecode(v8::internal::Vector<char> out_buffer,
             data++;
             int mod, regop, rm;
             get_modrm(*data, &mod, &regop, &rm);
-            AppendToBuffer("xorpd %s,", NameOfXMMRegister(regop));
-            data += PrintRightXMMOperand(data);
-          } else if (*data == 0x58) {
-            data++;
-            int mod, regop, rm;
-            get_modrm(*data, &mod, &regop, &rm);
-            AppendToBuffer("addpd %s,", NameOfXMMRegister(regop));
-            data += PrintRightXMMOperand(data);
-          } else if (*data == 0x59) {
-            data++;
-            int mod, regop, rm;
-            get_modrm(*data, &mod, &regop, &rm);
-            AppendToBuffer("mulpd %s,", NameOfXMMRegister(regop));
-            data += PrintRightXMMOperand(data);
-          } else if (*data == 0x5B) {
-            data++;
-            int mod, regop, rm;
-            get_modrm(*data, &mod, &regop, &rm);
-            AppendToBuffer("cvtps2dq %s,", NameOfXMMRegister(regop));
-            data += PrintRightXMMOperand(data);
-          } else if (*data == 0x5C) {
-            data++;
-            int mod, regop, rm;
-            get_modrm(*data, &mod, &regop, &rm);
-            AppendToBuffer("subpd %s,", NameOfXMMRegister(regop));
-            data += PrintRightXMMOperand(data);
-          } else if (*data == 0x5D) {
-            data++;
-            int mod, regop, rm;
-            get_modrm(*data, &mod, &regop, &rm);
-            AppendToBuffer("minpd %s,", NameOfXMMRegister(regop));
-            data += PrintRightXMMOperand(data);
-          } else if (*data == 0x5E) {
-            data++;
-            int mod, regop, rm;
-            get_modrm(*data, &mod, &regop, &rm);
-            AppendToBuffer("divpd %s,", NameOfXMMRegister(regop));
-            data += PrintRightXMMOperand(data);
-          } else if (*data == 0x5F) {
-            data++;
-            int mod, regop, rm;
-            get_modrm(*data, &mod, &regop, &rm);
-            AppendToBuffer("maxpd %s,", NameOfXMMRegister(regop));
-            data += PrintRightXMMOperand(data);
-          } else if (*data == 0x62) {
-            data++;
-            int mod, regop, rm;
-            get_modrm(*data, &mod, &regop, &rm);
-            AppendToBuffer("punpackldq %s,", NameOfXMMRegister(regop));
-            data += PrintRightXMMOperand(data);
-          } else if (*data == 0xD6) {
-            AppendToBuffer("movq ");
-            data += 3;
-            int mod, regop, rm;
-            get_modrm(*data, &mod, &regop, &rm);
-            data += PrintRightXMMOperand(data);
-            AppendToBuffer(",%s", NameOfXMMRegister(regop));
-          } else if (*data == 0xF4) {
-            data++;
-            int mod, regop, rm;
-            get_modrm(*data, &mod, &regop, &rm);
-            AppendToBuffer("pmuludq %s,", NameOfXMMRegister(regop));
-            data += PrintRightXMMOperand(data);
-          } else if (*data == 0xFA) {
-            data++;
-            int mod, regop, rm;
-            get_modrm(*data, &mod, &regop, &rm);
-            AppendToBuffer("psubd %s,", NameOfXMMRegister(regop));
-            data += PrintRightXMMOperand(data);
-          } else if (*data == 0xFE) {
+            AppendToBuffer("xorpd %s,%s",
+                           NameOfXMMRegister(regop),
+                           NameOfXMMRegister(rm));
             data++;
-            int mod, regop, rm;
-            get_modrm(*data, &mod, &regop, &rm);
-            AppendToBuffer("paddd %s,", NameOfXMMRegister(regop));
-            data += PrintRightXMMOperand(data);
           } else if (*data == 0x6E) {
             data++;
             int mod, regop, rm;
@@ -1944,13 +1820,6 @@ int DisassemblerIA32::InstructionDecode(v8::internal::Vector<char> out_buffer,
             AppendToBuffer("punpckhdq %s,%s", NameOfXMMRegister(regop),
                            NameOfXMMRegister(rm));
             data++;
-          } else if (*data == 0x66) {
-            data++;
-            int mod, regop, rm;
-            get_modrm(*data, &mod, &regop, &rm);
-            AppendToBuffer("pcmpgtd %s,%s", NameOfXMMRegister(regop),
-                           NameOfXMMRegister(rm));
-            data++;
           } else if (*data == 0x76) {
             data++;
             int mod, regop, rm;
@@ -1990,39 +1859,6 @@ int DisassemblerIA32::InstructionDecode(v8::internal::Vector<char> out_buffer,
                            NameOfXMMRegister(rm),
                            static_cast<int>(imm8));
             data += 2;
-          } else if (*data == 0xF2) {
-            data++;
-            int mod, regop, rm;
-            get_modrm(*data, &mod, &regop, &rm);
-            AppendToBuffer("pslld %s,%s", NameOfXMMRegister(regop),
-                           NameOfXMMRegister(rm));
-            data++;
-          } else if (*data == 0x72) {
-            data++;
-            int mod, regop, rm;
-            get_modrm(*data, &mod, &regop, &rm);
-            int8_t imm8 = static_cast<int8_t>(data[1]);
-            DCHECK(regop == esi || regop == edx);
-            AppendToBuffer(
-                "%s %s,%d",
-                (regop == esi) ? "pslld" : ((regop == edx) ? "psrld" : "psrad"),
-                NameOfXMMRegister(rm), static_cast<int>(imm8));
-            data += 2;
-          } else if (*data == 0xC6) {
-            data++;
-            int mod, regop, rm;
-            get_modrm(*data, &mod, &regop, &rm);
-            int8_t imm8 = static_cast<int8_t>(data[1]);
-            AppendToBuffer("shufpd %s,%s,%d", NameOfXMMRegister(regop),
-                           NameOfXMMRegister(rm), static_cast<int>(imm8));
-            data += 2;
-          } else if (*data == 0xD2) {
-            data++;
-            int mod, regop, rm;
-            get_modrm(*data, &mod, &regop, &rm);
-            AppendToBuffer("psrld %s,%s", NameOfXMMRegister(regop),
-                           NameOfXMMRegister(rm));
-            data++;
           } else if (*data == 0xD3) {
             data++;
             int mod, regop, rm;
@@ -2031,13 +1867,6 @@ int DisassemblerIA32::InstructionDecode(v8::internal::Vector<char> out_buffer,
                            NameOfXMMRegister(regop),
                            NameOfXMMRegister(rm));
             data++;
-          } else if (*data == 0xE2) {
-            data++;
-            int mod, regop, rm;
-            get_modrm(*data, &mod, &regop, &rm);
-            AppendToBuffer("psrad %s,%s", NameOfXMMRegister(regop),
-                           NameOfXMMRegister(rm));
-            data++;
           } else if (*data == 0x7F) {
             AppendToBuffer("movdqa ");
             data++;
@@ -2296,12 +2125,6 @@ int DisassemblerIA32::InstructionDecode(v8::internal::Vector<char> out_buffer,
             get_modrm(*data, &mod, &regop, &rm);
             AppendToBuffer("lzcnt %s,", NameOfCPURegister(regop));
             data += PrintRightOperand(data);
-          } else if (b2 == 0x7E) {
-            data += 3;
-            int mod, regop, rm;
-            get_modrm(*data, &mod, &regop, &rm);
-            AppendToBuffer("movq %s,", NameOfXMMRegister(regop));
-            data += PrintRightXMMOperand(data);
           } else {
             const char* mnem = "?";
             switch (b2) {
diff --git a/src/ia32/macro-assembler-ia32.cc b/src/ia32/macro-assembler-ia32.cc
index c19a6a1adc..25a0a95974 100644
--- a/src/ia32/macro-assembler-ia32.cc
+++ b/src/ia32/macro-assembler-ia32.cc
@@ -1159,13 +1159,13 @@ void MacroAssembler::EnterExitFramePrologue() {
 void MacroAssembler::EnterExitFrameEpilogue(int argc, bool save_doubles) {
   // Optionally save all XMM registers.
   if (save_doubles) {
-    int space =
-        XMMRegister::kMaxNumRegisters * kSIMD128Size + argc * kPointerSize;
+    int space = XMMRegister::kMaxNumRegisters * kDoubleSize +
+                argc * kPointerSize;
     sub(esp, Immediate(space));
     const int offset = -ExitFrameConstants::kFixedFrameSizeFromFp;
     for (int i = 0; i < XMMRegister::kMaxNumRegisters; i++) {
       XMMRegister reg = XMMRegister::from_code(i);
-      movups(Operand(ebp, offset - ((i + 1) * kSIMD128Size)), reg);
+      movsd(Operand(ebp, offset - ((i + 1) * kDoubleSize)), reg);
     }
   } else {
     sub(esp, Immediate(argc * kPointerSize));
@@ -1208,7 +1208,7 @@ void MacroAssembler::LeaveExitFrame(bool save_doubles, bool pop_arguments) {
     const int offset = -ExitFrameConstants::kFixedFrameSizeFromFp;
     for (int i = 0; i < XMMRegister::kMaxNumRegisters; i++) {
       XMMRegister reg = XMMRegister::from_code(i);
-      movups(reg, Operand(ebp, offset - ((i + 1) * kSIMD128Size)));
+      movsd(reg, Operand(ebp, offset - ((i + 1) * kDoubleSize)));
     }
   }
 
@@ -1799,24 +1799,6 @@ void MacroAssembler::AllocateHeapNumber(Register result,
   mov(FieldOperand(result, HeapObject::kMapOffset), Immediate(map));
 }
 
-#define SIMD128_HEAP_ALLOCATE_FUNCTIONS(V) \
-  V(Float32x4, float32x4)                  \
-  V(Int32x4, int32x4)                      \
-  V(Bool32x4, bool32x4)
-
-#define DECLARE_SIMD_HEAP_ALLOCATE_FUNCTION(Type, type)                        \
-  void MacroAssembler::Allocate##Type(Register result, Register scratch1,      \
-                                      Register scratch2, Label* gc_required) { \
-    /* Allocate SIMD128 object */                                              \
-    Allocate(Type::kSize, result, scratch1, no_reg, gc_required,               \
-             NO_ALLOCATION_FLAGS);                                             \
-    Handle<Map> map = isolate()->factory()->type##_map();                      \
-                                                                               \
-    /*set the map*/                                                            \
-    mov(FieldOperand(result, HeapObject::kMapOffset), Immediate(map));         \
-  }
-
-SIMD128_HEAP_ALLOCATE_FUNCTIONS(DECLARE_SIMD_HEAP_ALLOCATE_FUNCTION)
 
 void MacroAssembler::AllocateTwoByteString(Register result,
                                            Register length,
@@ -3476,72 +3458,6 @@ void MacroAssembler::TruncatingDiv(Register dividend, int32_t divisor) {
   add(edx, eax);
 }
 
-void MacroAssembler::absps(XMMRegister dst) {
-  static const struct V8_ALIGNED(16) {
-    uint32_t a;
-    uint32_t b;
-    uint32_t c;
-    uint32_t d;
-  } float_absolute_constant = {0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF};
-  andps(dst, Operand(reinterpret_cast<int32_t>(&float_absolute_constant),
-                     RelocInfo::NONE32));
-}
-
-void MacroAssembler::abspd(XMMRegister dst) {
-  static const struct V8_ALIGNED(16) {
-    uint32_t a;
-    uint32_t b;
-    uint32_t c;
-    uint32_t d;
-  } double_absolute_constant = {0xFFFFFFFF, 0x7FFFFFFF, 0xFFFFFFFF, 0x7FFFFFFF};
-  andps(dst, Operand(reinterpret_cast<int32_t>(&double_absolute_constant),
-                     RelocInfo::NONE32));
-}
-
-void MacroAssembler::notps(XMMRegister dst) {
-  static const struct V8_ALIGNED(16) {
-    uint32_t a;
-    uint32_t b;
-    uint32_t c;
-    uint32_t d;
-  } float_not_constant = {0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF};
-  xorps(dst, Operand(reinterpret_cast<int32_t>(&float_not_constant),
-                     RelocInfo::NONE32));
-}
-
-void MacroAssembler::negateps(XMMRegister dst) {
-  static const struct V8_ALIGNED(16) {
-    uint32_t a;
-    uint32_t b;
-    uint32_t c;
-    uint32_t d;
-  } float_negate_constant = {0x80000000, 0x80000000, 0x80000000, 0x80000000};
-  xorps(dst, Operand(reinterpret_cast<int32_t>(&float_negate_constant),
-                     RelocInfo::NONE32));
-}
-
-void MacroAssembler::negatepd(XMMRegister dst) {
-  static const struct V8_ALIGNED(16) {
-    uint32_t a;
-    uint32_t b;
-    uint32_t c;
-    uint32_t d;
-  } double_negate_constant = {0x00000000, 0x80000000, 0x00000000, 0x80000000};
-  xorpd(dst, Operand(reinterpret_cast<int32_t>(&double_negate_constant),
-                     RelocInfo::NONE32));
-}
-
-void MacroAssembler::pnegd(XMMRegister dst) {
-  static const struct V8_ALIGNED(16) {
-    uint32_t a;
-    uint32_t b;
-    uint32_t c;
-    uint32_t d;
-  } int32_one_constant = {0x1, 0x1, 0x1, 0x1};
-  notps(dst);
-  paddd(dst, Operand(reinterpret_cast<int32_t>(&int32_one_constant),
-                     RelocInfo::NONE32));
-}
 
 }  // namespace internal
 }  // namespace v8
diff --git a/src/ia32/macro-assembler-ia32.h b/src/ia32/macro-assembler-ia32.h
index c83a44e9d8..91c68d6886 100644
--- a/src/ia32/macro-assembler-ia32.h
+++ b/src/ia32/macro-assembler-ia32.h
@@ -655,19 +655,6 @@ class MacroAssembler: public Assembler {
   void AllocateHeapNumber(Register result, Register scratch1, Register scratch2,
                           Label* gc_required, MutableMode mode = IMMUTABLE);
 
-  // Allocate a float32x4, bool32x4 and int32x4 object in new space with
-  // undefined value.
-  // Returns tagged pointer in result register, or jumps to gc_required if new
-  // space is full.
-  void AllocateFloat32x4(Register result, Register scratch1, Register scratch2,
-                         Label* gc_required);
-
-  void AllocateBool32x4(Register result, Register scratch1, Register scratch2,
-                        Label* gc_required);
-
-  void AllocateInt32x4(Register result, Register scratch1, Register scratch2,
-                       Label* gc_required);
-
   // Allocate a sequential string. All the header fields of the string object
   // are initialized.
   void AllocateTwoByteString(Register result, Register length,
@@ -904,15 +891,6 @@ class MacroAssembler: public Assembler {
   bool has_frame() { return has_frame_; }
   inline bool AllowThisStubCall(CodeStub* stub);
 
-  // ---------------------------------------------------------------------------
-  // SIMD macros.
-  void absps(XMMRegister dst);
-  void abspd(XMMRegister dst);
-  void negateps(XMMRegister dst);
-  void negatepd(XMMRegister dst);
-  void notps(XMMRegister dst);
-  void pnegd(XMMRegister dst);
-
   // ---------------------------------------------------------------------------
   // String utilities.
 
diff --git a/src/interface-descriptors.h b/src/interface-descriptors.h
index 18fc9a87c5..3e64032700 100644
--- a/src/interface-descriptors.h
+++ b/src/interface-descriptors.h
@@ -56,16 +56,6 @@ class PlatformInterfaceDescriptor;
   V(RegExpConstructResult)             \
   V(TransitionElementsKind)            \
   V(AllocateHeapNumber)                \
-  V(AllocateFloat32x4)                 \
-  V(AllocateInt32x4)                   \
-  V(AllocateUint32x4)                  \
-  V(AllocateBool32x4)                  \
-  V(AllocateInt16x8)                   \
-  V(AllocateUint16x8)                  \
-  V(AllocateBool16x8)                  \
-  V(AllocateInt8x16)                   \
-  V(AllocateUint8x16)                  \
-  V(AllocateBool8x16)                  \
   V(ArrayNoArgumentConstructor)        \
   V(ArraySingleArgumentConstructor)    \
   V(ArrayNArgumentsConstructor)        \
@@ -666,13 +656,6 @@ class AllocateHeapNumberDescriptor : public CallInterfaceDescriptor {
   DECLARE_DESCRIPTOR(AllocateHeapNumberDescriptor, CallInterfaceDescriptor)
 };
 
-#define SIMD128_ALLOC_DESC(TYPE, Type, type, lane_count, lane_type)         \
-  class Allocate##Type##Descriptor : public CallInterfaceDescriptor {       \
-   public:                                                                  \
-    DECLARE_DESCRIPTOR(Allocate##Type##Descriptor, CallInterfaceDescriptor) \
-  };
-SIMD128_TYPES(SIMD128_ALLOC_DESC)
-#undef SIMD128_ALLOC_DESC
 
 class ArrayNoArgumentConstructorDescriptor : public CallInterfaceDescriptor {
  public:
diff --git a/src/js/harmony-simd.js b/src/js/harmony-simd.js
index 18057fc279..4df2f437ec 100644
--- a/src/js/harmony-simd.js
+++ b/src/js/harmony-simd.js
@@ -222,19 +222,11 @@ function NAMEGreaterThanOrEqualJS(a, b) {
 }
 
 function NAMELoadJS(tarray, index) {
-  if (NAME == "Float32x4" || NAME == "Int32x4") {
-    return tarray._getTYPEXYZW(index);
-  } else {
-    return %NAMELoad(tarray, index);
-  }
+  return %NAMELoad(tarray, index);
 }
 
 function NAMEStoreJS(tarray, index, a) {
-  if (NAME == "Float32x4" || NAME == "Int32x4") {
-    return tarray._setTYPEXYZW(index, a);
-  } else {
-    return %NAMEStore(tarray, index, a);
-  }
+  return %NAMEStore(tarray, index, a);
 }
 endmacro
 
@@ -342,32 +334,24 @@ SIMD_FROM_BITS_TYPES(DECLARE_FROM_BITS_FUNCTIONS)
 
 
 macro SIMD_LOADN_STOREN_TYPES(FUNCTION)
-FUNCTION(Float32x4, 1, X)
-FUNCTION(Float32x4, 2, XY)
-FUNCTION(Float32x4, 3, XYZ)
-FUNCTION(Int32x4, 1, X)
-FUNCTION(Int32x4, 2, XY)
-FUNCTION(Int32x4, 3, XYZ)
-FUNCTION(Uint32x4, 1, X)
-FUNCTION(Uint32x4, 2, XY)
-FUNCTION(Uint32x4, 3, XYZ)
-endmacro
-
-macro DECLARE_LOADN_STOREN_FUNCTIONS(NAME, COUNT, LANES)
+FUNCTION(Float32x4, 1)
+FUNCTION(Float32x4, 2)
+FUNCTION(Float32x4, 3)
+FUNCTION(Int32x4, 1)
+FUNCTION(Int32x4, 2)
+FUNCTION(Int32x4, 3)
+FUNCTION(Uint32x4, 1)
+FUNCTION(Uint32x4, 2)
+FUNCTION(Uint32x4, 3)
+endmacro
+
+macro DECLARE_LOADN_STOREN_FUNCTIONS(NAME, COUNT)
 function NAMELoadCOUNTJS(tarray, index) {
-  if (NAME == "Float32x4" || NAME == "Int32x4") {
-    return tarray._getTYPELANES(index);
-  } else {
-    return %NAMELoadCOUNT(tarray, index);
-  }
+  return %NAMELoadCOUNT(tarray, index);
 }
 
 function NAMEStoreCOUNTJS(tarray, index, a) {
-  if (NAME == "Float32x4" || NAME == "Int32x4") {
-    return tarray._setTYPELANES(index, a);
-  } else {
-    return %NAMEStoreCOUNT(tarray, index, a);
-  }
+  return %NAMEStoreCOUNT(tarray, index, a);
 }
 endmacro
 
@@ -953,112 +937,5 @@ utils.Export(function(to) {
   to.Uint8x16ToString = Uint8x16ToString;
   to.Bool8x16ToString = Bool8x16ToString;
 });
-// --------------------SIMD128 Access in Typed Array -----------------
-var $Uint8Array = global.Uint8Array;
-var $Int8Array = global.Int8Array;
-var $Uint16Array = global.Uint16Array;
-var $Int16Array = global.Int16Array;
-var $Uint32Array = global.Uint32Array;
-var $Int32Array = global.Int32Array;
-var $Float32Array = global.Float32Array;
-var $Float64Array = global.Float64Array;
-
-macro DECLARE_TYPED_ARRAY_SIMD_LOAD_AND_STORE_FUNCTION(VIEW, TYPE, TYPENAME, LANES, NBYTES)
-function VIEWGetTYPELANESJS(index) {
-  if (!(%_ClassOf(this) === 'VIEW')) {
-    throw MakeTypeError('incompatible_method_receiver',
-                        ["VIEW._getTYPELANES", this]);
-  }
-  var tarray = this;
-  if (arguments.length < 1) {
-    throw MakeTypeError('invalid_argument');
-  }
-  if (!IS_NUMBER(index)) {
-    throw MakeTypeError('The 2nd argument must be a Number.');
-  }
-  var offset = TO_INTEGER(index) * tarray.BYTES_PER_ELEMENT + tarray.byteOffset;
-  if (offset < tarray.byteOffset || (offset + NBYTES) > (tarray.byteLength + tarray.byteOffset))
-    throw MakeRangeError('The value of index is invalid.');
-  var arraybuffer = tarray.buffer;
-  return %TYPELoadLANES(arraybuffer, offset);
-}
-
-function VIEWSetTYPELANESJS(index, value) {
-  if (!(%_ClassOf(this) === 'VIEW')) {
-    throw MakeTypeError('incompatible_method_receiver',
-                        ["VIEW._setTYPELANES", this]);
-  }
-  var tarray = this;
-  if (arguments.length < 2) {
-    throw MakeTypeError('invalid_argument');
-  }
-  if (!IS_NUMBER(index)) {
-    throw MakeTypeError('The 2nd argument must be a Number.');
-  }
-
-  if (typeof(value) !== 'TYPENAME') {
-     throw MakeTypeError(kInvalidArgument);
-  }
-  var offset = TO_INTEGER(index) * tarray.BYTES_PER_ELEMENT + tarray.byteOffset;
-  if (offset < tarray.byteOffset || (offset + NBYTES) > (tarray.byteLength + tarray.byteOffset))
-    throw MakeRangeError('The value of index is invalid.');
-  var arraybuffer = tarray.buffer;
-  %TYPEStoreLANES(arraybuffer, offset, value);
-}
-endmacro
-
-macro DECLARE_VIEW_SIMD_LOAD_AND_STORE_FUNCTION(VIEW)
-DECLARE_TYPED_ARRAY_SIMD_LOAD_AND_STORE_FUNCTION(VIEW, Float32x4, float32x4, XYZW, 16)
-DECLARE_TYPED_ARRAY_SIMD_LOAD_AND_STORE_FUNCTION(VIEW, Float32x4, float32x4, XYZ, 12)
-DECLARE_TYPED_ARRAY_SIMD_LOAD_AND_STORE_FUNCTION(VIEW, Float32x4, float32x4, XY, 8)
-DECLARE_TYPED_ARRAY_SIMD_LOAD_AND_STORE_FUNCTION(VIEW, Float32x4, float32x4, X, 4)
-DECLARE_TYPED_ARRAY_SIMD_LOAD_AND_STORE_FUNCTION(VIEW, Int32x4, int32x4, XYZW, 16)
-DECLARE_TYPED_ARRAY_SIMD_LOAD_AND_STORE_FUNCTION(VIEW, Int32x4, int32x4, XYZ, 12)
-DECLARE_TYPED_ARRAY_SIMD_LOAD_AND_STORE_FUNCTION(VIEW, Int32x4, int32x4, XY, 8)
-DECLARE_TYPED_ARRAY_SIMD_LOAD_AND_STORE_FUNCTION(VIEW, Int32x4, int32x4, X, 4)
-endmacro
-
-DECLARE_VIEW_SIMD_LOAD_AND_STORE_FUNCTION(Uint8Array)
-DECLARE_VIEW_SIMD_LOAD_AND_STORE_FUNCTION(Int8Array)
-DECLARE_VIEW_SIMD_LOAD_AND_STORE_FUNCTION(Uint16Array)
-DECLARE_VIEW_SIMD_LOAD_AND_STORE_FUNCTION(Int16Array)
-DECLARE_VIEW_SIMD_LOAD_AND_STORE_FUNCTION(Uint32Array)
-DECLARE_VIEW_SIMD_LOAD_AND_STORE_FUNCTION(Int32Array)
-DECLARE_VIEW_SIMD_LOAD_AND_STORE_FUNCTION(Float32Array)
-DECLARE_VIEW_SIMD_LOAD_AND_STORE_FUNCTION(Float64Array)
-
-function SetupTypedArraysSimdLoadStore() {
-macro DECLARE_INSTALL_SIMD_LOAD_AND_STORE_FUNCTION(VIEW)
-  utils.InstallFunctions($VIEW.prototype, DONT_ENUM, [
-      "_getFloat32x4X", VIEWGetFloat32x4XJS,
-      "_setFloat32x4X", VIEWSetFloat32x4XJS,
-      "_getFloat32x4XY", VIEWGetFloat32x4XYJS,
-      "_setFloat32x4XY", VIEWSetFloat32x4XYJS,
-      "_getFloat32x4XYZ", VIEWGetFloat32x4XYZJS,
-      "_setFloat32x4XYZ", VIEWSetFloat32x4XYZJS,
-      "_getFloat32x4XYZW", VIEWGetFloat32x4XYZWJS,
-      "_setFloat32x4XYZW", VIEWSetFloat32x4XYZWJS,
-      "_getInt32x4X", VIEWGetInt32x4XJS,
-      "_setInt32x4X", VIEWSetInt32x4XJS,
-      "_getInt32x4XY", VIEWGetInt32x4XYJS,
-      "_setInt32x4XY", VIEWSetInt32x4XYJS,
-      "_getInt32x4XYZ", VIEWGetInt32x4XYZJS,
-      "_setInt32x4XYZ", VIEWSetInt32x4XYZJS,
-      "_getInt32x4XYZW", VIEWGetInt32x4XYZWJS,
-      "_setInt32x4XYZW", VIEWSetInt32x4XYZWJS
-  ]);
-endmacro
-
-DECLARE_INSTALL_SIMD_LOAD_AND_STORE_FUNCTION(Uint8Array)
-DECLARE_INSTALL_SIMD_LOAD_AND_STORE_FUNCTION(Int8Array)
-DECLARE_INSTALL_SIMD_LOAD_AND_STORE_FUNCTION(Uint16Array)
-DECLARE_INSTALL_SIMD_LOAD_AND_STORE_FUNCTION(Int16Array)
-DECLARE_INSTALL_SIMD_LOAD_AND_STORE_FUNCTION(Uint32Array)
-DECLARE_INSTALL_SIMD_LOAD_AND_STORE_FUNCTION(Int32Array)
-DECLARE_INSTALL_SIMD_LOAD_AND_STORE_FUNCTION(Float32Array)
-DECLARE_INSTALL_SIMD_LOAD_AND_STORE_FUNCTION(Float64Array)
-}
-
-SetupTypedArraysSimdLoadStore();
 
 })
diff --git a/src/js/macros.py b/src/js/macros.py
index c6ed019dd6..a76231911a 100644
--- a/src/js/macros.py
+++ b/src/js/macros.py
@@ -85,7 +85,6 @@ macro IS_SCRIPT(arg)            = (%_ClassOf(arg) === 'Script');
 macro IS_SET(arg)               = (%_ClassOf(arg) === 'Set');
 macro IS_SET_ITERATOR(arg)      = (%_ClassOf(arg) === 'Set Iterator');
 macro IS_SHAREDARRAYBUFFER(arg) = (%_ClassOf(arg) === 'SharedArrayBuffer');
-macro IS_SIMD_VALUE(arg)        = (%IsSimdValue(arg));
 macro IS_STRING(arg)            = (typeof(arg) === 'string');
 macro IS_STRING_WRAPPER(arg)    = (%_ClassOf(arg) === 'String');
 macro IS_SYMBOL(arg)            = (typeof(arg) === 'symbol');
diff --git a/src/js/messages.js b/src/js/messages.js
index 24d8d2bfa1..8e339e6526 100644
--- a/src/js/messages.js
+++ b/src/js/messages.js
@@ -116,20 +116,6 @@ function NoSideEffectsToString(obj) {
     return str;
   }
   if (IS_SYMBOL(obj)) return %_Call(SymbolToString, obj);
-  if (IS_SIMD_VALUE(obj)) {
-    switch (typeof(obj)) {
-      case 'float32x4': return %_Call(Float32x4ToString, obj);
-      case 'int32x4':   return %_Call(Int32x4ToString, obj);
-      case 'int16x8':   return %_Call(Int16x8ToString, obj);
-      case 'int8x16':   return %_Call(Int8x16ToString, obj);
-      case 'uint32x4':   return %_Call(Uint32x4ToString, obj);
-      case 'uint16x8':   return %_Call(Uint16x8ToString, obj);
-      case 'uint8x16':   return %_Call(Uint8x16ToString, obj);
-      case 'bool32x4':  return %_Call(Bool32x4ToString, obj);
-      case 'bool16x8':  return %_Call(Bool16x8ToString, obj);
-      case 'bool8x16':  return %_Call(Bool8x16ToString, obj);
-    }
-  }
 
   if (IS_RECEIVER(obj)) {
     // When internally formatting error objects, use a side-effects-free version
diff --git a/src/json-stringifier.cc b/src/json-stringifier.cc
index 29685c20e2..c718812004 100644
--- a/src/json-stringifier.cc
+++ b/src/json-stringifier.cc
@@ -323,7 +323,6 @@ JsonStringifier::Result JsonStringifier::Serialize_(Handle<Object> object,
     case JS_VALUE_TYPE:
       if (deferred_string_key) SerializeDeferredKey(comma, key);
       return SerializeJSValue(Handle<JSValue>::cast(object));
-    case SIMD128_VALUE_TYPE:
     case SYMBOL_TYPE:
       return UNCHANGED;
     default:
diff --git a/src/messages.h b/src/messages.h
index 9379796726..682105d5d6 100644
--- a/src/messages.h
+++ b/src/messages.h
@@ -352,7 +352,6 @@ class CallSite {
   T(TypedArraySetSourceTooLarge, "Source is too large")                        \
   T(UnsupportedTimeZone, "Unsupported time zone specified %")                  \
   T(ValueOutOfRange, "Value % out of range for % options property %")          \
-  T(InvalidOffset, "invalid_offset")                                           \
   /* SyntaxError */                                                            \
   T(BadGetterArity, "Getter must not have any formal parameters.")             \
   T(BadSetterArity, "Setter must have exactly one formal parameter.")          \
diff --git a/src/mips/assembler-mips-inl.h b/src/mips/assembler-mips-inl.h
index 6d1b42efbc..57aea3898c 100644
--- a/src/mips/assembler-mips-inl.h
+++ b/src/mips/assembler-mips-inl.h
@@ -48,7 +48,7 @@ namespace internal {
 
 
 bool CpuFeatures::SupportsCrankshaft() { return IsSupported(FPU); }
-bool CpuFeatures::SupportsSIMD128InCrankshaft() { return false; }
+
 
 // -----------------------------------------------------------------------------
 // Operand and MemOperand.
diff --git a/src/mips/assembler-mips.h b/src/mips/assembler-mips.h
index 95c046bf8d..8f4f9d90e2 100644
--- a/src/mips/assembler-mips.h
+++ b/src/mips/assembler-mips.h
@@ -308,20 +308,6 @@ struct FPUControlRegister {
 const FPUControlRegister no_fpucreg = { kInvalidFPUControlRegister };
 const FPUControlRegister FCSR = { kFCSRRegister };
 
-struct SIMD128Register {
-  static const int kMaxNumRegisters = 0;
-
-  static int ToAllocationIndex(SIMD128Register reg) {
-    UNIMPLEMENTED();
-    return -1;
-  }
-
-  static const char* AllocationIndexToString(int index) {
-    UNIMPLEMENTED();
-    return NULL;
-  }
-};
-
 // -----------------------------------------------------------------------------
 // Machine instruction Operands.
 
diff --git a/src/mips/deoptimizer-mips.cc b/src/mips/deoptimizer-mips.cc
index 29e87be278..478b9dfe30 100644
--- a/src/mips/deoptimizer-mips.cc
+++ b/src/mips/deoptimizer-mips.cc
@@ -98,8 +98,6 @@ void Deoptimizer::CopyDoubleRegisters(FrameDescription* output_frame) {
   }
 }
 
-void Deoptimizer::CopySIMD128Registers(FrameDescription* output_frame) {}
-
 #define __ masm()->
 
 
@@ -385,34 +383,6 @@ void FrameDescription::SetCallerConstantPool(unsigned offset, intptr_t value) {
   UNREACHABLE();
 }
 
-double RegisterValues::GetDoubleRegister(unsigned n) const {
-  DCHECK(n < arraysize(double_registers_));
-  return double_registers_[n];
-}
-
-void RegisterValues::SetDoubleRegister(unsigned n, double value) {
-  DCHECK(n < arraysize(double_registers_));
-  double_registers_[n] = value;
-}
-
-simd128_value_t RegisterValues::GetSIMD128Register(unsigned n) const {
-  UNREACHABLE();
-  simd128_value_t value;
-  return value;
-}
-
-void RegisterValues::SetSIMD128Register(unsigned n, simd128_value_t value) {
-  UNREACHABLE();
-}
-
-int FrameDescription::double_registers_offset() {
-  return OFFSET_OF(FrameDescription, register_values_.double_registers_);
-}
-
-int FrameDescription::simd128_registers_offset() {
-  UNREACHABLE();
-  return -1;
-}
 
 #undef __
 
diff --git a/src/objects-body-descriptors-inl.h b/src/objects-body-descriptors-inl.h
index cfa945dd6f..a32bbc697c 100644
--- a/src/objects-body-descriptors-inl.h
+++ b/src/objects-body-descriptors-inl.h
@@ -509,7 +509,6 @@ ReturnType BodyDescriptorApply(InstanceType type, T1 p1, T2 p2, T3 p3) {
 
     case HEAP_NUMBER_TYPE:
     case MUTABLE_HEAP_NUMBER_TYPE:
-    case SIMD128_VALUE_TYPE:
     case FILLER_TYPE:
     case BYTE_ARRAY_TYPE:
     case FREE_SPACE_TYPE:
diff --git a/src/objects-debug.cc b/src/objects-debug.cc
index d3d13d4586..23418ffb55 100644
--- a/src/objects-debug.cc
+++ b/src/objects-debug.cc
@@ -62,9 +62,6 @@ void HeapObject::HeapObjectVerify() {
     case MUTABLE_HEAP_NUMBER_TYPE:
       HeapNumber::cast(this)->HeapNumberVerify();
       break;
-    case SIMD128_VALUE_TYPE:
-      Simd128Value::cast(this)->Simd128ValueVerify();
-      break;
     case FIXED_ARRAY_TYPE:
       FixedArray::cast(this)->FixedArrayVerify();
       break;
@@ -222,9 +219,6 @@ void HeapNumber::HeapNumberVerify() {
 }
 
 
-void Simd128Value::Simd128ValueVerify() { CHECK(IsSimd128Value()); }
-
-
 void ByteArray::ByteArrayVerify() {
   CHECK(IsByteArray());
 }
diff --git a/src/objects-inl.h b/src/objects-inl.h
index 58441d3853..061f0f7ee0 100644
--- a/src/objects-inl.h
+++ b/src/objects-inl.h
@@ -149,12 +149,6 @@ bool HeapObject::IsExternal() const {
 TYPE_CHECKER(HeapNumber, HEAP_NUMBER_TYPE)
 TYPE_CHECKER(MutableHeapNumber, MUTABLE_HEAP_NUMBER_TYPE)
 TYPE_CHECKER(Symbol, SYMBOL_TYPE)
-TYPE_CHECKER(Simd128Value, SIMD128_VALUE_TYPE)
-
-#define SIMD128_TYPE_CHECKER(TYPE, Type, type, lane_count, lane_type) \
-  bool HeapObject::Is##Type() const { return map() == GetHeap()->type##_map(); }
-SIMD128_TYPES(SIMD128_TYPE_CHECKER)
-#undef SIMD128_TYPE_CHECKER
 
 #define IS_TYPE_FUNCTION_DEF(type_)                               \
   bool Object::Is##type_() const {                                \
@@ -1414,109 +1408,6 @@ int HeapNumber::get_sign() {
 }
 
 
-bool Simd128Value::Equals(Simd128Value* that) {
-  // TODO(bmeurer): This doesn't match the SIMD.js specification, but it seems
-  // to be consistent with what the CompareICStub does, and what is tested in
-  // the current SIMD.js testsuite.
-  if (this == that) return true;
-#define SIMD128_VALUE(TYPE, Type, type, lane_count, lane_type) \
-  if (this->Is##Type()) {                                      \
-    if (!that->Is##Type()) return false;                       \
-    return Type::cast(this)->Equals(Type::cast(that));         \
-  }
-  SIMD128_TYPES(SIMD128_VALUE)
-#undef SIMD128_VALUE
-  return false;
-}
-
-
-// static
-bool Simd128Value::Equals(Handle<Simd128Value> one, Handle<Simd128Value> two) {
-  return one->Equals(*two);
-}
-
-
-#define SIMD128_VALUE_EQUALS(TYPE, Type, type, lane_count, lane_type) \
-  bool Type::Equals(Type* that) {                                     \
-    for (int lane = 0; lane < lane_count; ++lane) {                   \
-      if (this->get_lane(lane) != that->get_lane(lane)) return false; \
-    }                                                                 \
-    return true;                                                      \
-  }
-SIMD128_TYPES(SIMD128_VALUE_EQUALS)
-#undef SIMD128_VALUE_EQUALS
-
-
-#if defined(V8_TARGET_LITTLE_ENDIAN)
-#define SIMD128_READ_LANE(lane_type, lane_count, field_type, field_size) \
-  lane_type value =                                                      \
-      READ_##field_type##_FIELD(this, kValueOffset + lane * field_size);
-#elif defined(V8_TARGET_BIG_ENDIAN)
-#define SIMD128_READ_LANE(lane_type, lane_count, field_type, field_size) \
-  lane_type value = READ_##field_type##_FIELD(                           \
-      this, kValueOffset + (lane_count - lane - 1) * field_size);
-#else
-#error Unknown byte ordering
-#endif
-
-#if defined(V8_TARGET_LITTLE_ENDIAN)
-#define SIMD128_WRITE_LANE(lane_count, field_type, field_size, value) \
-  WRITE_##field_type##_FIELD(this, kValueOffset + lane * field_size, value);
-#elif defined(V8_TARGET_BIG_ENDIAN)
-#define SIMD128_WRITE_LANE(lane_count, field_type, field_size, value) \
-  WRITE_##field_type##_FIELD(                                         \
-      this, kValueOffset + (lane_count - lane - 1) * field_size, value);
-#else
-#error Unknown byte ordering
-#endif
-
-#define SIMD128_NUMERIC_LANE_FNS(type, lane_type, lane_count, field_type, \
-                                 field_size)                              \
-  lane_type type::get_lane(int lane) const {                              \
-    DCHECK(lane < lane_count && lane >= 0);                               \
-    SIMD128_READ_LANE(lane_type, lane_count, field_type, field_size)      \
-    return value;                                                         \
-  }                                                                       \
-                                                                          \
-  void type::set_lane(int lane, lane_type value) {                        \
-    DCHECK(lane < lane_count && lane >= 0);                               \
-    SIMD128_WRITE_LANE(lane_count, field_type, field_size, value)         \
-  }
-
-SIMD128_NUMERIC_LANE_FNS(Float32x4, float, 4, FLOAT, kFloatSize)
-SIMD128_NUMERIC_LANE_FNS(Int32x4, int32_t, 4, INT32, kInt32Size)
-SIMD128_NUMERIC_LANE_FNS(Uint32x4, uint32_t, 4, UINT32, kInt32Size)
-SIMD128_NUMERIC_LANE_FNS(Int16x8, int16_t, 8, INT16, kShortSize)
-SIMD128_NUMERIC_LANE_FNS(Uint16x8, uint16_t, 8, UINT16, kShortSize)
-SIMD128_NUMERIC_LANE_FNS(Int8x16, int8_t, 16, INT8, kCharSize)
-SIMD128_NUMERIC_LANE_FNS(Uint8x16, uint8_t, 16, UINT8, kCharSize)
-#undef SIMD128_NUMERIC_LANE_FNS
-
-
-#define SIMD128_BOOLEAN_LANE_FNS(type, lane_type, lane_count, field_type, \
-                                 field_size)                              \
-  bool type::get_lane(int lane) const {                                   \
-    DCHECK(lane < lane_count && lane >= 0);                               \
-    SIMD128_READ_LANE(lane_type, lane_count, field_type, field_size)      \
-    DCHECK(value == 0 || value == -1);                                    \
-    return value != 0;                                                    \
-  }                                                                       \
-                                                                          \
-  void type::set_lane(int lane, bool value) {                             \
-    DCHECK(lane < lane_count && lane >= 0);                               \
-    int32_t int_val = value ? -1 : 0;                                     \
-    SIMD128_WRITE_LANE(lane_count, field_type, field_size, int_val)       \
-  }
-
-SIMD128_BOOLEAN_LANE_FNS(Bool32x4, int32_t, 4, INT32, kInt32Size)
-SIMD128_BOOLEAN_LANE_FNS(Bool16x8, int16_t, 8, INT16, kShortSize)
-SIMD128_BOOLEAN_LANE_FNS(Bool8x16, int8_t, 16, INT8, kCharSize)
-#undef SIMD128_BOOLEAN_LANE_FNS
-
-#undef SIMD128_READ_LANE
-#undef SIMD128_WRITE_LANE
-
-
 ACCESSORS(JSReceiver, properties, FixedArray, kPropertiesOffset)
 
 
@@ -2290,7 +2181,7 @@ void Object::VerifyApiCallResultType() {
   DCHECK(IsHeapObject());
   Isolate* isolate = HeapObject::cast(this)->GetIsolate();
   if (!(IsString() || IsSymbol() || IsJSReceiver() || IsHeapNumber() ||
-        IsSimd128Value() || IsUndefined(isolate) || IsTrue(isolate) ||
+        IsUndefined(isolate) || IsTrue(isolate) ||
         IsFalse(isolate) || IsNull(isolate))) {
     FATAL("API call returned invalid object");
   }
@@ -2496,7 +2387,6 @@ AllocationAlignment HeapObject::RequiredAlignment() {
     return kDoubleAligned;
   }
   if (IsHeapNumber()) return kDoubleUnaligned;
-  if (IsSimd128Value()) return kSimd128Unaligned;
 #endif  // V8_HOST_ARCH_32_BIT
   return kWordAligned;
 }
@@ -3139,9 +3029,6 @@ void SeededNumberDictionary::set_requires_slow_elements() {
 
 CAST_ACCESSOR(AbstractCode)
 CAST_ACCESSOR(ArrayList)
-CAST_ACCESSOR(Bool16x8)
-CAST_ACCESSOR(Bool32x4)
-CAST_ACCESSOR(Bool8x16)
 CAST_ACCESSOR(ByteArray)
 CAST_ACCESSOR(BytecodeArray)
 CAST_ACCESSOR(Cell)
@@ -3160,14 +3047,10 @@ CAST_ACCESSOR(FixedArray)
 CAST_ACCESSOR(FixedArrayBase)
 CAST_ACCESSOR(FixedDoubleArray)
 CAST_ACCESSOR(FixedTypedArrayBase)
-CAST_ACCESSOR(Float32x4)
 CAST_ACCESSOR(Foreign)
 CAST_ACCESSOR(GlobalDictionary)
 CAST_ACCESSOR(HandlerTable)
 CAST_ACCESSOR(HeapObject)
-CAST_ACCESSOR(Int16x8)
-CAST_ACCESSOR(Int32x4)
-CAST_ACCESSOR(Int8x16)
 CAST_ACCESSOR(JSArray)
 CAST_ACCESSOR(JSArrayBuffer)
 CAST_ACCESSOR(JSArrayBufferView)
@@ -3209,7 +3092,6 @@ CAST_ACCESSOR(SeqOneByteString)
 CAST_ACCESSOR(SeqString)
 CAST_ACCESSOR(SeqTwoByteString)
 CAST_ACCESSOR(SharedFunctionInfo)
-CAST_ACCESSOR(Simd128Value)
 CAST_ACCESSOR(SlicedString)
 CAST_ACCESSOR(Smi)
 CAST_ACCESSOR(String)
@@ -3217,9 +3099,6 @@ CAST_ACCESSOR(StringSet)
 CAST_ACCESSOR(StringTable)
 CAST_ACCESSOR(Struct)
 CAST_ACCESSOR(Symbol)
-CAST_ACCESSOR(Uint16x8)
-CAST_ACCESSOR(Uint32x4)
-CAST_ACCESSOR(Uint8x16)
 CAST_ACCESSOR(UnseededNumberDictionary)
 CAST_ACCESSOR(WeakCell)
 CAST_ACCESSOR(WeakFixedArray)
diff --git a/src/objects.cc b/src/objects.cc
index 6bcc8892d5..82ca47cc43 100644
--- a/src/objects.cc
+++ b/src/objects.cc
@@ -146,10 +146,6 @@ MaybeHandle<Object> Object::ToNumber(Handle<Object> input) {
       THROW_NEW_ERROR(isolate, NewTypeError(MessageTemplate::kSymbolToNumber),
                       Object);
     }
-    if (input->IsSimd128Value()) {
-      THROW_NEW_ERROR(isolate, NewTypeError(MessageTemplate::kSimdToNumber),
-                      Object);
-    }
     ASSIGN_RETURN_ON_EXCEPTION(
         isolate, input, JSReceiver::ToPrimitive(Handle<JSReceiver>::cast(input),
                                                 ToPrimitiveHint::kNumber),
@@ -205,9 +201,6 @@ MaybeHandle<String> Object::ToString(Isolate* isolate, Handle<Object> input) {
       THROW_NEW_ERROR(isolate, NewTypeError(MessageTemplate::kSymbolToString),
                       String);
     }
-    if (input->IsSimd128Value()) {
-      return Simd128Value::ToString(Handle<Simd128Value>::cast(input));
-    }
     ASSIGN_RETURN_ON_EXCEPTION(
         isolate, input, JSReceiver::ToPrimitive(Handle<JSReceiver>::cast(input),
                                                 ToPrimitiveHint::kString),
@@ -367,18 +360,6 @@ Maybe<bool> Object::Equals(Handle<Object> x, Handle<Object> y) {
       } else {
         return Just(false);
       }
-    } else if (x->IsSimd128Value()) {
-      if (y->IsSimd128Value()) {
-        return Just(Simd128Value::Equals(Handle<Simd128Value>::cast(x),
-                                         Handle<Simd128Value>::cast(y)));
-      } else if (y->IsJSReceiver()) {
-        if (!JSReceiver::ToPrimitive(Handle<JSReceiver>::cast(y))
-                 .ToHandle(&y)) {
-          return Nothing<bool>();
-        }
-      } else {
-        return Just(false);
-      }
     } else if (x->IsJSReceiver()) {
       if (y->IsJSReceiver()) {
         return Just(x.is_identical_to(y));
@@ -404,9 +385,6 @@ bool Object::StrictEquals(Object* that) {
   } else if (this->IsString()) {
     if (!that->IsString()) return false;
     return String::cast(this)->Equals(String::cast(that));
-  } else if (this->IsSimd128Value()) {
-    if (!that->IsSimd128Value()) return false;
-    return Simd128Value::cast(this)->Equals(Simd128Value::cast(that));
   }
   return this == that;
 }
@@ -422,10 +400,6 @@ Handle<String> Object::TypeOf(Isolate* isolate, Handle<Object> object) {
   if (object->IsString()) return isolate->factory()->string_string();
   if (object->IsSymbol()) return isolate->factory()->symbol_string();
   if (object->IsString()) return isolate->factory()->string_string();
-#define SIMD128_TYPE(TYPE, Type, type, lane_count, lane_type) \
-  if (object->Is##Type()) return isolate->factory()->type##_string();
-  SIMD128_TYPES(SIMD128_TYPE)
-#undef SIMD128_TYPE
   if (object->IsCallable()) return isolate->factory()->function_string();
   return isolate->factory()->object_string();
 }
@@ -1711,10 +1685,6 @@ Object* GetSimpleHash(Object* object) {
     uint32_t hash = Oddball::cast(object)->to_string()->Hash();
     return Smi::FromInt(hash);
   }
-  if (object->IsSimd128Value()) {
-    uint32_t hash = Simd128Value::cast(object)->Hash();
-    return Smi::FromInt(hash & Smi::kMaxValue);
-  }
   DCHECK(object->IsJSReceiver());
   // Simply return the receiver as it is guaranteed to not be a SMI.
   return object;
@@ -1761,23 +1731,6 @@ bool Object::SameValue(Object* other) {
   if (IsString() && other->IsString()) {
     return String::cast(this)->Equals(String::cast(other));
   }
-  if (IsFloat32x4() && other->IsFloat32x4()) {
-    Float32x4* a = Float32x4::cast(this);
-    Float32x4* b = Float32x4::cast(other);
-    for (int i = 0; i < 4; i++) {
-      float x = a->get_lane(i);
-      float y = b->get_lane(i);
-      // Implements the ES5 SameValue operation for floating point types.
-      // http://www.ecma-international.org/ecma-262/6.0/#sec-samevalue
-      if (x != y && !(std::isnan(x) && std::isnan(y))) return false;
-      if (std::signbit(x) != std::signbit(y)) return false;
-    }
-    return true;
-  } else if (IsSimd128Value() && other->IsSimd128Value()) {
-    Simd128Value* a = Simd128Value::cast(this);
-    Simd128Value* b = Simd128Value::cast(other);
-    return a->map() == b->map() && a->BitwiseEquals(b);
-  }
   return false;
 }
 
@@ -1797,23 +1750,6 @@ bool Object::SameValueZero(Object* other) {
   if (IsString() && other->IsString()) {
     return String::cast(this)->Equals(String::cast(other));
   }
-  if (IsFloat32x4() && other->IsFloat32x4()) {
-    Float32x4* a = Float32x4::cast(this);
-    Float32x4* b = Float32x4::cast(other);
-    for (int i = 0; i < 4; i++) {
-      float x = a->get_lane(i);
-      float y = b->get_lane(i);
-      // Implements the ES6 SameValueZero operation for floating point types.
-      // http://www.ecma-international.org/ecma-262/6.0/#sec-samevaluezero
-      if (x != y && !(std::isnan(x) && std::isnan(y))) return false;
-      // SameValueZero doesn't distinguish between 0 and -0.
-    }
-    return true;
-  } else if (IsSimd128Value() && other->IsSimd128Value()) {
-    Simd128Value* a = Simd128Value::cast(this);
-    Simd128Value* b = Simd128Value::cast(other);
-    return a->map() == b->map() && a->BitwiseEquals(b);
-  }
   return false;
 }
 
@@ -2515,17 +2451,6 @@ void HeapObject::HeapObjectShortPrint(std::ostream& os) {  // NOLINT
       os << '>';
       break;
     }
-    case SIMD128_VALUE_TYPE: {
-#define SIMD128_TYPE(TYPE, Type, type, lane_count, lane_type) \
-  if (Is##Type()) {                                           \
-    os << "<" #Type ">";                                      \
-    break;                                                    \
-  }
-      SIMD128_TYPES(SIMD128_TYPE)
-#undef SIMD128_TYPE
-      UNREACHABLE();
-      break;
-    }
     case JS_PROXY_TYPE:
       os << "<JSProxy>";
       break;
@@ -2617,100 +2542,6 @@ void HeapNumber::HeapNumberPrint(std::ostream& os) {  // NOLINT
   (*reinterpret_cast<const byte*>(FIELD_ADDR_CONST(p, offset)))
 
 
-// static
-Handle<String> Simd128Value::ToString(Handle<Simd128Value> input) {
-#define SIMD128_TYPE(TYPE, Type, type, lane_count, lane_type) \
-  if (input->Is##Type()) return Type::ToString(Handle<Type>::cast(input));
-  SIMD128_TYPES(SIMD128_TYPE)
-#undef SIMD128_TYPE
-  UNREACHABLE();
-  return Handle<String>::null();
-}
-
-
-// static
-Handle<String> Float32x4::ToString(Handle<Float32x4> input) {
-  Isolate* const isolate = input->GetIsolate();
-  char arr[100];
-  Vector<char> buffer(arr, arraysize(arr));
-  std::ostringstream os;
-  os << "SIMD.Float32x4("
-     << std::string(DoubleToCString(input->get_lane(0), buffer)) << ", "
-     << std::string(DoubleToCString(input->get_lane(1), buffer)) << ", "
-     << std::string(DoubleToCString(input->get_lane(2), buffer)) << ", "
-     << std::string(DoubleToCString(input->get_lane(3), buffer)) << ")";
-  return isolate->factory()->NewStringFromAsciiChecked(os.str().c_str());
-}
-
-
-#define SIMD128_BOOL_TO_STRING(Type, lane_count)                            \
-  Handle<String> Type::ToString(Handle<Type> input) {                       \
-    Isolate* const isolate = input->GetIsolate();                           \
-    std::ostringstream os;                                                  \
-    os << "SIMD." #Type "(";                                                \
-    os << (input->get_lane(0) ? "true" : "false");                          \
-    for (int i = 1; i < lane_count; i++) {                                  \
-      os << ", " << (input->get_lane(i) ? "true" : "false");                \
-    }                                                                       \
-    os << ")";                                                              \
-    return isolate->factory()->NewStringFromAsciiChecked(os.str().c_str()); \
-  }
-SIMD128_BOOL_TO_STRING(Bool32x4, 4)
-SIMD128_BOOL_TO_STRING(Bool16x8, 8)
-SIMD128_BOOL_TO_STRING(Bool8x16, 16)
-#undef SIMD128_BOOL_TO_STRING
-
-
-#define SIMD128_INT_TO_STRING(Type, lane_count)                             \
-  Handle<String> Type::ToString(Handle<Type> input) {                       \
-    Isolate* const isolate = input->GetIsolate();                           \
-    char arr[100];                                                          \
-    Vector<char> buffer(arr, arraysize(arr));                               \
-    std::ostringstream os;                                                  \
-    os << "SIMD." #Type "(";                                                \
-    os << IntToCString(input->get_lane(0), buffer);                         \
-    for (int i = 1; i < lane_count; i++) {                                  \
-      os << ", " << IntToCString(input->get_lane(i), buffer);               \
-    }                                                                       \
-    os << ")";                                                              \
-    return isolate->factory()->NewStringFromAsciiChecked(os.str().c_str()); \
-  }
-SIMD128_INT_TO_STRING(Int32x4, 4)
-SIMD128_INT_TO_STRING(Uint32x4, 4)
-SIMD128_INT_TO_STRING(Int16x8, 8)
-SIMD128_INT_TO_STRING(Uint16x8, 8)
-SIMD128_INT_TO_STRING(Int8x16, 16)
-SIMD128_INT_TO_STRING(Uint8x16, 16)
-#undef SIMD128_INT_TO_STRING
-
-
-bool Simd128Value::BitwiseEquals(const Simd128Value* other) const {
-  return READ_INT64_FIELD(this, kValueOffset) ==
-             READ_INT64_FIELD(other, kValueOffset) &&
-         READ_INT64_FIELD(this, kValueOffset + kInt64Size) ==
-             READ_INT64_FIELD(other, kValueOffset + kInt64Size);
-}
-
-
-uint32_t Simd128Value::Hash() const {
-  uint32_t seed = v8::internal::kZeroHashSeed;
-  uint32_t hash;
-  hash = ComputeIntegerHash(READ_INT32_FIELD(this, kValueOffset), seed);
-  hash = ComputeIntegerHash(
-      READ_INT32_FIELD(this, kValueOffset + 1 * kInt32Size), hash * 31);
-  hash = ComputeIntegerHash(
-      READ_INT32_FIELD(this, kValueOffset + 2 * kInt32Size), hash * 31);
-  hash = ComputeIntegerHash(
-      READ_INT32_FIELD(this, kValueOffset + 3 * kInt32Size), hash * 31);
-  return hash;
-}
-
-
-void Simd128Value::CopyBits(void* destination) const {
-  memcpy(destination, &READ_BYTE_FIELD(this, kValueOffset), kSimd128Size);
-}
-
-
 String* JSReceiver::class_name() {
   if (IsFunction()) {
     return GetHeap()->Function_string();
@@ -2899,12 +2730,6 @@ const char* Representation::Mnemonic() const {
     case kTagged: return "t";
     case kSmi: return "s";
     case kDouble: return "d";
-    case kFloat32x4:
-      return "Float32x4";
-    case kInt32x4:
-      return "Int32x4";
-    case kBool32x4:
-      return "Bool32x4";
     case kInteger32: return "i";
     case kHeapObject: return "h";
     case kExternal: return "x";
@@ -4663,8 +4488,7 @@ Maybe<bool> Object::SetDataProperty(LookupIterator* it, Handle<Object> value) {
   Handle<Object> to_assign = value;
   // Convert the incoming value to a number for storing into typed arrays.
   if (it->IsElement() && receiver->HasFixedTypedArrayElements()) {
-    if (!value->IsNumber() && !value->IsFloat32x4() && !value->IsInt32x4() &&
-        !value->IsBool32x4() && !value->IsUndefined(it->isolate())) {
+    if (!value->IsNumber() && !value->IsUndefined(it->isolate())) {
       ASSIGN_RETURN_ON_EXCEPTION_VALUE(
           it->isolate(), to_assign, Object::ToNumber(value), Nothing<bool>());
       // We have to recheck the length. However, it can only change if the
@@ -12409,7 +12233,6 @@ bool CanSubclassHaveInobjectProperties(InstanceType instance_type) {
     case ODDBALL_TYPE:
     case PROPERTY_CELL_TYPE:
     case SHARED_FUNCTION_INFO_TYPE:
-    case SIMD128_VALUE_TYPE:
     case SYMBOL_TYPE:
     case WEAK_CELL_TYPE:
 
@@ -14142,48 +13965,6 @@ void DeoptimizationInputData::DeoptimizationInputDataPrint(
           break;
         }
 
-        case Translation::FLOAT32x4_REGISTER: {
-          int reg_code = iterator.Next();
-#if V8_TARGET_ARCH_IA32 || V8_TARGET_ARCH_X64
-          os << "{input="
-             << RegisterConfiguration::Crankshaft()->GetSimd128RegisterName(
-                    reg_code)
-             << "}";
-#else
-          os << "{input=" << reg_code << "on other target"
-             << "}";
-#endif
-          break;
-        }
-
-        case Translation::BOOL32x4_REGISTER: {
-          int reg_code = iterator.Next();
-#if V8_TARGET_ARCH_IA32 || V8_TARGET_ARCH_X64
-          os << "{input="
-             << RegisterConfiguration::Crankshaft()->GetSimd128RegisterName(
-                    reg_code)
-             << "}";
-#else
-          os << "{input=" << reg_code << "on ther target"
-             << "}";
-#endif
-          break;
-        }
-
-        case Translation::INT32x4_REGISTER: {
-          int reg_code = iterator.Next();
-#if V8_TARGET_ARCH_IA32 || V8_TARGET_ARCH_X64
-          os << "{input="
-             << RegisterConfiguration::Crankshaft()->GetSimd128RegisterName(
-                    reg_code)
-             << "}";
-#else
-          os << "{input=" << reg_code << "on other target"
-             << "}";
-#endif
-          break;
-        }
-
         case Translation::STACK_SLOT: {
           int input_slot_index = iterator.Next();
           os << "{input=" << input_slot_index << "}";
@@ -14215,24 +13996,6 @@ void DeoptimizationInputData::DeoptimizationInputDataPrint(
           break;
         }
 
-        case Translation::FLOAT32x4_STACK_SLOT: {
-          int input_slot_index = iterator.Next();
-          os << "{input=" << input_slot_index << "}";
-          break;
-        }
-
-        case Translation::BOOL32x4_STACK_SLOT: {
-          int input_slot_index = iterator.Next();
-          os << "{input=" << input_slot_index << "}";
-          break;
-        }
-
-        case Translation::INT32x4_STACK_SLOT: {
-          int input_slot_index = iterator.Next();
-          os << "{input=" << input_slot_index << "}";
-          break;
-        }
-
         case Translation::LITERAL: {
           int literal_index = iterator.Next();
           Object* literal_value = LiteralArray()->get(literal_index);
diff --git a/src/objects.h b/src/objects.h
index 42ab9bc0c1..31bdc0d4e6 100644
--- a/src/objects.h
+++ b/src/objects.h
@@ -359,7 +359,6 @@ const int kStubMinorKeyBits = kSmiValueSize - kStubMajorKeyBits - 1;
   V(SHORT_EXTERNAL_INTERNALIZED_STRING_WITH_ONE_BYTE_DATA_TYPE) \
                                                                 \
   V(SYMBOL_TYPE)                                                \
-  V(SIMD128_VALUE_TYPE)                                         \
                                                                 \
   V(MAP_TYPE)                                                   \
   V(CODE_TYPE)                                                  \
@@ -427,9 +426,6 @@ const int kStubMinorKeyBits = kSmiValueSize - kStubMajorKeyBits - 1;
   V(JS_ARRAY_BUFFER_TYPE)                                       \
   V(JS_TYPED_ARRAY_TYPE)                                        \
   V(JS_DATA_VIEW_TYPE)                                          \
-  V(FLOAT32x4_TYPE)                                             \
-  V(INT32x4_TYPE)                                               \
-  V(BOOL32x4_TYPE)                                              \
   V(JS_PROXY_TYPE)                                              \
   V(JS_SET_TYPE)                                                \
   V(JS_MAP_TYPE)                                                \
@@ -648,7 +644,6 @@ enum InstanceType {
 
   // Other primitives (cannot contain non-map-word pointers to heap objects).
   HEAP_NUMBER_TYPE,
-  SIMD128_VALUE_TYPE,
   ODDBALL_TYPE,  // LAST_PRIMITIVE_TYPE
 
   // Objects allocated in their own spaces (never in new space).
@@ -725,9 +720,6 @@ enum InstanceType {
   JS_ARRAY_BUFFER_TYPE,
   JS_TYPED_ARRAY_TYPE,
   JS_DATA_VIEW_TYPE,
-  FLOAT32x4_TYPE,
-  INT32x4_TYPE,
-  BOOL32x4_TYPE,
   JS_SET_TYPE,
   JS_MAP_TYPE,
   JS_SET_ITERATOR_TYPE,
@@ -897,17 +889,6 @@ template <class C> inline bool Is(Object* obj);
 #define HEAP_OBJECT_TYPE_LIST(V) \
   V(HeapNumber)                  \
   V(MutableHeapNumber)           \
-  V(Simd128Value)                \
-  V(Float32x4)                   \
-  V(Int32x4)                     \
-  V(Uint32x4)                    \
-  V(Bool32x4)                    \
-  V(Int16x8)                     \
-  V(Uint16x8)                    \
-  V(Bool16x8)                    \
-  V(Int8x16)                     \
-  V(Uint8x16)                    \
-  V(Bool8x16)                    \
   V(Name)                        \
   V(UniqueName)                  \
   V(String)                      \
@@ -1733,70 +1714,6 @@ class HeapNumber: public HeapObject {
 };
 
 
-// The Simd128Value class describes heap allocated 128 bit SIMD values.
-class Simd128Value : public HeapObject {
- public:
-  DECLARE_CAST(Simd128Value)
-
-  DECLARE_PRINTER(Simd128Value)
-  DECLARE_VERIFIER(Simd128Value)
-
-  static Handle<String> ToString(Handle<Simd128Value> input);
-
-  // Equality operations.
-  inline bool Equals(Simd128Value* that);
-  static inline bool Equals(Handle<Simd128Value> one, Handle<Simd128Value> two);
-
-  // Checks that another instance is bit-wise equal.
-  bool BitwiseEquals(const Simd128Value* other) const;
-  // Computes a hash from the 128 bit value, viewed as 4 32-bit integers.
-  uint32_t Hash() const;
-  // Copies the 16 bytes of SIMD data to the destination address.
-  void CopyBits(void* destination) const;
-
-  // Layout description.
-  static const int kValueOffset = HeapObject::kHeaderSize;
-  static const int kSize = kValueOffset + kSimd128Size;
-
- private:
-  DISALLOW_IMPLICIT_CONSTRUCTORS(Simd128Value);
-};
-
-
-// V has parameters (TYPE, Type, type, lane count, lane type)
-#define SIMD128_TYPES(V)                       \
-  V(FLOAT32X4, Float32x4, float32x4, 4, float) \
-  V(INT32X4, Int32x4, int32x4, 4, int32_t)     \
-  V(UINT32X4, Uint32x4, uint32x4, 4, uint32_t) \
-  V(BOOL32X4, Bool32x4, bool32x4, 4, bool)     \
-  V(INT16X8, Int16x8, int16x8, 8, int16_t)     \
-  V(UINT16X8, Uint16x8, uint16x8, 8, uint16_t) \
-  V(BOOL16X8, Bool16x8, bool16x8, 8, bool)     \
-  V(INT8X16, Int8x16, int8x16, 16, int8_t)     \
-  V(UINT8X16, Uint8x16, uint8x16, 16, uint8_t) \
-  V(BOOL8X16, Bool8x16, bool8x16, 16, bool)
-
-#define SIMD128_VALUE_CLASS(TYPE, Type, type, lane_count, lane_type) \
-  class Type final : public Simd128Value {                           \
-   public:                                                           \
-    inline lane_type get_lane(int lane) const;                       \
-    inline void set_lane(int lane, lane_type value);                 \
-                                                                     \
-    DECLARE_CAST(Type)                                               \
-                                                                     \
-    DECLARE_PRINTER(Type)                                            \
-                                                                     \
-    static Handle<String> ToString(Handle<Type> input);              \
-                                                                     \
-    inline bool Equals(Type* that);                                  \
-                                                                     \
-   private:                                                          \
-    DISALLOW_IMPLICIT_CONSTRUCTORS(Type);                            \
-  };
-SIMD128_TYPES(SIMD128_VALUE_CLASS)
-#undef SIMD128_VALUE_CLASS
-
-
 enum EnsureElementsMode {
   DONT_ALLOW_DOUBLE_ELEMENTS,
   ALLOW_COPIED_DOUBLE_ELEMENTS,
@@ -6713,201 +6630,13 @@ class Script: public Struct {
   V(Atomics, load, AtomicsLoad)          \
   V(Atomics, store, AtomicsStore)
 
-#define SIMD_NULLARY_OPERATIONS(V)                  \
-  V(SIMD.Float32x4, zero, Float32x4Zero, Float32x4) \
-  V(SIMD.Int32x4, zero, Int32x4Zero, Int32x4)
-
-#define SIMD_UNARY_OPERATIONS(V)                                              \
-  V(SIMD.Float32x4, check, Float32x4Check, Float32x4, Float32x4)              \
-  V(SIMD.Int32x4, check, Int32x4Check, Int32x4, Int32x4)                      \
-  V(SIMD.Float32x4, abs, Float32x4Abs, Float32x4, Float32x4)                  \
-  V(SIMD.Float32x4, fromInt32x4, Int32x4ToFloat32x4, Float32x4, Int32x4)      \
-  V(SIMD.Float32x4, fromInt32x4Bits, Int32x4BitsToFloat32x4, Float32x4,       \
-    Int32x4)                                                                  \
-  V(SIMD.Float32x4, neg, Float32x4Neg, Float32x4, Float32x4)                  \
-  V(SIMD.Float32x4, reciprocalApproximation, Float32x4RecipApprox, Float32x4, \
-    Float32x4)                                                                \
-  V(SIMD.Float32x4, reciprocalSqrtApproximation, Float32x4RecipSqrtApprox,    \
-    Float32x4, Float32x4)                                                     \
-  V(SIMD.Float32x4, splat, Float32x4Splat, Float32x4, Double)                 \
-  V(SIMD.Float32x4, sqrt, Float32x4Sqrt, Float32x4, Float32x4)                \
-  V(SIMD.Int32x4, fromFloat32x4, Float32x4ToInt32x4, Int32x4, Float32x4)      \
-  V(SIMD.Int32x4, fromFloat32x4Bits, Float32x4BitsToInt32x4, Int32x4,         \
-    Float32x4)                                                                \
-  V(SIMD.Int32x4, neg, Int32x4Neg, Int32x4, Int32x4)                          \
-  V(SIMD.Int32x4, not, Int32x4Not, Int32x4, Int32x4)                          \
-  V(SIMD.Int32x4, splat, Int32x4Splat, Int32x4, Integer32)                    \
-  V(SIMD.Bool32x4, anyTrue, Bool32x4AnyTrue, Tagged, Bool32x4)                \
-  V(SIMD.Bool32x4, allTrue, Bool32x4AllTrue, Tagged, Bool32x4)
-
-// Do not need to install them in InstallExperimentalSIMDBuiltinFunctionIds.
-#define SIMD_UNARY_OPERATIONS_FOR_PROPERTY_ACCESS(V)                          \
-  V(SIMD.Float32x4.prototype, signMask, Float32x4GetSignMask, Integer32,      \
-    Float32x4)                                                                \
-  V(SIMD.Float32x4.prototype, x, Float32x4GetX, Double, Float32x4)            \
-  V(SIMD.Float32x4.prototype, y, Float32x4GetY, Double, Float32x4)            \
-  V(SIMD.Float32x4.prototype, z, Float32x4GetZ, Double, Float32x4)            \
-  V(SIMD.Float32x4.prototype, w, Float32x4GetW, Double, Float32x4)            \
-  V(SIMD.Int32x4.prototype, signMask, Int32x4GetSignMask, Integer32, Int32x4) \
-  V(SIMD.Int32x4.prototype, x, Int32x4GetX, Integer32, Int32x4)               \
-  V(SIMD.Int32x4.prototype, y, Int32x4GetY, Integer32, Int32x4)               \
-  V(SIMD.Int32x4.prototype, z, Int32x4GetZ, Integer32, Int32x4)               \
-  V(SIMD.Int32x4.prototype, w, Int32x4GetW, Integer32, Int32x4)               \
-  V(SIMD.Int32x4.prototype, flagX, Int32x4GetFlagX, Tagged, Int32x4)          \
-  V(SIMD.Int32x4.prototype, flagY, Int32x4GetFlagY, Tagged, Int32x4)          \
-  V(SIMD.Int32x4.prototype, flagZ, Int32x4GetFlagZ, Tagged, Int32x4)          \
-  V(SIMD.Int32x4.prototype, flagW, Int32x4GetFlagW, Tagged, Int32x4)
-
-#define SIMD_BINARY_OPERATIONS(V)                                              \
-  V(SIMD.Float32x4, add, Float32x4Add, Float32x4, Float32x4, Float32x4)        \
-  V(SIMD.Float32x4, div, Float32x4Div, Float32x4, Float32x4, Float32x4)        \
-  V(SIMD.Float32x4, max, Float32x4Max, Float32x4, Float32x4, Float32x4)        \
-  V(SIMD.Float32x4, min, Float32x4Min, Float32x4, Float32x4, Float32x4)        \
-  V(SIMD.Float32x4, mul, Float32x4Mul, Float32x4, Float32x4, Float32x4)        \
-  V(SIMD.Float32x4, sub, Float32x4Sub, Float32x4, Float32x4, Float32x4)        \
-  V(SIMD.Float32x4, equal, Float32x4Equal, Bool32x4, Float32x4, Float32x4)     \
-  V(SIMD.Float32x4, notEqual, Float32x4NotEqual, Bool32x4, Float32x4,          \
-    Float32x4)                                                                 \
-  V(SIMD.Float32x4, greaterThan, Float32x4GreaterThan, Bool32x4, Float32x4,    \
-    Float32x4)                                                                 \
-  V(SIMD.Float32x4, greaterThanOrEqual, Float32x4GreaterThanOrEqual, Bool32x4, \
-    Float32x4, Float32x4)                                                      \
-  V(SIMD.Float32x4, lessThan, Float32x4LessThan, Bool32x4, Float32x4,          \
-    Float32x4)                                                                 \
-  V(SIMD.Float32x4, lessThanOrEqual, Float32x4LessThanOrEqual, Bool32x4,       \
-    Float32x4, Float32x4)                                                      \
-  V(SIMD.Float32x4, extractLane, Float32x4ExtractLane, Double, Float32x4,      \
-    Integer32)                                                                 \
-  V(SIMD.Int32x4, add, Int32x4Add, Int32x4, Int32x4, Int32x4)                  \
-  V(SIMD.Int32x4, and, Int32x4And, Int32x4, Int32x4, Int32x4)                  \
-  V(SIMD.Int32x4, mul, Int32x4Mul, Int32x4, Int32x4, Int32x4)                  \
-  V(SIMD.Int32x4, or, Int32x4Or, Int32x4, Int32x4, Int32x4)                    \
-  V(SIMD.Int32x4, sub, Int32x4Sub, Int32x4, Int32x4, Int32x4)                  \
-  V(SIMD.Int32x4, xor, Int32x4Xor, Int32x4, Int32x4, Int32x4)                  \
-  V(SIMD.Int32x4, extractLane, Int32x4ExtractLane, Integer32, Int32x4,         \
-    Integer32)                                                                 \
-  V(SIMD.Int32x4, greaterThan, Int32x4GreaterThan, Bool32x4, Int32x4, Int32x4) \
-  V(SIMD.Int32x4, equal, Int32x4Equal, Bool32x4, Int32x4, Int32x4)             \
-  V(SIMD.Int32x4, lessThan, Int32x4LessThan, Bool32x4, Int32x4, Int32x4)       \
-  V(SIMD.Int32x4, shiftLeftByScalar, Int32x4ShiftLeft, Int32x4, Int32x4,       \
-    Integer32)                                                                 \
-  V(SIMD.Int32x4, shiftRightByScalar, Int32x4ShiftRightArithmetic, Int32x4,    \
-    Int32x4, Integer32)                                                        \
-  V(SIMD.Bool32x4, extractLane, Bool32x4ExtractLane, Tagged, Bool32x4,         \
-    Integer32)
-
-#define SIMD_TERNARY_OPERATIONS(V)                                            \
-  V(SIMD.Float32x4, select, Float32x4Select, Float32x4, Int32x4, Float32x4,   \
-    Float32x4)                                                                \
-  V(SIMD.Int32x4, select, Int32x4Select, Int32x4, Bool32x4, Int32x4, Int32x4) \
-  V(SIMD.Float32x4, replaceLane, Float32x4ReplaceLane, Float32x4, Float32x4,  \
-    Integer32, Double)                                                        \
-  V(SIMD.Int32x4, replaceLane, Int32x4ReplaceLane, Int32x4, Int32x4,          \
-    Integer32, Integer32)
-
-#define SIMD_QUARTERNARY_OPERATIONS(V)                                        \
-  V(SIMD, Float32x4, Float32x4Constructor, Float32x4, Double, Double, Double, \
-    Double)                                                                   \
-  V(SIMD, Int32x4, Int32x4Constructor, Int32x4, Integer32, Integer32,         \
-    Integer32, Integer32)                                                     \
-  V(SIMD, Bool32x4, Bool32x4Constructor, Bool32x4, Tagged, Tagged, Tagged,    \
-    Tagged)
-
-#define SIMD_QUINARY_OPERATIONS(V)                                      \
-  V(SIMD.Float32x4, swizzle, Float32x4Swizzle, Float32x4, Float32x4,    \
-    Integer32, Integer32, Integer32, Integer32)                         \
-  V(SIMD.Int32x4, swizzle, Int32x4Swizzle, Int32x4, Int32x4, Integer32, \
-    Integer32, Integer32, Integer32)
-
-#define SIMD_SENARY_OPERATIONS(V)                                     \
-  V(SIMD.Float32x4, shuffle, Float32x4Shuffle, Float32x4, Float32x4,  \
-    Float32x4, Integer32, Integer32, Integer32, Integer32)            \
-  V(SIMD.Int32x4, shuffle, Int32x4Shuffle, Int32x4, Int32x4, Int32x4, \
-    Integer32, Integer32, Integer32, Integer32)
-
-#define SIMD_LOAD_OPERATIONS(V)               \
-  V(SIMD.Float32x4, load, GetFloat32x4XYZW)   \
-  V(SIMD.Float32x4, loadX, GetFloat32x4X)     \
-  V(SIMD.Float32x4, loadXY, GetFloat32x4XY)   \
-  V(SIMD.Float32x4, loadXYZ, GetFloat32x4XYZ) \
-  V(SIMD.Int32x4, load, GetInt32x4XYZW)       \
-  V(SIMD.Int32x4, loadX, GetInt32x4X)         \
-  V(SIMD.Int32x4, loadXY, GetInt32x4XY)       \
-  V(SIMD.Int32x4, loadXYZ, GetInt32x4XYZ)
-
-#define SIMD_STORE_OPERATIONS(V)               \
-  V(SIMD.Float32x4, store, SetFloat32x4XYZW)   \
-  V(SIMD.Float32x4, storeX, SetFloat32x4X)     \
-  V(SIMD.Float32x4, storeXY, SetFloat32x4XY)   \
-  V(SIMD.Float32x4, storeXYZ, SetFloat32x4XYZ) \
-  V(SIMD.Int32x4, store, SetInt32x4XYZW)       \
-  V(SIMD.Int32x4, storeX, SetInt32x4X)         \
-  V(SIMD.Int32x4, storeXY, SetInt32x4XY)       \
-  V(SIMD.Int32x4, storeXYZ, SetInt32x4XYZ)
-
-#define TYPED_ARRAYS_SIMD_LOAD_OPERATIONS(V)                                 \
-  V(Float32Array.prototype, _getFloat32x4XYZW, Float32ArrayGetFloat32x4XYZW) \
-  V(Float32Array.prototype, _getFloat32x4XYZ, Float32ArrayGetFloat32x4XYZ)   \
-  V(Float32Array.prototype, _getFloat32x4XY, Float32ArrayGetFloat32x4XY)     \
-  V(Float32Array.prototype, _getFloat32x4X, Float32ArrayGetFloat32x4X)       \
-  V(Int32Array.prototype, _getInt32x4XYZW, Int32ArrayGetInt32x4XYZW)         \
-  V(Int32Array.prototype, _getInt32x4XYZ, Int32ArrayGetInt32x4XYZ)           \
-  V(Int32Array.prototype, _getInt32x4XY, Int32ArrayGetInt32x4XY)             \
-  V(Int32Array.prototype, _getInt32x4X, Int32ArrayGetInt32x4X)               \
-  V(Int8Array.prototype, _getFloat32x4XYZW, Int8ArrayGetFloat32x4XYZW)       \
-  V(Int8Array.prototype, _getFloat32x4XYZ, Int8ArrayGetFloat32x4XYZ)         \
-  V(Int8Array.prototype, _getFloat32x4XY, Int8ArrayGetFloat32x4XY)           \
-  V(Int8Array.prototype, _getFloat32x4X, Int8ArrayGetFloat32x4X)             \
-  V(Int8Array.prototype, _getInt32x4XYZW, Int8ArrayGetInt32x4XYZW)           \
-  V(Int8Array.prototype, _getInt32x4XYZ, Int8ArrayGetInt32x4XYZ)             \
-  V(Int8Array.prototype, _getInt32x4XY, Int8ArrayGetInt32x4XY)               \
-  V(Int8Array.prototype, _getInt32x4X, Int8ArrayGetInt32x4X)                 \
-  V(Uint8Array.prototype, _getFloat32x4XYZW, Uint8ArrayGetFloat32x4XYZW)     \
-  V(Uint8Array.prototype, _getFloat32x4XYZ, Uint8ArrayGetFloat32x4XYZ)       \
-  V(Uint8Array.prototype, _getFloat32x4XY, Uint8ArrayGetFloat32x4XY)         \
-  V(Uint8Array.prototype, _getFloat32x4X, Uint8ArrayGetFloat32x4X)           \
-  V(Uint8Array.prototype, _getInt32x4XYZW, Uint8ArrayGetInt32x4XYZW)         \
-  V(Uint8Array.prototype, _getInt32x4XYZ, Uint8ArrayGetInt32x4XYZ)           \
-  V(Uint8Array.prototype, _getInt32x4XY, Uint8ArrayGetInt32x4XY)             \
-  V(Uint8Array.prototype, _getInt32x4X, Uint8ArrayGetInt32x4X)
-
-#define TYPED_ARRAYS_SIMD_STORE_OPERATIONS(V)                                \
-  V(Float32Array.prototype, _setFloat32x4XYZW, Float32ArraySetFloat32x4XYZW) \
-  V(Float32Array.prototype, _setFloat32x4XYZ, Float32ArraySetFloat32x4XYZ)   \
-  V(Float32Array.prototype, _setFloat32x4XY, Float32ArraySetFloat32x4XY)     \
-  V(Float32Array.prototype, _setFloat32x4X, Float32ArraySetFloat32x4X)       \
-  V(Int32Array.prototype, _setInt32x4XYZW, Int32ArraySetInt32x4XYZW)         \
-  V(Int32Array.prototype, _setInt32x4XYZ, Int32ArraySetInt32x4XYZ)           \
-  V(Int32Array.prototype, _setInt32x4XY, Int32ArraySetInt32x4XY)             \
-  V(Int32Array.prototype, _setInt32x4X, Int32ArraySetInt32x4X)               \
-  V(Int8Array.prototype, _setFloat32x4XYZW, Int8ArraySetFloat32x4XYZW)       \
-  V(Int8Array.prototype, _setFloat32x4XYZ, Int8ArraySetFloat32x4XYZ)         \
-  V(Int8Array.prototype, _setFloat32x4XY, Int8ArraySetFloat32x4XY)           \
-  V(Int8Array.prototype, _setFloat32x4X, Int8ArraySetFloat32x4X)             \
-  V(Int8Array.prototype, _setInt32x4XYZW, Int8ArraySetInt32x4XYZW)           \
-  V(Int8Array.prototype, _setInt32x4XYZ, Int8ArraySetInt32x4XYZ)             \
-  V(Int8Array.prototype, _setInt32x4XY, Int8ArraySetInt32x4XY)               \
-  V(Int8Array.prototype, _setInt32x4X, Int8ArraySetInt32x4X)                 \
-  V(Uint8Array.prototype, _setFloat32x4XYZW, Uint8ArraySetFloat32x4XYZW)     \
-  V(Uint8Array.prototype, _setFloat32x4XYZ, Uint8ArraySetFloat32x4XYZ)       \
-  V(Uint8Array.prototype, _setFloat32x4XY, Uint8ArraySetFloat32x4XY)         \
-  V(Uint8Array.prototype, _setFloat32x4X, Uint8ArraySetFloat32x4X)           \
-  V(Uint8Array.prototype, _setInt32x4XYZW, Uint8ArraySetInt32x4XYZW)         \
-  V(Uint8Array.prototype, _setInt32x4XYZ, Uint8ArraySetInt32x4XYZ)           \
-  V(Uint8Array.prototype, _setInt32x4XY, Uint8ArraySetInt32x4XY)             \
-  V(Uint8Array.prototype, _setInt32x4X, Uint8ArraySetInt32x4X)
-
-// Do not need to install them in InstallExperimentalSIMDBuiltinFunctionIds.
-#define SIMD_FAKE_ID_LISTS(V)              \
-  V(SIMD, unreachable, SIMD128Unreachable) \
-  V(SIMD, change, SIMD128Change)
-
 enum BuiltinFunctionId {
   kArrayCode,
 #define DECLARE_FUNCTION_ID(ignored1, ignore2, name)    \
   k##name,
   FUNCTIONS_WITH_ID_LIST(DECLARE_FUNCTION_ID)
       ATOMIC_FUNCTIONS_WITH_ID_LIST(DECLARE_FUNCTION_ID)
+#undef DECLARE_FUNCTION_ID
   // Fake id for a special case of Math.pow. Note, it continues the
   // list of math functions.
   kMathPowHalf,
@@ -6918,47 +6647,9 @@ enum BuiltinFunctionId {
   kTypedArrayByteLength,
   kTypedArrayByteOffset,
   kTypedArrayLength,
-  SIMD_FAKE_ID_LISTS(DECLARE_FUNCTION_ID) TYPED_ARRAYS_SIMD_LOAD_OPERATIONS(
-      DECLARE_FUNCTION_ID)
-      TYPED_ARRAYS_SIMD_STORE_OPERATIONS(DECLARE_FUNCTION_ID)
-          SIMD_LOAD_OPERATIONS(DECLARE_FUNCTION_ID) SIMD_STORE_OPERATIONS(
-              DECLARE_FUNCTION_ID)
-#undef DECLARE_FUNCTION_ID
-#define DECLARE_SIMD_NULLARY_FUNCTION_ID(i1, i2, name, i3) k##name,
-              SIMD_NULLARY_OPERATIONS(DECLARE_SIMD_NULLARY_FUNCTION_ID)
-#undef DECLARE_SIMD_NULLARY_FUNCTION_ID
-#define DECLARE_SIMD_UNARY_FUNCTION_ID(i1, i2, name, i3, i4) k##name,
-                  SIMD_UNARY_OPERATIONS(DECLARE_SIMD_UNARY_FUNCTION_ID)
-                      SIMD_UNARY_OPERATIONS_FOR_PROPERTY_ACCESS(
-                          DECLARE_SIMD_UNARY_FUNCTION_ID)
-#undef DECLARE_SIMD_UNARY_FUNCTION_ID
-#define DECLARE_SIMD_BINARY_FUNCTION_ID(i1, i2, name, i3, i4, i5) k##name,
-                          SIMD_BINARY_OPERATIONS(
-                              DECLARE_SIMD_BINARY_FUNCTION_ID)
-#undef DECLARE_SIMD_BINARY_FUNCTION_ID
-#define DECLARE_SIMD_TERNARY_FUNCTION_ID(i1, i2, name, i3, i4, i5, i6) k##name,
-                              SIMD_TERNARY_OPERATIONS(
-                                  DECLARE_SIMD_TERNARY_FUNCTION_ID)
-#undef DECLARE_SIMD_TERNARY_FUNCTION_ID
-#define DECLARE_SIMD_QUARTERNARY_FUNCTION_ID(i1, i2, name, i3, i4, i5, i6, i7) \
-  k##name,
-                                  SIMD_QUARTERNARY_OPERATIONS(
-                                      DECLARE_SIMD_QUARTERNARY_FUNCTION_ID)
-#undef DECLARE_SIMD_QUARTERNARY_FUNCTION_ID
-#define DECLARE_SIMD_QUINARY_FUNCTION_ID(i1, i2, name, i3, i4, i5, i6, i7, i8) \
-  k##name,
-                                      SIMD_QUINARY_OPERATIONS(
-                                          DECLARE_SIMD_QUINARY_FUNCTION_ID)
-#undef DECLARE_SIMD_QUINARY_FUNCTION_ID
-#define DECLARE_SIMD_SENARY_FUNCTION_ID(i1, i2, name, i3, i4, i5, i6, i7, i8, \
-                                        i9)                                   \
-  k##name,
-                                          SIMD_SENARY_OPERATIONS(
-                                              DECLARE_SIMD_SENARY_FUNCTION_ID)
-#undef DECLARE_SIMD_SENARY_FUNCTION_ID
-                                              kNumberOfBuiltinFunction
 };
 
+
 // Result of searching in an optimized code map of a SharedFunctionInfo. Note
 // that both {code} and {literals} can be NULL to pass search result status.
 struct CodeAndLiterals {
diff --git a/src/parsing/parser-base.h b/src/parsing/parser-base.h
index e5edfee4c8..669defa27f 100644
--- a/src/parsing/parser-base.h
+++ b/src/parsing/parser-base.h
@@ -2835,10 +2835,6 @@ ParserBase<Traits>::ParseLeftHandSideExpression(
 
         ArrowFormalParametersUnexpectedToken(classifier);
 
-        if (this->BuildSIMD128LoadStoreExpression(&result, args, pos,
-                                                  factory()))
-          break;
-
         // Keep track of eval() calls since they disable all local variable
         // optimizations.
         // The calls that need special treatment are the
diff --git a/src/parsing/parser.cc b/src/parsing/parser.cc
index a3d435feb2..a39d0eec12 100644
--- a/src/parsing/parser.cc
+++ b/src/parsing/parser.cc
@@ -467,156 +467,6 @@ bool ParserTraits::ShortcutNumericLiteralBinaryExpression(
   return false;
 }
 
-bool ParserTraits::BuildSIMD128LoadStoreExpression(
-    Expression** expression, ZoneList<Expression*>* arguments, int pos,
-    AstNodeFactory* factory) {
-  Property* prop = (*expression)->AsProperty();
-  Expression* tarray_op_literal = NULL;
-
-  if (prop) {
-    Property* simd_type_prop = prop->obj()->AsProperty();
-    if (simd_type_prop) {
-      VariableProxy* simd_var = simd_type_prop->obj()->AsVariableProxy();
-      if (simd_var && simd_var->raw_name() &&
-          simd_var->raw_name()->IsOneByteEqualTo("SIMD")) {
-        Literal* type_literal = simd_type_prop->key()->AsLiteral();
-        if (type_literal && type_literal->raw_value() &&
-            type_literal->raw_value()->AsString()) {
-          const AstRawString* type_literal_raw_string =
-              type_literal->raw_value()->AsString();
-          if (type_literal_raw_string->IsOneByteEqualTo("Float32x4")) {
-            Literal* op_literal = prop->key()->AsLiteral();
-            if (op_literal && op_literal->raw_value() &&
-                op_literal->raw_value()->AsString()) {
-              const AstRawString* op_raw_string =
-                  op_literal->raw_value()->AsString();
-              AstValueFactory* ast_factory = parser_->ast_value_factory();
-              if (op_raw_string->IsOneByteEqualTo("load")) {
-                const AstRawString* op_str =
-                    ast_factory->GetOneByteString("_getFloat32x4XYZW");
-                tarray_op_literal =
-                    factory->NewStringLiteral(op_str, RelocInfo::kNoPosition);
-              } else if (op_raw_string->IsOneByteEqualTo("load1")) {
-                const AstRawString* op_str =
-                    ast_factory->GetOneByteString("_getFloat32x4X");
-                tarray_op_literal =
-                    factory->NewStringLiteral(op_str, RelocInfo::kNoPosition);
-              } else if (op_raw_string->IsOneByteEqualTo("load2")) {
-                const AstRawString* op_str =
-                    ast_factory->GetOneByteString("_getFloat32x4XY");
-                tarray_op_literal =
-                    factory->NewStringLiteral(op_str, RelocInfo::kNoPosition);
-              } else if (op_raw_string->IsOneByteEqualTo("load3")) {
-                const AstRawString* op_str =
-                    ast_factory->GetOneByteString("_getFloat32x4XYZ");
-                tarray_op_literal =
-                    factory->NewStringLiteral(op_str, RelocInfo::kNoPosition);
-              } else if (op_raw_string->IsOneByteEqualTo("store")) {
-                const AstRawString* op_str =
-                    ast_factory->GetOneByteString("_setFloat32x4XYZW");
-                tarray_op_literal =
-                    factory->NewStringLiteral(op_str, RelocInfo::kNoPosition);
-              } else if (op_raw_string->IsOneByteEqualTo("store1")) {
-                const AstRawString* op_str =
-                    ast_factory->GetOneByteString("_setFloat32x4X");
-                tarray_op_literal =
-                    factory->NewStringLiteral(op_str, RelocInfo::kNoPosition);
-              } else if (op_raw_string->IsOneByteEqualTo("store2")) {
-                const AstRawString* op_str =
-                    ast_factory->GetOneByteString("_setFloat32x4XY");
-                tarray_op_literal =
-                    factory->NewStringLiteral(op_str, RelocInfo::kNoPosition);
-              } else if (op_raw_string->IsOneByteEqualTo("store3")) {
-                const AstRawString* op_str =
-                    ast_factory->GetOneByteString("_setFloat32x4XYZ");
-                tarray_op_literal =
-                    factory->NewStringLiteral(op_str, RelocInfo::kNoPosition);
-              }
-            }
-          } else if (type_literal_raw_string->IsOneByteEqualTo("Int32x4")) {
-            Literal* op_literal = prop->key()->AsLiteral();
-            if (op_literal && op_literal->raw_value() &&
-                op_literal->raw_value()->AsString()) {
-              const AstRawString* op_raw_string =
-                  op_literal->raw_value()->AsString();
-              AstValueFactory* ast_factory = parser_->ast_value_factory();
-              if (op_raw_string->IsOneByteEqualTo("load")) {
-                const AstRawString* op_str =
-                    ast_factory->GetOneByteString("_getInt32x4XYZW");
-                tarray_op_literal =
-                    factory->NewStringLiteral(op_str, RelocInfo::kNoPosition);
-              } else if (op_raw_string->IsOneByteEqualTo("load1")) {
-                const AstRawString* op_str =
-                    ast_factory->GetOneByteString("_getInt32x4X");
-                tarray_op_literal =
-                    factory->NewStringLiteral(op_str, RelocInfo::kNoPosition);
-              } else if (op_raw_string->IsOneByteEqualTo("load2")) {
-                const AstRawString* op_str =
-                    ast_factory->GetOneByteString("_getInt32x4XY");
-                tarray_op_literal =
-                    factory->NewStringLiteral(op_str, RelocInfo::kNoPosition);
-              } else if (op_raw_string->IsOneByteEqualTo("load3")) {
-                const AstRawString* op_str =
-                    ast_factory->GetOneByteString("_getInt32x4XYZ");
-                tarray_op_literal =
-                    factory->NewStringLiteral(op_str, RelocInfo::kNoPosition);
-              } else if (op_raw_string->IsOneByteEqualTo("store")) {
-                const AstRawString* op_str =
-                    ast_factory->GetOneByteString("_setInt32x4XYZW");
-                tarray_op_literal =
-                    factory->NewStringLiteral(op_str, RelocInfo::kNoPosition);
-              } else if (op_raw_string->IsOneByteEqualTo("store1")) {
-                const AstRawString* op_str =
-                    ast_factory->GetOneByteString("_setInt32x4X");
-                tarray_op_literal =
-                    factory->NewStringLiteral(op_str, RelocInfo::kNoPosition);
-              } else if (op_raw_string->IsOneByteEqualTo("store2")) {
-                const AstRawString* op_str =
-                    ast_factory->GetOneByteString("_setInt32x4XY");
-                tarray_op_literal =
-                    factory->NewStringLiteral(op_str, RelocInfo::kNoPosition);
-              } else if (op_raw_string->IsOneByteEqualTo("store3")) {
-                const AstRawString* op_str =
-                    ast_factory->GetOneByteString("_setInt32x4XYZ");
-                tarray_op_literal =
-                    factory->NewStringLiteral(op_str, RelocInfo::kNoPosition);
-              }
-            }
-          }
-        }
-      }
-    }
-  }
-
-  if (tarray_op_literal) {
-    if (arguments && arguments->length() == 2) {
-      Expression* tarray = arguments->at(0);
-      Expression* index = arguments->at(1);
-      Expression* tarray_op =
-          factory->NewProperty(tarray, tarray_op_literal, pos);
-      Zone* zone = parser_->zone();
-      ZoneList<Expression*>* tarray_op_args =
-          new (zone) ZoneList<Expression*>(1, zone);
-      tarray_op_args->Add(index, zone);
-      *expression = factory->NewCall(tarray_op, tarray_op_args, pos);
-      return true;
-    } else if (arguments && arguments->length() == 3) {
-      Expression* tarray = arguments->at(0);
-      Expression* index = arguments->at(1);
-      Expression* value = arguments->at(2);
-      Expression* tarray_op =
-          factory->NewProperty(tarray, tarray_op_literal, pos);
-      Zone* zone = parser_->zone();
-      ZoneList<Expression*>* tarray_op_args =
-          new (zone) ZoneList<Expression*>(1, zone);
-      tarray_op_args->Add(index, zone);
-      tarray_op_args->Add(value, zone);
-      *expression = factory->NewCall(tarray_op, tarray_op_args, pos);
-      return true;
-    }
-  }
-  return false;
-}
 
 Expression* ParserTraits::BuildUnaryExpression(Expression* expression,
                                                Token::Value op, int pos,
diff --git a/src/parsing/parser.h b/src/parsing/parser.h
index 36bad7e874..472dab9c6e 100644
--- a/src/parsing/parser.h
+++ b/src/parsing/parser.h
@@ -419,14 +419,6 @@ class ParserTraits {
                                               Token::Value op, int pos,
                                               AstNodeFactory* factory);
 
-  // If we find a SIMD load or store call with array types
-  // and offset as arguments, we will return an expression
-  // calling array types load or store with offset as argument.
-  // Otherwise, returns NULL.
-  bool BuildSIMD128LoadStoreExpression(Expression** expression,
-                                       ZoneList<Expression*>* arguments,
-                                       int pos, AstNodeFactory* factory);
-
   // Rewrites the following types of unary expressions:
   // not <literal> -> true / false
   // + <numeric literal> -> <numeric literal>
diff --git a/src/parsing/preparser.h b/src/parsing/preparser.h
index 2b52466824..8eb95e7e98 100644
--- a/src/parsing/preparser.h
+++ b/src/parsing/preparser.h
@@ -726,12 +726,6 @@ class PreParserTraits {
     return false;
   }
 
-  bool BuildSIMD128LoadStoreExpression(PreParserExpression* expression,
-                                       PreParserExpressionList arguments,
-                                       int pos, PreParserFactory* factory) {
-    return false;
-  }
-
   PreParserExpression BuildUnaryExpression(PreParserExpression expression,
                                            Token::Value op, int pos,
                                            PreParserFactory* factory) {
diff --git a/src/profiler/heap-snapshot-generator.cc b/src/profiler/heap-snapshot-generator.cc
index c80877f623..f666e04c4b 100644
--- a/src/profiler/heap-snapshot-generator.cc
+++ b/src/profiler/heap-snapshot-generator.cc
@@ -153,7 +153,6 @@ const char* HeapEntry::TypeAsString() {
     case kConsString: return "/concatenated string/";
     case kSlicedString: return "/sliced string/";
     case kSymbol: return "/symbol/";
-    case kSimdValue: return "/simd/";
     default: return "???";
   }
 }
@@ -847,8 +846,6 @@ HeapEntry* V8HeapExplorer::AddEntry(HeapObject* object) {
     return AddEntry(object, HeapEntry::kArray, "");
   } else if (object->IsHeapNumber()) {
     return AddEntry(object, HeapEntry::kHeapNumber, "number");
-  } else if (object->IsSimd128Value()) {
-    return AddEntry(object, HeapEntry::kSimdValue, "simd");
   }
   return AddEntry(object, HeapEntry::kHidden, GetSystemEntryName(object));
 }
diff --git a/src/profiler/heap-snapshot-generator.h b/src/profiler/heap-snapshot-generator.h
index a6bc38570a..d4bb335114 100644
--- a/src/profiler/heap-snapshot-generator.h
+++ b/src/profiler/heap-snapshot-generator.h
@@ -89,8 +89,7 @@ class HeapEntry BASE_EMBEDDED {
     kSynthetic = v8::HeapGraphNode::kSynthetic,
     kConsString = v8::HeapGraphNode::kConsString,
     kSlicedString = v8::HeapGraphNode::kSlicedString,
-    kSymbol = v8::HeapGraphNode::kSymbol,
-    kSimdValue = v8::HeapGraphNode::kSimdValue
+    kSymbol = v8::HeapGraphNode::kSymbol
   };
   static const int kNoEntry;
 
diff --git a/src/property-details.h b/src/property-details.h
index aaadfc51ce..e30d6681aa 100644
--- a/src/property-details.h
+++ b/src/property-details.h
@@ -98,9 +98,6 @@ class Representation {
     kSmi,
     kInteger32,
     kDouble,
-    kFloat32x4,
-    kInt32x4,
-    kBool32x4,
     kHeapObject,
     kTagged,
     kExternal,
@@ -118,9 +115,6 @@ class Representation {
   static Representation Smi() { return Representation(kSmi); }
   static Representation Integer32() { return Representation(kInteger32); }
   static Representation Double() { return Representation(kDouble); }
-  static Representation Float32x4() { return Representation(kFloat32x4); }
-  static Representation Int32x4() { return Representation(kInt32x4); }
-  static Representation Bool32x4() { return Representation(kBool32x4); }
   static Representation HeapObject() { return Representation(kHeapObject); }
   static Representation External() { return Representation(kExternal); }
 
@@ -149,7 +143,6 @@ class Representation {
     if (IsHeapObject()) return other.IsNone();
     if (kind_ == kUInteger8 && other.kind_ == kInteger8) return false;
     if (kind_ == kUInteger16 && other.kind_ == kInteger16) return false;
-    if (IsSIMD128() && other.IsSIMD128()) return false;
     return kind_ > other.kind_;
   }
 
@@ -189,12 +182,6 @@ class Representation {
   bool IsInteger32() const { return kind_ == kInteger32; }
   bool IsSmiOrInteger32() const { return IsSmi() || IsInteger32(); }
   bool IsDouble() const { return kind_ == kDouble; }
-  bool IsFloat32x4() const { return kind_ == kFloat32x4; }
-  bool IsInt32x4() const { return kind_ == kInt32x4; }
-  bool IsBool32x4() const { return kind_ == kBool32x4; }
-  bool IsSIMD128() const {
-    return IsFloat32x4() || IsInt32x4() || IsBool32x4();
-  }
   bool IsHeapObject() const { return kind_ == kHeapObject; }
   bool IsExternal() const { return kind_ == kExternal; }
   bool IsSpecialization() const {
diff --git a/src/register-configuration.h b/src/register-configuration.h
index 5547cead51..25f3ef5f20 100644
--- a/src/register-configuration.h
+++ b/src/register-configuration.h
@@ -88,9 +88,6 @@ class RegisterConfiguration {
   const char* GetDoubleRegisterName(int code) const {
     return double_register_names_[code];
   }
-  const char* GetSimd128RegisterName(int code) const {
-    return simd128_register_names_[code];
-  }
   const int* allocatable_general_codes() const {
     return allocatable_general_codes_;
   }
@@ -130,7 +127,6 @@ class RegisterConfiguration {
   char const* const* general_register_names_;
   char const* const* float_register_names_;
   char const* const* double_register_names_;
-  char const* const* simd128_register_names_;
 };
 
 }  // namespace internal
diff --git a/src/runtime/runtime-simd.cc b/src/runtime/runtime-simd.cc
index f840420421..70bc950150 100644
--- a/src/runtime/runtime-simd.cc
+++ b/src/runtime/runtime-simd.cc
@@ -17,30 +17,6 @@
 namespace v8 {
 namespace internal {
 
-RUNTIME_FUNCTION(Runtime_AllocateFloat32x4) {
-  HandleScope scope(isolate);
-  DCHECK(args.length() == 0);
-
-  float32x4_value_t zero = {{0, 0, 0, 0}};
-  return *isolate->factory()->NewFloat32x4(zero.storage);
-}
-
-RUNTIME_FUNCTION(Runtime_AllocateInt32x4) {
-  HandleScope scope(isolate);
-  DCHECK(args.length() == 0);
-
-  int32x4_value_t zero = {{0, 0, 0, 0}};
-  return *isolate->factory()->NewInt32x4(zero.storage);
-}
-
-RUNTIME_FUNCTION(Runtime_AllocateBool32x4) {
-  HandleScope scope(isolate);
-  DCHECK(args.length() == 0);
-
-  bool zero[4] = {false, false, false, false};
-  return *isolate->factory()->NewBool32x4(zero);
-}
-
 namespace {
 
 // Functions to convert Numbers to SIMD component types.
@@ -1034,125 +1010,6 @@ SIMD_LOADN_STOREN_TYPES(SIMD_STORE1_FUNCTION)
 SIMD_LOADN_STOREN_TYPES(SIMD_STORE2_FUNCTION)
 SIMD_LOADN_STOREN_TYPES(SIMD_STORE3_FUNCTION)
 
-template <int n>
-inline void CopyBytes(uint8_t* target, uint8_t* source) {
-  for (int i = 0; i < n; i++) {
-    *(target++) = *(source++);
-  }
-}
-
-template <typename T, int Bytes>
-inline static bool SimdTypeLoadValue(Isolate* isolate,
-                                     Handle<JSArrayBuffer> buffer,
-                                     Handle<Object> byte_offset_obj,
-                                     T* result) {
-  size_t byte_offset = 0;
-  if (!TryNumberToSize(isolate, *byte_offset_obj, &byte_offset)) {
-    return false;
-  }
-
-  size_t buffer_byte_length = NumberToSize(isolate, buffer->byte_length());
-  if (byte_offset + Bytes > buffer_byte_length) {  // overflow
-    return false;
-  }
-
-  union Value {
-    T data;
-    uint8_t bytes[sizeof(T)];
-  };
-
-  Value value;
-  memset(value.bytes, 0, sizeof(T));
-  uint8_t* source =
-      static_cast<uint8_t*>(buffer->backing_store()) + byte_offset;
-  DCHECK(Bytes <= sizeof(T));
-  CopyBytes<Bytes>(value.bytes, source);
-  *result = value.data;
-  return true;
-}
-
-template <typename T, int Bytes>
-static bool SimdTypeStoreValue(Isolate* isolate, Handle<JSArrayBuffer> buffer,
-                               Handle<Object> byte_offset_obj, T data) {
-  size_t byte_offset = 0;
-  if (!TryNumberToSize(isolate, *byte_offset_obj, &byte_offset)) {
-    return false;
-  }
-
-  size_t buffer_byte_length = NumberToSize(isolate, buffer->byte_length());
-  if (byte_offset + Bytes > buffer_byte_length) {  // overflow
-    return false;
-  }
-
-  union Value {
-    T data;
-    uint8_t bytes[sizeof(T)];
-  };
-
-  Value value;
-  value.data = data;
-
-  uint8_t* target =
-      static_cast<uint8_t*>(buffer->backing_store()) + byte_offset;
-  DCHECK(Bytes <= sizeof(T));
-  CopyBytes<Bytes>(target, value.bytes);
-  return true;
-}
-
-#define SIMD128_LOAD_RUNTIME_FUNCTION(Type, ValueType, Lanes, Bytes) \
-  RUNTIME_FUNCTION(Runtime_##Type##Load##Lanes) {                    \
-    HandleScope scope(isolate);                                      \
-    DCHECK(args.length() == 2);                                      \
-    CONVERT_ARG_HANDLE_CHECKED(JSArrayBuffer, buffer, 0);            \
-    CONVERT_NUMBER_ARG_HANDLE_CHECKED(offset, 1);                    \
-    ValueType result;                                                \
-    if (SimdTypeLoadValue<ValueType, Bytes>(isolate, buffer, offset, \
-                                            &result)) {              \
-      return *isolate->factory()->New##Type(result.storage);         \
-    } else {                                                         \
-      THROW_NEW_ERROR_RETURN_FAILURE(                                \
-          isolate, NewRangeError(MessageTemplate::kInvalidOffset));  \
-    }                                                                \
-  }
-
-SIMD128_LOAD_RUNTIME_FUNCTION(Float32x4, float32x4_value_t, XYZW, 16)
-SIMD128_LOAD_RUNTIME_FUNCTION(Float32x4, float32x4_value_t, XYZ, 12)
-SIMD128_LOAD_RUNTIME_FUNCTION(Float32x4, float32x4_value_t, XY, 8)
-SIMD128_LOAD_RUNTIME_FUNCTION(Float32x4, float32x4_value_t, X, 4)
-SIMD128_LOAD_RUNTIME_FUNCTION(Int32x4, int32x4_value_t, XYZW, 16)
-SIMD128_LOAD_RUNTIME_FUNCTION(Int32x4, int32x4_value_t, XYZ, 12)
-SIMD128_LOAD_RUNTIME_FUNCTION(Int32x4, int32x4_value_t, XY, 8)
-SIMD128_LOAD_RUNTIME_FUNCTION(Int32x4, int32x4_value_t, X, 4)
-
-#define SIMD128_STORE_RUNTIME_FUNCTION(Type, ValueType, Lanes, Lanes_count, \
-                                       Bytes)                               \
-  RUNTIME_FUNCTION(Runtime_##Type##Store##Lanes) {                          \
-    HandleScope scope(isolate);                                             \
-    DCHECK(args.length() == 3);                                             \
-    CONVERT_ARG_HANDLE_CHECKED(JSArrayBuffer, buffer, 0);                   \
-    CONVERT_NUMBER_ARG_HANDLE_CHECKED(offset, 1);                           \
-    CONVERT_ARG_CHECKED(Type, value, 2);                                    \
-    ValueType v;                                                            \
-    for (uint32_t count = 0; count < Lanes_count; count++) {                \
-      v.storage[count] = value->get_lane(count);                            \
-    }                                                                       \
-    if (SimdTypeStoreValue<ValueType, Bytes>(isolate, buffer, offset, v)) { \
-      return isolate->heap()->undefined_value();                            \
-    } else {                                                                \
-      THROW_NEW_ERROR_RETURN_FAILURE(                                       \
-          isolate, NewRangeError(MessageTemplate::kInvalidOffset));         \
-    }                                                                       \
-  }
-
-SIMD128_STORE_RUNTIME_FUNCTION(Float32x4, float32x4_value_t, XYZW, 4, 16)
-SIMD128_STORE_RUNTIME_FUNCTION(Float32x4, float32x4_value_t, XYZ, 3, 12)
-SIMD128_STORE_RUNTIME_FUNCTION(Float32x4, float32x4_value_t, XY, 2, 8)
-SIMD128_STORE_RUNTIME_FUNCTION(Float32x4, float32x4_value_t, X, 1, 4)
-SIMD128_STORE_RUNTIME_FUNCTION(Int32x4, int32x4_value_t, XYZW, 4, 16)
-SIMD128_STORE_RUNTIME_FUNCTION(Int32x4, int32x4_value_t, XYZ, 3, 12)
-SIMD128_STORE_RUNTIME_FUNCTION(Int32x4, int32x4_value_t, XY, 2, 8)
-SIMD128_STORE_RUNTIME_FUNCTION(Int32x4, int32x4_value_t, X, 1, 4)
-
 //-------------------------------------------------------------------
 
 }  // namespace internal
diff --git a/src/runtime/runtime.h b/src/runtime/runtime.h
index 5b57d5ce28..0bd537b2f6 100644
--- a/src/runtime/runtime.h
+++ b/src/runtime/runtime.h
@@ -499,335 +499,6 @@ namespace internal {
   F(StoreLookupSlot_Sloppy, 2, 1)     \
   F(StoreLookupSlot_Strict, 2, 1)
 
-#define FOR_EACH_INTRINSIC_SIMD(F)     \
-  F(AllocateFloat32x4, 0, 1)           \
-  F(AllocateInt32x4, 0, 1)             \
-  F(AllocateBool32x4, 0, 1)            \
-  F(IsSimdValue, 1, 1)                 \
-  F(CreateFloat32x4, 4, 1)             \
-  F(CreateInt32x4, 4, 1)               \
-  F(CreateUint32x4, 4, 1)              \
-  F(CreateBool32x4, 4, 1)              \
-  F(CreateInt16x8, 8, 1)               \
-  F(CreateUint16x8, 8, 1)              \
-  F(CreateBool16x8, 8, 1)              \
-  F(CreateInt8x16, 16, 1)              \
-  F(CreateUint8x16, 16, 1)             \
-  F(CreateBool8x16, 16, 1)             \
-  F(Float32x4Check, 1, 1)              \
-  F(Float32x4ExtractLane, 2, 1)        \
-  F(Float32x4ReplaceLane, 3, 1)        \
-  F(Float32x4Abs, 1, 1)                \
-  F(Float32x4Neg, 1, 1)                \
-  F(Float32x4Sqrt, 1, 1)               \
-  F(Float32x4RecipApprox, 1, 1)        \
-  F(Float32x4RecipSqrtApprox, 1, 1)    \
-  F(Float32x4Add, 2, 1)                \
-  F(Float32x4Sub, 2, 1)                \
-  F(Float32x4Mul, 2, 1)                \
-  F(Float32x4Div, 2, 1)                \
-  F(Float32x4Min, 2, 1)                \
-  F(Float32x4Max, 2, 1)                \
-  F(Float32x4MinNum, 2, 1)             \
-  F(Float32x4MaxNum, 2, 1)             \
-  F(Float32x4Equal, 2, 1)              \
-  F(Float32x4NotEqual, 2, 1)           \
-  F(Float32x4LessThan, 2, 1)           \
-  F(Float32x4LessThanOrEqual, 2, 1)    \
-  F(Float32x4GreaterThan, 2, 1)        \
-  F(Float32x4GreaterThanOrEqual, 2, 1) \
-  F(Float32x4Select, 3, 1)             \
-  F(Float32x4Swizzle, 5, 1)            \
-  F(Float32x4Shuffle, 6, 1)            \
-  F(Float32x4FromInt32x4, 1, 1)        \
-  F(Float32x4FromUint32x4, 1, 1)       \
-  F(Float32x4FromInt32x4Bits, 1, 1)    \
-  F(Float32x4FromUint32x4Bits, 1, 1)   \
-  F(Float32x4FromInt16x8Bits, 1, 1)    \
-  F(Float32x4FromUint16x8Bits, 1, 1)   \
-  F(Float32x4FromInt8x16Bits, 1, 1)    \
-  F(Float32x4FromUint8x16Bits, 1, 1)   \
-  F(Float32x4Load, 2, 1)               \
-  F(Float32x4Load1, 2, 1)              \
-  F(Float32x4Load2, 2, 1)              \
-  F(Float32x4Load3, 2, 1)              \
-  F(Float32x4Store, 3, 1)              \
-  F(Float32x4Store1, 3, 1)             \
-  F(Float32x4Store2, 3, 1)             \
-  F(Float32x4Store3, 3, 1)             \
-  F(Float32x4LoadX, 2, 1)              \
-  F(Float32x4LoadXY, 2, 1)             \
-  F(Float32x4LoadXYZ, 2, 1)            \
-  F(Float32x4LoadXYZW, 2, 1)           \
-  F(Float32x4StoreX, 3, 1)             \
-  F(Float32x4StoreXY, 3, 1)            \
-  F(Float32x4StoreXYZ, 3, 1)           \
-  F(Float32x4StoreXYZW, 3, 1)          \
-  F(Int32x4Check, 1, 1)                \
-  F(Int32x4ExtractLane, 2, 1)          \
-  F(Int32x4ReplaceLane, 3, 1)          \
-  F(Int32x4Neg, 1, 1)                  \
-  F(Int32x4Add, 2, 1)                  \
-  F(Int32x4Sub, 2, 1)                  \
-  F(Int32x4Mul, 2, 1)                  \
-  F(Int32x4Min, 2, 1)                  \
-  F(Int32x4Max, 2, 1)                  \
-  F(Int32x4And, 2, 1)                  \
-  F(Int32x4Or, 2, 1)                   \
-  F(Int32x4Xor, 2, 1)                  \
-  F(Int32x4Not, 1, 1)                  \
-  F(Int32x4ShiftLeftByScalar, 2, 1)    \
-  F(Int32x4ShiftRightByScalar, 2, 1)   \
-  F(Int32x4Equal, 2, 1)                \
-  F(Int32x4NotEqual, 2, 1)             \
-  F(Int32x4LessThan, 2, 1)             \
-  F(Int32x4LessThanOrEqual, 2, 1)      \
-  F(Int32x4GreaterThan, 2, 1)          \
-  F(Int32x4GreaterThanOrEqual, 2, 1)   \
-  F(Int32x4Select, 3, 1)               \
-  F(Int32x4Swizzle, 5, 1)              \
-  F(Int32x4Shuffle, 6, 1)              \
-  F(Int32x4FromFloat32x4, 1, 1)        \
-  F(Int32x4FromUint32x4, 1, 1)         \
-  F(Int32x4FromFloat32x4Bits, 1, 1)    \
-  F(Int32x4FromUint32x4Bits, 1, 1)     \
-  F(Int32x4FromInt16x8Bits, 1, 1)      \
-  F(Int32x4FromUint16x8Bits, 1, 1)     \
-  F(Int32x4FromInt8x16Bits, 1, 1)      \
-  F(Int32x4FromUint8x16Bits, 1, 1)     \
-  F(Int32x4Load, 2, 1)                 \
-  F(Int32x4Load1, 2, 1)                \
-  F(Int32x4Load2, 2, 1)                \
-  F(Int32x4Load3, 2, 1)                \
-  F(Int32x4Store, 3, 1)                \
-  F(Int32x4Store1, 3, 1)               \
-  F(Int32x4Store2, 3, 1)               \
-  F(Int32x4Store3, 3, 1)               \
-  F(Int32x4LoadX, 2, 1)                \
-  F(Int32x4LoadXY, 2, 1)               \
-  F(Int32x4LoadXYZ, 2, 1)              \
-  F(Int32x4LoadXYZW, 2, 1)             \
-  F(Int32x4StoreX, 3, 1)               \
-  F(Int32x4StoreXY, 3, 1)              \
-  F(Int32x4StoreXYZ, 3, 1)             \
-  F(Int32x4StoreXYZW, 3, 1)            \
-  F(Uint32x4Check, 1, 1)               \
-  F(Uint32x4ExtractLane, 2, 1)         \
-  F(Uint32x4ReplaceLane, 3, 1)         \
-  F(Uint32x4Add, 2, 1)                 \
-  F(Uint32x4Sub, 2, 1)                 \
-  F(Uint32x4Mul, 2, 1)                 \
-  F(Uint32x4Min, 2, 1)                 \
-  F(Uint32x4Max, 2, 1)                 \
-  F(Uint32x4And, 2, 1)                 \
-  F(Uint32x4Or, 2, 1)                  \
-  F(Uint32x4Xor, 2, 1)                 \
-  F(Uint32x4Not, 1, 1)                 \
-  F(Uint32x4ShiftLeftByScalar, 2, 1)   \
-  F(Uint32x4ShiftRightByScalar, 2, 1)  \
-  F(Uint32x4Equal, 2, 1)               \
-  F(Uint32x4NotEqual, 2, 1)            \
-  F(Uint32x4LessThan, 2, 1)            \
-  F(Uint32x4LessThanOrEqual, 2, 1)     \
-  F(Uint32x4GreaterThan, 2, 1)         \
-  F(Uint32x4GreaterThanOrEqual, 2, 1)  \
-  F(Uint32x4Select, 3, 1)              \
-  F(Uint32x4Swizzle, 5, 1)             \
-  F(Uint32x4Shuffle, 6, 1)             \
-  F(Uint32x4FromFloat32x4, 1, 1)       \
-  F(Uint32x4FromInt32x4, 1, 1)         \
-  F(Uint32x4FromFloat32x4Bits, 1, 1)   \
-  F(Uint32x4FromInt32x4Bits, 1, 1)     \
-  F(Uint32x4FromInt16x8Bits, 1, 1)     \
-  F(Uint32x4FromUint16x8Bits, 1, 1)    \
-  F(Uint32x4FromInt8x16Bits, 1, 1)     \
-  F(Uint32x4FromUint8x16Bits, 1, 1)    \
-  F(Uint32x4Load, 2, 1)                \
-  F(Uint32x4Load1, 2, 1)               \
-  F(Uint32x4Load2, 2, 1)               \
-  F(Uint32x4Load3, 2, 1)               \
-  F(Uint32x4Store, 3, 1)               \
-  F(Uint32x4Store1, 3, 1)              \
-  F(Uint32x4Store2, 3, 1)              \
-  F(Uint32x4Store3, 3, 1)              \
-  F(Bool32x4Check, 1, 1)               \
-  F(Bool32x4ExtractLane, 2, 1)         \
-  F(Bool32x4ReplaceLane, 3, 1)         \
-  F(Bool32x4And, 2, 1)                 \
-  F(Bool32x4Or, 2, 1)                  \
-  F(Bool32x4Xor, 2, 1)                 \
-  F(Bool32x4Not, 1, 1)                 \
-  F(Bool32x4AnyTrue, 1, 1)             \
-  F(Bool32x4AllTrue, 1, 1)             \
-  F(Bool32x4Swizzle, 5, 1)             \
-  F(Bool32x4Shuffle, 6, 1)             \
-  F(Bool32x4Equal, 2, 1)               \
-  F(Bool32x4NotEqual, 2, 1)            \
-  F(Int16x8Check, 1, 1)                \
-  F(Int16x8ExtractLane, 2, 1)          \
-  F(Int16x8ReplaceLane, 3, 1)          \
-  F(Int16x8Neg, 1, 1)                  \
-  F(Int16x8Add, 2, 1)                  \
-  F(Int16x8AddSaturate, 2, 1)          \
-  F(Int16x8Sub, 2, 1)                  \
-  F(Int16x8SubSaturate, 2, 1)          \
-  F(Int16x8Mul, 2, 1)                  \
-  F(Int16x8Min, 2, 1)                  \
-  F(Int16x8Max, 2, 1)                  \
-  F(Int16x8And, 2, 1)                  \
-  F(Int16x8Or, 2, 1)                   \
-  F(Int16x8Xor, 2, 1)                  \
-  F(Int16x8Not, 1, 1)                  \
-  F(Int16x8ShiftLeftByScalar, 2, 1)    \
-  F(Int16x8ShiftRightByScalar, 2, 1)   \
-  F(Int16x8Equal, 2, 1)                \
-  F(Int16x8NotEqual, 2, 1)             \
-  F(Int16x8LessThan, 2, 1)             \
-  F(Int16x8LessThanOrEqual, 2, 1)      \
-  F(Int16x8GreaterThan, 2, 1)          \
-  F(Int16x8GreaterThanOrEqual, 2, 1)   \
-  F(Int16x8Select, 3, 1)               \
-  F(Int16x8Swizzle, 9, 1)              \
-  F(Int16x8Shuffle, 10, 1)             \
-  F(Int16x8FromUint16x8, 1, 1)         \
-  F(Int16x8FromFloat32x4Bits, 1, 1)    \
-  F(Int16x8FromInt32x4Bits, 1, 1)      \
-  F(Int16x8FromUint32x4Bits, 1, 1)     \
-  F(Int16x8FromUint16x8Bits, 1, 1)     \
-  F(Int16x8FromInt8x16Bits, 1, 1)      \
-  F(Int16x8FromUint8x16Bits, 1, 1)     \
-  F(Int16x8Load, 2, 1)                 \
-  F(Int16x8Store, 3, 1)                \
-  F(Uint16x8Check, 1, 1)               \
-  F(Uint16x8ExtractLane, 2, 1)         \
-  F(Uint16x8ReplaceLane, 3, 1)         \
-  F(Uint16x8Add, 2, 1)                 \
-  F(Uint16x8AddSaturate, 2, 1)         \
-  F(Uint16x8Sub, 2, 1)                 \
-  F(Uint16x8SubSaturate, 2, 1)         \
-  F(Uint16x8Mul, 2, 1)                 \
-  F(Uint16x8Min, 2, 1)                 \
-  F(Uint16x8Max, 2, 1)                 \
-  F(Uint16x8And, 2, 1)                 \
-  F(Uint16x8Or, 2, 1)                  \
-  F(Uint16x8Xor, 2, 1)                 \
-  F(Uint16x8Not, 1, 1)                 \
-  F(Uint16x8ShiftLeftByScalar, 2, 1)   \
-  F(Uint16x8ShiftRightByScalar, 2, 1)  \
-  F(Uint16x8Equal, 2, 1)               \
-  F(Uint16x8NotEqual, 2, 1)            \
-  F(Uint16x8LessThan, 2, 1)            \
-  F(Uint16x8LessThanOrEqual, 2, 1)     \
-  F(Uint16x8GreaterThan, 2, 1)         \
-  F(Uint16x8GreaterThanOrEqual, 2, 1)  \
-  F(Uint16x8Select, 3, 1)              \
-  F(Uint16x8Swizzle, 9, 1)             \
-  F(Uint16x8Shuffle, 10, 1)            \
-  F(Uint16x8FromInt16x8, 1, 1)         \
-  F(Uint16x8FromFloat32x4Bits, 1, 1)   \
-  F(Uint16x8FromInt32x4Bits, 1, 1)     \
-  F(Uint16x8FromUint32x4Bits, 1, 1)    \
-  F(Uint16x8FromInt16x8Bits, 1, 1)     \
-  F(Uint16x8FromInt8x16Bits, 1, 1)     \
-  F(Uint16x8FromUint8x16Bits, 1, 1)    \
-  F(Uint16x8Load, 2, 1)                \
-  F(Uint16x8Store, 3, 1)               \
-  F(Bool16x8Check, 1, 1)               \
-  F(Bool16x8ExtractLane, 2, 1)         \
-  F(Bool16x8ReplaceLane, 3, 1)         \
-  F(Bool16x8And, 2, 1)                 \
-  F(Bool16x8Or, 2, 1)                  \
-  F(Bool16x8Xor, 2, 1)                 \
-  F(Bool16x8Not, 1, 1)                 \
-  F(Bool16x8AnyTrue, 1, 1)             \
-  F(Bool16x8AllTrue, 1, 1)             \
-  F(Bool16x8Swizzle, 9, 1)             \
-  F(Bool16x8Shuffle, 10, 1)            \
-  F(Bool16x8Equal, 2, 1)               \
-  F(Bool16x8NotEqual, 2, 1)            \
-  F(Int8x16Check, 1, 1)                \
-  F(Int8x16ExtractLane, 2, 1)          \
-  F(Int8x16ReplaceLane, 3, 1)          \
-  F(Int8x16Neg, 1, 1)                  \
-  F(Int8x16Add, 2, 1)                  \
-  F(Int8x16AddSaturate, 2, 1)          \
-  F(Int8x16Sub, 2, 1)                  \
-  F(Int8x16SubSaturate, 2, 1)          \
-  F(Int8x16Mul, 2, 1)                  \
-  F(Int8x16Min, 2, 1)                  \
-  F(Int8x16Max, 2, 1)                  \
-  F(Int8x16And, 2, 1)                  \
-  F(Int8x16Or, 2, 1)                   \
-  F(Int8x16Xor, 2, 1)                  \
-  F(Int8x16Not, 1, 1)                  \
-  F(Int8x16ShiftLeftByScalar, 2, 1)    \
-  F(Int8x16ShiftRightByScalar, 2, 1)   \
-  F(Int8x16Equal, 2, 1)                \
-  F(Int8x16NotEqual, 2, 1)             \
-  F(Int8x16LessThan, 2, 1)             \
-  F(Int8x16LessThanOrEqual, 2, 1)      \
-  F(Int8x16GreaterThan, 2, 1)          \
-  F(Int8x16GreaterThanOrEqual, 2, 1)   \
-  F(Int8x16Select, 3, 1)               \
-  F(Int8x16Swizzle, 17, 1)             \
-  F(Int8x16Shuffle, 18, 1)             \
-  F(Int8x16FromUint8x16, 1, 1)         \
-  F(Int8x16FromFloat32x4Bits, 1, 1)    \
-  F(Int8x16FromInt32x4Bits, 1, 1)      \
-  F(Int8x16FromUint32x4Bits, 1, 1)     \
-  F(Int8x16FromInt16x8Bits, 1, 1)      \
-  F(Int8x16FromUint16x8Bits, 1, 1)     \
-  F(Int8x16FromUint8x16Bits, 1, 1)     \
-  F(Int8x16Load, 2, 1)                 \
-  F(Int8x16Store, 3, 1)                \
-  F(Uint8x16Check, 1, 1)               \
-  F(Uint8x16ExtractLane, 2, 1)         \
-  F(Uint8x16ReplaceLane, 3, 1)         \
-  F(Uint8x16Add, 2, 1)                 \
-  F(Uint8x16AddSaturate, 2, 1)         \
-  F(Uint8x16Sub, 2, 1)                 \
-  F(Uint8x16SubSaturate, 2, 1)         \
-  F(Uint8x16Mul, 2, 1)                 \
-  F(Uint8x16Min, 2, 1)                 \
-  F(Uint8x16Max, 2, 1)                 \
-  F(Uint8x16And, 2, 1)                 \
-  F(Uint8x16Or, 2, 1)                  \
-  F(Uint8x16Xor, 2, 1)                 \
-  F(Uint8x16Not, 1, 1)                 \
-  F(Uint8x16ShiftLeftByScalar, 2, 1)   \
-  F(Uint8x16ShiftRightByScalar, 2, 1)  \
-  F(Uint8x16Equal, 2, 1)               \
-  F(Uint8x16NotEqual, 2, 1)            \
-  F(Uint8x16LessThan, 2, 1)            \
-  F(Uint8x16LessThanOrEqual, 2, 1)     \
-  F(Uint8x16GreaterThan, 2, 1)         \
-  F(Uint8x16GreaterThanOrEqual, 2, 1)  \
-  F(Uint8x16Select, 3, 1)              \
-  F(Uint8x16Swizzle, 17, 1)            \
-  F(Uint8x16Shuffle, 18, 1)            \
-  F(Uint8x16FromInt8x16, 1, 1)         \
-  F(Uint8x16FromFloat32x4Bits, 1, 1)   \
-  F(Uint8x16FromInt32x4Bits, 1, 1)     \
-  F(Uint8x16FromUint32x4Bits, 1, 1)    \
-  F(Uint8x16FromInt16x8Bits, 1, 1)     \
-  F(Uint8x16FromUint16x8Bits, 1, 1)    \
-  F(Uint8x16FromInt8x16Bits, 1, 1)     \
-  F(Uint8x16Load, 2, 1)                \
-  F(Uint8x16Store, 3, 1)               \
-  F(Bool8x16Check, 1, 1)               \
-  F(Bool8x16ExtractLane, 2, 1)         \
-  F(Bool8x16ReplaceLane, 3, 1)         \
-  F(Bool8x16And, 2, 1)                 \
-  F(Bool8x16Or, 2, 1)                  \
-  F(Bool8x16Xor, 2, 1)                 \
-  F(Bool8x16Not, 1, 1)                 \
-  F(Bool8x16AnyTrue, 1, 1)             \
-  F(Bool8x16AllTrue, 1, 1)             \
-  F(Bool8x16Swizzle, 17, 1)            \
-  F(Bool8x16Shuffle, 18, 1)            \
-  F(Bool8x16Equal, 2, 1)               \
-  F(Bool8x16NotEqual, 2, 1)
-
 #define FOR_EACH_INTRINSIC_STRINGS(F)     \
   F(StringReplaceOneCharWithString, 3, 1) \
   F(StringIndexOf, 3, 1)                  \
@@ -1009,7 +680,6 @@ namespace internal {
   FOR_EACH_INTRINSIC_PROXY(F)               \
   FOR_EACH_INTRINSIC_REGEXP(F)              \
   FOR_EACH_INTRINSIC_SCOPES(F)              \
-  FOR_EACH_INTRINSIC_SIMD(F)                \
   FOR_EACH_INTRINSIC_STRINGS(F)             \
   FOR_EACH_INTRINSIC_SYMBOL(F)              \
   FOR_EACH_INTRINSIC_TEST(F)                \
diff --git a/src/tracing/trace-event.h b/src/tracing/trace-event.h
index 2b3bf9bf92..6deac1216a 100644
--- a/src/tracing/trace-event.h
+++ b/src/tracing/trace-event.h
@@ -76,7 +76,7 @@ enum CategoryGroupEnabledFlags {
 
 
 #define INTERNAL_TRACE_EVENT_CATEGORY_GROUP_ENABLED_FOR_RECORDING_MODE() \
-  *INTERNAL_TRACE_EVENT_UID(category_group_enabled) &                    \
+  false&&*INTERNAL_TRACE_EVENT_UID(category_group_enabled) &                    \
       (kEnabledForRecording_CategoryGroupEnabledFlags |                  \
        kEnabledForEventCallback_CategoryGroupEnabledFlags)
 
@@ -98,9 +98,9 @@ enum CategoryGroupEnabledFlags {
 // for best performance when tracing is disabled.
 // const uint8_t*
 //     TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(const char* category_group)
-#define TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED              \
-  v8::internal::tracing::TraceEventHelper::GetCurrentPlatform() \
-      ->GetCategoryGroupEnabled
+#define TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(cg)              \
+  true ? (uint8_t*)"\0" : v8::internal::tracing::TraceEventHelper::GetCurrentPlatform() \
+      ->GetCategoryGroupEnabled(cg)
 
 // Get the number of times traces have been recorded. This is used to implement
 // the TRACE_EVENT_IS_NEW_TRACE facility.
diff --git a/src/type-info.cc b/src/type-info.cc
index 61af125c47..19461aa789 100644
--- a/src/type-info.cc
+++ b/src/type-info.cc
@@ -63,8 +63,7 @@ Handle<Object> TypeFeedbackOracle::GetInfo(FeedbackVectorSlot slot) {
     obj = cell->value();
   }
 
-  if (obj->IsJSFunction() || obj->IsAllocationSite() || obj->IsSymbol() ||
-      obj->IsSimd128Value()) {
+  if (obj->IsJSFunction() || obj->IsAllocationSite() || obj->IsSymbol()) {
     return Handle<Object>(obj, isolate());
   }
 
diff --git a/src/types.cc b/src/types.cc
index 9451686b9d..4d7fea9158 100644
--- a/src/types.cc
+++ b/src/types.cc
@@ -198,8 +198,6 @@ Type::bitset BitsetType::Lub(i::Map* map) {
     }
     case HEAP_NUMBER_TYPE:
       return kNumber & kTaggedPointer;
-    case SIMD128_VALUE_TYPE:
-      return kSimd;
     case JS_OBJECT_TYPE:
     case JS_ARGUMENTS_TYPE:
     case JS_ERROR_TYPE:
@@ -230,11 +228,6 @@ Type::bitset BitsetType::Lub(i::Map* map) {
     case JS_BOUND_FUNCTION_TYPE:
       DCHECK(!map->is_undetectable());
       return kOtherObject;
-    case FLOAT32x4_TYPE:
-    case INT32x4_TYPE:
-    case BOOL32x4_TYPE:
-      if (map->is_undetectable()) return kUndetectable;
-      return kOtherObject;
     case JS_FUNCTION_TYPE:
       DCHECK(!map->is_undetectable());
       return kFunction;
@@ -1267,12 +1260,6 @@ BitsetType::bitset BitsetType::UnsignedSmall() {
   return i::SmiValuesAre31Bits() ? kUnsigned30 : kUnsigned31;
 }
 
-#define CONSTRUCT_SIMD_TYPE(NAME, Name, name, lane_count, lane_type) \
-  Type* Type::Name(Isolate* isolate, Zone* zone) {                   \
-    return Class(i::handle(isolate->heap()->name##_map()), zone);    \
-  }
-SIMD128_TYPES(CONSTRUCT_SIMD_TYPE)
-#undef CONSTRUCT_SIMD_TYPE
 
 // -----------------------------------------------------------------------------
 // Instantiations.
diff --git a/src/types.h b/src/types.h
index 254183873b..2e6421765a 100644
--- a/src/types.h
+++ b/src/types.h
@@ -165,7 +165,6 @@ namespace internal {
   V(UntaggedIntegral32, 1u << 25 | kSemantic) \
   V(UntaggedFloat32,    1u << 26 | kSemantic) \
   V(UntaggedFloat64,    1u << 27 | kSemantic) \
-  V(UntaggedSimd128,    1u << 28 | kSemantic) \
   V(UntaggedPointer,    1u << 29 | kSemantic) \
   V(TaggedSigned,       1u << 30 | kSemantic) \
   V(TaggedPointer,      1u << 31 | kSemantic) \
@@ -194,7 +193,6 @@ namespace internal {
   V(Symbol,              1u << 12 | REPRESENTATION(kTaggedPointer)) \
   V(InternalizedString,  1u << 13 | REPRESENTATION(kTaggedPointer)) \
   V(OtherString,         1u << 14 | REPRESENTATION(kTaggedPointer)) \
-  V(Simd,                1u << 15 | REPRESENTATION(kTaggedPointer)) \
   V(OtherObject,         1u << 17 | REPRESENTATION(kTaggedPointer)) \
   V(OtherUndetectable,   1u << 16 | REPRESENTATION(kTaggedPointer)) \
   V(Proxy,               1u << 18 | REPRESENTATION(kTaggedPointer)) \
@@ -220,11 +218,10 @@ namespace internal {
   V(NullOrUndefined,          kNull | kUndefined) \
   V(Undetectable,             kNullOrUndefined | kOtherUndetectable) \
   V(NumberOrOddball,          kNumber | kNullOrUndefined | kBoolean) \
-  V(NumberOrSimdOrString,     kNumber | kSimd | kString) \
   V(NumberOrString,           kNumber | kString) \
   V(NumberOrUndefined,        kNumber | kUndefined) \
   V(PlainPrimitive,           kNumberOrString | kBoolean | kNullOrUndefined) \
-  V(Primitive,                kSymbol | kSimd | kPlainPrimitive) \
+  V(Primitive,                kSymbol | kPlainPrimitive) \
   V(DetectableReceiver,       kFunction | kOtherObject | kProxy) \
   V(Object,                   kFunction | kOtherObject | kOtherUndetectable) \
   V(Receiver,                 kObject | kProxy) \
@@ -738,11 +735,6 @@ class Type {
     return tuple;
   }
 
-#define CONSTRUCT_SIMD_TYPE(NAME, Name, name, lane_count, lane_type) \
-  static Type* Name(Isolate* isolate, Zone* zone);
-  SIMD128_TYPES(CONSTRUCT_SIMD_TYPE)
-#undef CONSTRUCT_SIMD_TYPE
-
   static Type* Union(Type* type1, Type* type2, Zone* zone);
   static Type* Intersect(Type* type1, Type* type2, Zone* zone);
 
diff --git a/src/typing-asm.cc b/src/typing-asm.cc
index 2390e7e7b1..336b9078c1 100644
--- a/src/typing-asm.cc
+++ b/src/typing-asm.cc
@@ -49,10 +49,6 @@ AsmTyper::AsmTyper(Isolate* isolate, Zone* zone, Script* script,
       stdlib_types_(zone),
       stdlib_heap_types_(zone),
       stdlib_math_types_(zone),
-#define V(NAME, Name, name, lane_count, lane_type) \
-  stdlib_simd_##name##_types_(zone),
-      SIMD128_TYPES(V)
-#undef V
           global_variable_type_(base::HashMap::PointersMatch,
                                 ZoneHashMap::kDefaultHashMapCapacity,
                                 ZoneAllocationPolicy(zone)),
@@ -890,36 +886,11 @@ bool AsmTyper::IsMathObject(Expression* expr) {
 }
 
 
-bool AsmTyper::IsSIMDObject(Expression* expr) {
-  Expression* obj = GetReceiverOfPropertyAccess(expr, "SIMD");
-  return obj && IsStdlibObject(obj);
-}
-
-
-bool AsmTyper::IsSIMDTypeObject(Expression* expr, const char* name) {
-  Expression* obj = GetReceiverOfPropertyAccess(expr, name);
-  return obj && IsSIMDObject(obj);
-}
-
-
 void AsmTyper::VisitProperty(Property* expr) {
   if (IsMathObject(expr->obj())) {
     VisitLibraryAccess(&stdlib_math_types_, expr);
     return;
   }
-#define V(NAME, Name, name, lane_count, lane_type)               \
-  if (IsSIMDTypeObject(expr->obj(), #Name)) {                    \
-    VisitLibraryAccess(&stdlib_simd_##name##_types_, expr);      \
-    return;                                                      \
-  }                                                              \
-  if (IsSIMDTypeObject(expr, #Name)) {                           \
-    VariableInfo* info = stdlib_simd_##name##_constructor_type_; \
-    SetResult(expr, info->type);                                 \
-    property_info_ = info;                                       \
-    return;                                                      \
-  }
-  SIMD128_TYPES(V)
-#undef V
   if (IsStdlibObject(expr->obj())) {
     VisitLibraryAccess(&stdlib_types_, expr);
     return;
@@ -1430,26 +1401,7 @@ void AsmTyper::VisitSuperCallReference(SuperCallReference* expr) {
 }
 
 
-void AsmTyper::InitializeStdlibSIMD() {
-#define V(NAME, Name, name, lane_count, lane_type)                            \
-  {                                                                           \
-    Type* type = Type::Function(Type::Name(isolate_, zone()), Type::Any(),    \
-                                lane_count, zone());                          \
-    for (int i = 0; i < lane_count; ++i) {                                    \
-      type->AsFunction()->InitParameter(i, Type::Number());                   \
-    }                                                                         \
-    stdlib_simd_##name##_constructor_type_ = new (zone()) VariableInfo(type); \
-    stdlib_simd_##name##_constructor_type_->is_constructor_function = true;   \
-  }
-  SIMD128_TYPES(V)
-#undef V
-}
-
-
 void AsmTyper::InitializeStdlib() {
-  if (allow_simd_) {
-    InitializeStdlibSIMD();
-  }
   Type* number_type = Type::Number();
   Type* double_type = cache_.kAsmDouble;
   Type* double_fn1_type = Type::Function(double_type, double_type, zone());
diff --git a/src/typing-asm.h b/src/typing-asm.h
index 09eacaa0ae..6ae13af777 100644
--- a/src/typing-asm.h
+++ b/src/typing-asm.h
@@ -103,11 +103,6 @@ class AsmTyper : public AstVisitor {
   ObjectTypeMap stdlib_types_;
   ObjectTypeMap stdlib_heap_types_;
   ObjectTypeMap stdlib_math_types_;
-#define V(NAME, Name, name, lane_count, lane_type) \
-  ObjectTypeMap stdlib_simd_##name##_types_;       \
-  VariableInfo* stdlib_simd_##name##_constructor_type_;
-  SIMD128_TYPES(V)
-#undef V
 
   // Map from Variable* to global/local variable Type*.
   ZoneHashMap global_variable_type_;
@@ -128,7 +123,6 @@ class AsmTyper : public AstVisitor {
   static const int kMaxUncombinedMultiplicativeSteps = 1;
 
   void InitializeStdlib();
-  void InitializeStdlibSIMD();
 
   void VisitDeclarations(ZoneList<Declaration*>* d) override;
   void VisitStatements(ZoneList<Statement*>* s) override;
@@ -144,12 +138,8 @@ class AsmTyper : public AstVisitor {
 
   Expression* GetReceiverOfPropertyAccess(Expression* expr, const char* name);
   bool IsMathObject(Expression* expr);
-  bool IsSIMDObject(Expression* expr);
-  bool IsSIMDTypeObject(Expression* expr, const char* name);
   bool IsStdlibObject(Expression* expr);
 
-  void VisitSIMDProperty(Property* expr);
-
   int ElementShiftSize(Type* type);
   Type* StorageType(Type* type);
 
diff --git a/src/wasm/wasm-js.cc b/src/wasm/wasm-js.cc
index 6dc14952a0..f6ebbeb0e6 100644
--- a/src/wasm/wasm-js.cc
+++ b/src/wasm/wasm-js.cc
@@ -146,9 +146,6 @@ v8::internal::wasm::ZoneBuffer* TranslateAsmModule(
 
   v8::internal::AsmTyper typer(info->isolate(), info->zone(), *(info->script()),
                                info->literal());
-  if (i::FLAG_enable_simd_asmjs) {
-    typer.set_allow_simd(true);
-  }
   if (!typer.Validate()) {
     thrower->Error("Asm.js validation failed: %s", typer.error_message());
     return nullptr;
diff --git a/src/x64/assembler-x64-inl.h b/src/x64/assembler-x64-inl.h
index 9850b716cc..60acacd3bb 100644
--- a/src/x64/assembler-x64-inl.h
+++ b/src/x64/assembler-x64-inl.h
@@ -15,7 +15,7 @@ namespace v8 {
 namespace internal {
 
 bool CpuFeatures::SupportsCrankshaft() { return true; }
-bool CpuFeatures::SupportsSIMD128InCrankshaft() { return true; }
+
 
 // -----------------------------------------------------------------------------
 // Implementation of Assembler
diff --git a/src/x64/assembler-x64.cc b/src/x64/assembler-x64.cc
index e5e80c7d41..3345e30538 100644
--- a/src/x64/assembler-x64.cc
+++ b/src/x64/assembler-x64.cc
@@ -2701,77 +2701,6 @@ void Assembler::divps(XMMRegister dst, const Operand& src) {
   emit_sse_operand(dst, src);
 }
 
-void Assembler::addpd(XMMRegister dst, XMMRegister src) {
-  EnsureSpace ensure_space(this);
-  emit(0x66);
-  emit_optional_rex_32(dst, src);
-  emit(0x0F);
-  emit(0x58);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::addpd(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  emit(0x66);
-  emit_optional_rex_32(dst, src);
-  emit(0x0F);
-  emit(0x58);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::subpd(XMMRegister dst, XMMRegister src) {
-  EnsureSpace ensure_space(this);
-  emit(0x66);
-  emit_optional_rex_32(dst, src);
-  emit(0x0F);
-  emit(0x5C);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::subpd(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  emit(0x66);
-  emit_optional_rex_32(dst, src);
-  emit(0x0F);
-  emit(0x5C);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::mulpd(XMMRegister dst, XMMRegister src) {
-  EnsureSpace ensure_space(this);
-  emit(0x66);
-  emit_optional_rex_32(dst, src);
-  emit(0x0F);
-  emit(0x59);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::mulpd(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  emit(0x66);
-  emit_optional_rex_32(dst, src);
-  emit(0x0F);
-  emit(0x59);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::divpd(XMMRegister dst, XMMRegister src) {
-  EnsureSpace ensure_space(this);
-  emit(0x66);
-  emit_optional_rex_32(dst, src);
-  emit(0x0F);
-  emit(0x5E);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::divpd(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  emit(0x66);
-  emit_optional_rex_32(dst, src);
-  emit(0x0F);
-  emit(0x5E);
-  emit_sse_operand(dst, src);
-}
 
 // SSE 2 operations.
 
@@ -2916,6 +2845,7 @@ void Assembler::pextrd(Register dst, XMMRegister src, int8_t imm8) {
   emit(imm8);
 }
 
+
 void Assembler::pinsrd(XMMRegister dst, Register src, int8_t imm8) {
   DCHECK(IsEnabled(SSE4_1));
   EnsureSpace ensure_space(this);
@@ -3004,21 +2934,11 @@ void Assembler::movaps(XMMRegister dst, XMMRegister src) {
   }
 }
 
-void Assembler::shufps(XMMRegister dst, XMMRegister src, byte imm8) {
-  DCHECK(is_uint8(imm8));
-  EnsureSpace ensure_space(this);
-  emit_optional_rex_32(dst, src);
-  emit(0x0F);
-  emit(0xC6);
-  emit_sse_operand(dst, src);
-  emit(imm8);
-}
 
-void Assembler::shufpd(XMMRegister dst, XMMRegister src, byte imm8) {
+void Assembler::shufps(XMMRegister dst, XMMRegister src, byte imm8) {
   DCHECK(is_uint8(imm8));
   EnsureSpace ensure_space(this);
-  emit(0x66);
-  emit_optional_rex_32(dst, src);
+  emit_optional_rex_32(src, dst);
   emit(0x0F);
   emit(0xC6);
   emit_sse_operand(dst, src);
@@ -3284,6 +3204,39 @@ void Assembler::psrld(XMMRegister reg, byte imm8) {
   emit(imm8);
 }
 
+void Assembler::cmpps(XMMRegister dst, XMMRegister src, int8_t cmp) {
+  EnsureSpace ensure_space(this);
+  emit_optional_rex_32(dst, src);
+  emit(0x0F);
+  emit(0xC2);
+  emit_sse_operand(dst, src);
+  emit(cmp);
+}
+
+void Assembler::cmpeqps(XMMRegister dst, XMMRegister src) {
+  cmpps(dst, src, 0x0);
+}
+
+void Assembler::cmpltps(XMMRegister dst, XMMRegister src) {
+  cmpps(dst, src, 0x1);
+}
+
+void Assembler::cmpleps(XMMRegister dst, XMMRegister src) {
+  cmpps(dst, src, 0x2);
+}
+
+void Assembler::cmpneqps(XMMRegister dst, XMMRegister src) {
+  cmpps(dst, src, 0x4);
+}
+
+void Assembler::cmpnltps(XMMRegister dst, XMMRegister src) {
+  cmpps(dst, src, 0x5);
+}
+
+void Assembler::cmpnleps(XMMRegister dst, XMMRegister src) {
+  cmpps(dst, src, 0x6);
+}
+
 void Assembler::cvttss2si(Register dst, const Operand& src) {
   DCHECK(!IsEnabled(AVX));
   EnsureSpace ensure_space(this);
@@ -3654,14 +3607,6 @@ void Assembler::andpd(XMMRegister dst, XMMRegister src) {
   emit_sse_operand(dst, src);
 }
 
-void Assembler::andpd(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  emit(0x66);
-  emit_optional_rex_32(dst, src);
-  emit(0x0F);
-  emit(0x54);
-  emit_sse_operand(dst, src);
-}
 
 void Assembler::orpd(XMMRegister dst, XMMRegister src) {
   EnsureSpace ensure_space(this);
@@ -3683,14 +3628,6 @@ void Assembler::xorpd(XMMRegister dst, XMMRegister src) {
   emit_sse_operand(dst, src);
 }
 
-void Assembler::xorpd(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  emit(0x66);
-  emit_optional_rex_32(dst, src);
-  emit(0x0F);
-  emit(0x57);
-  emit_sse_operand(dst, src);
-}
 
 void Assembler::sqrtsd(XMMRegister dst, XMMRegister src) {
   DCHECK(!IsEnabled(AVX));
@@ -3761,84 +3698,6 @@ void Assembler::roundss(XMMRegister dst, XMMRegister src, RoundingMode mode) {
   emit(static_cast<byte>(mode) | 0x8);
 }
 
-void Assembler::cmpps(XMMRegister dst, XMMRegister src, int8_t cmp) {
-  EnsureSpace ensure_space(this);
-  emit_optional_rex_32(dst, src);
-  emit(0x0F);
-  emit(0xC2);
-  emit_sse_operand(dst, src);
-  emit(cmp);
-}
-
-void Assembler::cmpeqps(XMMRegister dst, XMMRegister src) {
-  cmpps(dst, src, 0x0);
-}
-
-void Assembler::cmpltps(XMMRegister dst, XMMRegister src) {
-  cmpps(dst, src, 0x1);
-}
-
-void Assembler::cmpleps(XMMRegister dst, XMMRegister src) {
-  cmpps(dst, src, 0x2);
-}
-
-void Assembler::cmpneqps(XMMRegister dst, XMMRegister src) {
-  cmpps(dst, src, 0x4);
-}
-
-void Assembler::cmpnltps(XMMRegister dst, XMMRegister src) {
-  cmpps(dst, src, 0x5);
-}
-
-void Assembler::cmpnleps(XMMRegister dst, XMMRegister src) {
-  cmpps(dst, src, 0x6);
-}
-
-void Assembler::pslld(XMMRegister dst, XMMRegister src) {
-  EnsureSpace ensure_space(this);
-  emit(0x66);
-  emit_optional_rex_32(dst, src);
-  emit(0x0F);
-  emit(0xF2);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::psrld(XMMRegister dst, XMMRegister src) {
-  EnsureSpace ensure_space(this);
-  emit(0x66);
-  emit_optional_rex_32(dst, src);
-  emit(0x0F);
-  emit(0xD2);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::psrad(XMMRegister reg, int8_t shift) {
-  EnsureSpace ensure_space(this);
-  emit(0x66);
-  emit_optional_rex_32(reg);
-  emit(0x0F);
-  emit(0x72);
-  emit_sse_operand(rsp, reg);  // rsp == 4
-  emit(shift);
-}
-
-void Assembler::psrad(XMMRegister dst, XMMRegister src) {
-  EnsureSpace ensure_space(this);
-  emit(0x66);
-  emit_optional_rex_32(dst, src);
-  emit(0x0F);
-  emit(0xE2);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::pcmpgtd(XMMRegister dst, XMMRegister src) {
-  EnsureSpace ensure_space(this);
-  emit(0x66);
-  emit_optional_rex_32(dst, src);
-  emit(0x0F);
-  emit(0x66);
-  emit_sse_operand(dst, src);
-}
 
 void Assembler::roundsd(XMMRegister dst, XMMRegister src, RoundingMode mode) {
   DCHECK(!IsEnabled(AVX));
@@ -4081,14 +3940,6 @@ void Assembler::vucomiss(XMMRegister dst, XMMRegister src) {
   emit_sse_operand(dst, src);
 }
 
-void Assembler::minpd(XMMRegister dst, XMMRegister src) {
-  EnsureSpace ensure_space(this);
-  emit(0x66);
-  emit_optional_rex_32(dst, src);
-  emit(0x0F);
-  emit(0x5D);
-  emit_sse_operand(dst, src);
-}
 
 void Assembler::vucomiss(XMMRegister dst, const Operand& src) {
   DCHECK(IsEnabled(AVX));
@@ -4098,14 +3949,6 @@ void Assembler::vucomiss(XMMRegister dst, const Operand& src) {
   emit_sse_operand(dst, src);
 }
 
-void Assembler::minpd(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  emit(0x66);
-  emit_optional_rex_32(dst, src);
-  emit(0x0F);
-  emit(0x5D);
-  emit_sse_operand(dst, src);
-}
 
 void Assembler::vss(byte op, XMMRegister dst, XMMRegister src1,
                     XMMRegister src2) {
@@ -4414,24 +4257,6 @@ void Assembler::maxps(XMMRegister dst, const Operand& src) {
   emit_sse_operand(dst, src);
 }
 
-void Assembler::maxpd(XMMRegister dst, XMMRegister src) {
-  EnsureSpace ensure_space(this);
-  emit(0x66);
-  emit_optional_rex_32(dst, src);
-  emit(0x0F);
-  emit(0x5F);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::maxpd(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  emit(0x66);
-  emit_optional_rex_32(dst, src);
-  emit(0x0F);
-  emit(0x5F);
-  emit_sse_operand(dst, src);
-}
-
 void Assembler::rcpps(XMMRegister dst, XMMRegister src) {
   EnsureSpace ensure_space(this);
   emit_optional_rex_32(dst, src);
@@ -4528,24 +4353,6 @@ void Assembler::movups(const Operand& dst, XMMRegister src) {
   emit_sse_operand(src, dst);
 }
 
-void Assembler::sqrtpd(XMMRegister dst, XMMRegister src) {
-  EnsureSpace ensure_space(this);
-  emit(0x66);
-  emit_optional_rex_32(dst, src);
-  emit(0x0F);
-  emit(0x51);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::sqrtpd(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  emit(0x66);
-  emit_optional_rex_32(dst, src);
-  emit(0x0F);
-  emit(0x51);
-  emit_sse_operand(dst, src);
-}
-
 void Assembler::paddd(XMMRegister dst, XMMRegister src) {
   EnsureSpace ensure_space(this);
   emit(0x66);
@@ -4621,24 +4428,6 @@ void Assembler::pmuludq(XMMRegister dst, const Operand& src) {
   emit_sse_operand(dst, src);
 }
 
-void Assembler::punpackldq(XMMRegister dst, XMMRegister src) {
-  EnsureSpace ensure_space(this);
-  emit(0x66);
-  emit_optional_rex_32(dst, src);
-  emit(0x0F);
-  emit(0x62);
-  emit_sse_operand(dst, src);
-}
-
-void Assembler::punpackldq(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
-  emit(0x66);
-  emit_optional_rex_32(dst, src);
-  emit(0x0F);
-  emit(0x62);
-  emit_sse_operand(dst, src);
-}
-
 void Assembler::psrldq(XMMRegister dst, uint8_t shift) {
   EnsureSpace ensure_space(this);
   emit(0x66);
diff --git a/src/x64/assembler-x64.h b/src/x64/assembler-x64.h
index fc7d03513a..a7759c32e1 100644
--- a/src/x64/assembler-x64.h
+++ b/src/x64/assembler-x64.h
@@ -249,8 +249,6 @@ DOUBLE_REGISTERS(DECLARE_REGISTER)
 #undef DECLARE_REGISTER
 const DoubleRegister no_double_reg = {DoubleRegister::kCode_no_reg};
 
-typedef DoubleRegister SIMD128Register;
-
 enum Condition {
   // any value < 0 is considered no_condition
   no_condition  = -1,
@@ -358,11 +356,11 @@ enum ScaleFactor {
   times_2 = 1,
   times_4 = 2,
   times_8 = 3,
-  maximal_scale_factor = times_8,
   times_int_size = times_4,
   times_pointer_size = (kPointerSize == 8) ? times_8 : times_4
 };
 
+
 class Operand BASE_EMBEDDED {
  public:
   // [base + disp/r]
@@ -1043,10 +1041,10 @@ class Assembler : public AssemblerBase {
   // Use movaps when moving float values and movd for integer
   // values in xmm registers.
   void movss(XMMRegister dst, XMMRegister src);
+
   void movss(XMMRegister dst, const Operand& src);
   void movss(const Operand& dst, XMMRegister src);
   void shufps(XMMRegister dst, XMMRegister src, byte imm8);
-  void shufpd(XMMRegister dst, XMMRegister src, byte imm8);
 
   void cvttss2si(Register dst, const Operand& src);
   void cvttss2si(Register dst, XMMRegister src);
@@ -1069,15 +1067,6 @@ class Assembler : public AssemblerBase {
   void divps(XMMRegister dst, XMMRegister src);
   void divps(XMMRegister dst, const Operand& src);
 
-  void addpd(XMMRegister dst, XMMRegister src);
-  void addpd(XMMRegister dst, const Operand& src);
-  void subpd(XMMRegister dst, XMMRegister src);
-  void subpd(XMMRegister dst, const Operand& src);
-  void mulpd(XMMRegister dst, XMMRegister src);
-  void mulpd(XMMRegister dst, const Operand& src);
-  void divpd(XMMRegister dst, XMMRegister src);
-  void divpd(XMMRegister dst, const Operand& src);
-
   void movmskps(Register dst, XMMRegister src);
 
   // SSE2 instructions
@@ -1150,10 +1139,8 @@ class Assembler : public AssemblerBase {
   void minsd(XMMRegister dst, const Operand& src);
 
   void andpd(XMMRegister dst, XMMRegister src);
-  void andpd(XMMRegister dst, const Operand& src);
   void orpd(XMMRegister dst, XMMRegister src);
   void xorpd(XMMRegister dst, XMMRegister src);
-  void xorpd(XMMRegister dst, const Operand& src);
   void sqrtsd(XMMRegister dst, XMMRegister src);
   void sqrtsd(XMMRegister dst, const Operand& src);
 
@@ -1171,16 +1158,6 @@ class Assembler : public AssemblerBase {
   // SSE 4.1 instruction
   void insertps(XMMRegister dst, XMMRegister src, byte imm8);
   void extractps(Register dst, XMMRegister src, byte imm8);
-
-  void minpd(XMMRegister dst, XMMRegister src);
-  void minpd(XMMRegister dst, const Operand& src);
-  void maxpd(XMMRegister dst, XMMRegister src);
-  void maxpd(XMMRegister dst, const Operand& src);
-  void sqrtpd(XMMRegister dst, XMMRegister src);
-  void sqrtpd(XMMRegister dst, const Operand& src);
-  void punpackldq(XMMRegister dst, XMMRegister src);
-  void punpackldq(XMMRegister dst, const Operand& src);
-
   void pextrd(Register dst, XMMRegister src, int8_t imm8);
   void pinsrd(XMMRegister dst, Register src, int8_t imm8);
   void pinsrd(XMMRegister dst, const Operand& src, int8_t imm8);
@@ -1392,14 +1369,6 @@ class Assembler : public AssemblerBase {
     vsd(0x11, src, xmm0, dst);
   }
 
-  void pslld(XMMRegister dst, XMMRegister src);
-  void psrld(XMMRegister dst, XMMRegister src);
-  void psrad(XMMRegister reg, int8_t shift);
-  void psrad(XMMRegister dst, XMMRegister src);
-
-  void pcmpgtd(XMMRegister dst, XMMRegister src);
-  void pcmpltd(XMMRegister dst, XMMRegister src);
-
 #define AVX_SP_3(instr, opcode) \
   AVX_S_3(instr, opcode)        \
   AVX_P_3(instr, opcode)
diff --git a/src/x64/deoptimizer-x64.cc b/src/x64/deoptimizer-x64.cc
index 9e32f055b3..35da7a2c00 100644
--- a/src/x64/deoptimizer-x64.cc
+++ b/src/x64/deoptimizer-x64.cc
@@ -97,12 +97,11 @@ void Deoptimizer::SetPlatformCompiledStubRegisters(
   output_frame->SetRegister(rbx.code(), handler);
 }
 
-void Deoptimizer::CopyDoubleRegisters(FrameDescription* output_frame) {}
 
-void Deoptimizer::CopySIMD128Registers(FrameDescription* output_frame) {
+void Deoptimizer::CopyDoubleRegisters(FrameDescription* output_frame) {
   for (int i = 0; i < XMMRegister::kMaxNumRegisters; ++i) {
-    simd128_value_t xmm_value = input_->GetSIMD128Register(i);
-    output_frame->SetSIMD128Register(i, xmm_value);
+    double double_value = input_->GetDoubleRegister(i);
+    output_frame->SetDoubleRegister(i, double_value);
   }
 }
 
@@ -114,15 +113,15 @@ void Deoptimizer::TableEntryGenerator::Generate() {
   // Save all general purpose registers before messing with them.
   const int kNumberOfRegisters = Register::kNumRegisters;
 
-  const int kXMMRegsSize = kSIMD128Size * XMMRegister::kMaxNumRegisters;
-  __ subp(rsp, Immediate(kXMMRegsSize));
+  const int kDoubleRegsSize = kDoubleSize * XMMRegister::kMaxNumRegisters;
+  __ subp(rsp, Immediate(kDoubleRegsSize));
 
   const RegisterConfiguration* config = RegisterConfiguration::Crankshaft();
   for (int i = 0; i < config->num_allocatable_double_registers(); ++i) {
     int code = config->GetAllocatableDoubleCode(i);
     XMMRegister xmm_reg = XMMRegister::from_code(code);
-    int offset = code * kSIMD128Size;
-    __ movups(Operand(rsp, offset), xmm_reg);
+    int offset = code * kDoubleSize;
+    __ Movsd(Operand(rsp, offset), xmm_reg);
   }
 
   // We push all registers onto the stack, even though we do not need
@@ -132,8 +131,8 @@ void Deoptimizer::TableEntryGenerator::Generate() {
     __ pushq(r);
   }
 
-  const int kSavedRegistersAreaSize =
-      kNumberOfRegisters * kRegisterSize + kXMMRegsSize;
+  const int kSavedRegistersAreaSize = kNumberOfRegisters * kRegisterSize +
+                                      kDoubleRegsSize;
 
   __ Store(ExternalReference(Isolate::kCEntryFPAddress, isolate()), rbp);
 
@@ -190,13 +189,11 @@ void Deoptimizer::TableEntryGenerator::Generate() {
     __ PopQuad(Operand(rbx, offset));
   }
 
-  // Fill in the xmm input registers.
-  STATIC_ASSERT(kSIMD128Size == 2 * kDoubleSize);
-  int xmm_regs_offset = FrameDescription::simd128_registers_offset();
+  // Fill in the double input registers.
+  int double_regs_offset = FrameDescription::double_registers_offset();
   for (int i = 0; i < XMMRegister::kMaxNumRegisters; i++) {
-    int dst_offset = i * kSIMD128Size + xmm_regs_offset;
+    int dst_offset = i * kDoubleSize + double_regs_offset;
     __ popq(Operand(rbx, dst_offset));
-    __ popq(Operand(rbx, dst_offset + kDoubleSize));
   }
 
   // Remove the bailout id and return address from the stack.
@@ -263,8 +260,8 @@ void Deoptimizer::TableEntryGenerator::Generate() {
   for (int i = 0; i < config->num_allocatable_double_registers(); ++i) {
     int code = config->GetAllocatableDoubleCode(i);
     XMMRegister xmm_reg = XMMRegister::from_code(code);
-    int src_offset = code * kSIMD128Size + xmm_regs_offset;
-    __ movups(xmm_reg, Operand(rbx, src_offset));
+    int src_offset = code * kDoubleSize + double_regs_offset;
+    __ Movsd(xmm_reg, Operand(rbx, src_offset));
   }
 
   // Push state, pc, and continuation from the last output frame.
@@ -335,33 +332,6 @@ void FrameDescription::SetCallerConstantPool(unsigned offset, intptr_t value) {
   UNREACHABLE();
 }
 
-double RegisterValues::GetDoubleRegister(unsigned n) const {
-  DCHECK(n < arraysize(simd128_registers_));
-  return simd128_registers_[n].d[0];
-}
-
-void RegisterValues::SetDoubleRegister(unsigned n, double value) {
-  DCHECK(n < arraysize(simd128_registers_));
-  simd128_registers_[n].d[0] = value;
-}
-
-simd128_value_t RegisterValues::GetSIMD128Register(unsigned n) const {
-  DCHECK(n < arraysize(simd128_registers_));
-  return simd128_registers_[n];
-}
-
-void RegisterValues::SetSIMD128Register(unsigned n, simd128_value_t value) {
-  DCHECK(n < arraysize(simd128_registers_));
-  simd128_registers_[n] = value;
-}
-
-int FrameDescription::double_registers_offset() {
-  return OFFSET_OF(FrameDescription, register_values_.simd128_registers_);
-}
-
-int FrameDescription::simd128_registers_offset() {
-  return OFFSET_OF(FrameDescription, register_values_.simd128_registers_);
-}
 
 #undef __
 
diff --git a/src/x64/disasm-x64.cc b/src/x64/disasm-x64.cc
index 416eec794f..d6798986a1 100644
--- a/src/x64/disasm-x64.cc
+++ b/src/x64/disasm-x64.cc
@@ -318,17 +318,6 @@ class DisassemblerX64 {
     OPERAND_QUADWORD_SIZE = 3
   };
 
-  enum {
-    rax = 0,
-    rcx = 1,
-    rdx = 2,
-    rbx = 3,
-    rsp = 4,
-    rbp = 5,
-    rsi = 6,
-    rdi = 7
-  };
-
   const NameConverter& converter_;
   v8::internal::EmbeddedVector<char, 128> tmp_buffer_;
   unsigned int tmp_buffer_pos_;
@@ -1548,18 +1537,6 @@ int DisassemblerX64::TwoByteOpcodeInstruction(byte* data) {
         current += PrintRightXMMOperand(current);
         AppendToBuffer(",0x%x", (*current) & 3);
         current += 1;
-      } else if (third_byte == 0x21) {
-        get_modrm(*current, &mod, &regop, &rm);
-        // insertps xmm, xmm, imm8
-        AppendToBuffer("insertps %s,%s,%d", NameOfXMMRegister(regop),
-                       NameOfXMMRegister(rm), (*(current + 1)) & 3);
-        current += 2;
-      } else if (third_byte == 0x22) {
-        get_modrm(*current, &mod, &regop, &rm);
-        // pinsrd xmm, reg32, imm8
-        AppendToBuffer("pinsrd %s,%s,%d", NameOfXMMRegister(regop),
-                       NameOfCPURegister(rm), (*(current + 1)) & 3);
-        current += 2;
       } else if (third_byte == 0x0b) {
         get_modrm(*current, &mod, &regop, &rm);
          // roundsd xmm, xmm/m64, imm8
@@ -1590,16 +1567,6 @@ int DisassemblerX64::TwoByteOpcodeInstruction(byte* data) {
       } else {
         UnimplementedInstruction();
       }
-    } else if (opcode == 0x38) {
-      byte third_byte = *current;
-      current = data + 3;
-      if (third_byte == 0x40) {
-        get_modrm(*current, &mod, &regop, &rm);
-        AppendToBuffer("pmulld %s, ", NameOfXMMRegister(regop));
-        current += PrintRightXMMOperand(current);
-      } else {
-        UnimplementedInstruction();
-      }
     } else {
       get_modrm(*current, &mod, &regop, &rm);
       if (opcode == 0x1f) {
@@ -1629,20 +1596,6 @@ int DisassemblerX64::TwoByteOpcodeInstruction(byte* data) {
         AppendToBuffer("movdqa %s,",
                        NameOfXMMRegister(regop));
         current += PrintRightXMMOperand(current);
-      } else if (opcode == 0x70) {
-        AppendToBuffer("pshufd %s,", NameOfXMMRegister(regop));
-        current += PrintRightXMMOperand(current);
-        AppendToBuffer(",0x%x", (*current) & 0xff);
-        current += 1;
-      } else if (opcode == 0x5B) {
-        AppendToBuffer("cvtps2dq %s,", NameOfXMMRegister(regop));
-        current += PrintRightXMMOperand(current);
-      } else if (opcode == 0xFE) {
-        AppendToBuffer("paddd %s,", NameOfXMMRegister(regop));
-        current += PrintRightXMMOperand(current);
-      } else if (opcode == 0xFA) {
-        AppendToBuffer("psubd %s,", NameOfXMMRegister(regop));
-        current += PrintRightXMMOperand(current);
       } else if (opcode == 0x7E) {
         AppendToBuffer("mov%c ",
                        rex_w() ? 'q' : 'd');
@@ -1676,28 +1629,9 @@ int DisassemblerX64::TwoByteOpcodeInstruction(byte* data) {
         current += 1;
       } else if (opcode == 0xB1) {
         current += PrintOperands("cmpxchg", OPER_REG_OP_ORDER, current);
-      } else if (opcode == 0x62) {
-        AppendToBuffer("punpackldq %s,", NameOfXMMRegister(regop));
-        current += PrintRightXMMOperand(current);
-      } else if (opcode == 0x72) {
-        AppendToBuffer(regop == rsi ? "pslld " : regop == rdx ? "psrld"
-                                                              : "psrad");
-        current += PrintRightXMMOperand(current);
-        AppendToBuffer(",0x%x", (*current) & 0xff);
-        current += 1;
-      } else if (opcode == 0xC6) {
-        AppendToBuffer("shufpd %s,", NameOfXMMRegister(regop));
-        current += PrintRightXMMOperand(current);
-        AppendToBuffer(",0x%x", (*current) & 0xff);
-        current += 1;
-      } else if (opcode == 0xF4) {
-        AppendToBuffer("pmuludq %s,", NameOfXMMRegister(regop));
-        current += PrintRightXMMOperand(current);
       } else {
         const char* mnemonic = "?";
-        if (opcode == 0x51) {
-          mnemonic = "sqrtpd";
-        } else if (opcode == 0x54) {
+        if (opcode == 0x54) {
           mnemonic = "andpd";
         } else  if (opcode == 0x56) {
           mnemonic = "orpd";
@@ -1705,18 +1639,6 @@ int DisassemblerX64::TwoByteOpcodeInstruction(byte* data) {
           mnemonic = "xorpd";
         } else if (opcode == 0x5B) {
           mnemonic = "cvtps2dq";
-        } else if (opcode == 0x58) {
-          mnemonic = "addpd";
-        } else if (opcode == 0x59) {
-          mnemonic = "mulpd";
-        } else if (opcode == 0x5C) {
-          mnemonic = "subpd";
-        } else if (opcode == 0x5D) {
-          mnemonic = "minpd";
-        } else if (opcode == 0x5E) {
-          mnemonic = "divpd";
-        } else if (opcode == 0x5F) {
-          mnemonic = "maxpd";
         } else if (opcode == 0x2E) {
           mnemonic = "ucomisd";
         } else if (opcode == 0x2F) {
@@ -1733,16 +1655,6 @@ int DisassemblerX64::TwoByteOpcodeInstruction(byte* data) {
           mnemonic = "psubd";
         } else if (opcode == 0xFE) {
           mnemonic = "paddd";
-        } else if (opcode == 0x66) {
-          mnemonic = "pcmpgtd";
-        } else if (opcode == 0x76) {
-          mnemonic = "pcmpeqd";
-        } else if (opcode == 0xD2) {
-          mnemonic = "psrld";
-        } else if (opcode == 0xE2) {
-          mnemonic = "psrad";
-        } else if (opcode == 0xF2) {
-          mnemonic = "pslld";
         } else {
           UnimplementedInstruction();
         }
@@ -1932,22 +1844,6 @@ int DisassemblerX64::TwoByteOpcodeInstruction(byte* data) {
     get_modrm(*current, &mod, &regop, &rm);
     AppendToBuffer("ucomiss %s,", NameOfXMMRegister(regop));
     current += PrintRightXMMOperand(current);
-
-  } else if (opcode == 0x10) {
-    // movups xmm, xmm/m128
-    int mod, regop, rm;
-    get_modrm(*current, &mod, &regop, &rm);
-    AppendToBuffer("movups %s, ", NameOfXMMRegister(regop));
-    current += PrintRightXMMOperand(current);
-
-  } else if (opcode == 0x11) {
-    // movups xmm/m128, xmm
-    int mod, regop, rm;
-    get_modrm(*current, &mod, &regop, &rm);
-    AppendToBuffer("movups ");
-    current += PrintRightXMMOperand(current);
-    AppendToBuffer(", %s", NameOfXMMRegister(regop));
-
   } else if (opcode == 0xA2) {
     // CPUID
     AppendToBuffer("%s", mnemonic);
@@ -1989,91 +1885,6 @@ int DisassemblerX64::TwoByteOpcodeInstruction(byte* data) {
     current += PrintRightXMMOperand(current);
     AppendToBuffer(", %d", (*current) & 3);
     current += 1;
-
-  } else if (opcode == 0x54) {
-    // andps xmm, xmm/m128
-    int mod, regop, rm;
-    get_modrm(*current, &mod, &regop, &rm);
-    AppendToBuffer("andps %s, ", NameOfXMMRegister(regop));
-    current += PrintRightXMMOperand(current);
-
-  } else if (opcode == 0x56) {
-    // orps xmm, xmm/m128
-    int mod, regop, rm;
-    get_modrm(*current, &mod, &regop, &rm);
-    AppendToBuffer("orps %s, ", NameOfXMMRegister(regop));
-    current += PrintRightXMMOperand(current);
-
-  } else if (opcode == 0x58) {
-    // addps xmm, xmm/m128
-    int mod, regop, rm;
-    get_modrm(*current, &mod, &regop, &rm);
-    AppendToBuffer("addps %s, ", NameOfXMMRegister(regop));
-    current += PrintRightXMMOperand(current);
-
-  } else if (opcode == 0x59) {
-    // mulps xmm, xmm/m128
-    int mod, regop, rm;
-    get_modrm(*current, &mod, &regop, &rm);
-    AppendToBuffer("mulps %s, ", NameOfXMMRegister(regop));
-    current += PrintRightXMMOperand(current);
-
-  } else if (opcode == 0x5C) {
-    // subps xmm, xmm/m128
-    int mod, regop, rm;
-    get_modrm(*current, &mod, &regop, &rm);
-    AppendToBuffer("subps %s, ", NameOfXMMRegister(regop));
-    current += PrintRightXMMOperand(current);
-
-  } else if (opcode == 0x5E) {
-    // divps xmm, xmm/m128
-    int mod, regop, rm;
-    get_modrm(*current, &mod, &regop, &rm);
-    AppendToBuffer("divps %s, ", NameOfXMMRegister(regop));
-    current += PrintRightXMMOperand(current);
-
-  } else if (opcode == 0x5D) {
-    // minps xmm, xmm/m128
-    int mod, regop, rm;
-    get_modrm(*current, &mod, &regop, &rm);
-    AppendToBuffer("minps %s, ", NameOfXMMRegister(regop));
-    current += PrintRightXMMOperand(current);
-
-  } else if (opcode == 0x5F) {
-    // maxps xmm, xmm/m128
-    int mod, regop, rm;
-    get_modrm(*current, &mod, &regop, &rm);
-    AppendToBuffer("maxps %s, ", NameOfXMMRegister(regop));
-    current += PrintRightXMMOperand(current);
-
-  } else if (opcode == 0x5B) {
-    // cvtdq2ps xmm, xmm/m128
-    int mod, regop, rm;
-    get_modrm(*current, &mod, &regop, &rm);
-    AppendToBuffer("cvtdq2ps %s, ", NameOfXMMRegister(regop));
-    current += PrintRightXMMOperand(current);
-
-  } else if (opcode == 0x53) {
-    // rcpps xmm, xmm/m128
-    int mod, regop, rm;
-    get_modrm(*current, &mod, &regop, &rm);
-    AppendToBuffer("rcpps %s, ", NameOfXMMRegister(regop));
-    current += PrintRightXMMOperand(current);
-
-  } else if (opcode == 0x52) {
-    // rsqrtps xmm, xmm/m128
-    int mod, regop, rm;
-    get_modrm(*current, &mod, &regop, &rm);
-    AppendToBuffer("rsqrtps %s, ", NameOfXMMRegister(regop));
-    current += PrintRightXMMOperand(current);
-
-  } else if (opcode == 0x51) {
-    // sqrtps xmm, xmm/m128
-    int mod, regop, rm;
-    get_modrm(*current, &mod, &regop, &rm);
-    AppendToBuffer("sqrtps %s, ", NameOfXMMRegister(regop));
-    current += PrintRightXMMOperand(current);
-
   } else if (opcode == 0x50) {
     // movmskps reg, xmm
     int mod, regop, rm;
@@ -2081,17 +1892,6 @@ int DisassemblerX64::TwoByteOpcodeInstruction(byte* data) {
     AppendToBuffer("movmskps %s,", NameOfCPURegister(regop));
     current += PrintRightXMMOperand(current);
 
-  } else if (opcode == 0xC2) {
-    // Intel manual 2A, Table 3-11.
-    int mod, regop, rm;
-    get_modrm(*current, &mod, &regop, &rm);
-    const char* const pseudo_op[] = {"cmpeqps",    "cmpltps",  "cmpleps",
-                                     "cmpunordps", "cmpneqps", "cmpnltps",
-                                     "cmpnleps",   "cmpordps"};
-    AppendToBuffer("%s %s,%s", pseudo_op[current[1]], NameOfXMMRegister(regop),
-                   NameOfXMMRegister(rm));
-    current += 2;
-
   } else if ((opcode & 0xF0) == 0x80) {
     // Jcc: Conditional jump (branch).
     current = data + JumpConditional(data);
@@ -2135,7 +1935,8 @@ int DisassemblerX64::TwoByteOpcodeInstruction(byte* data) {
     UnimplementedInstruction();
   }
   return static_cast<int>(current - data);
-}  // NOLINT(readability/fn_size)
+}
+
 
 // Mnemonics for two-byte opcode instructions starting with 0x0F.
 // The argument is the second byte of the two-byte opcode.
diff --git a/src/x64/macro-assembler-x64.cc b/src/x64/macro-assembler-x64.cc
index ca68dc046c..cd6b90ce95 100644
--- a/src/x64/macro-assembler-x64.cc
+++ b/src/x64/macro-assembler-x64.cc
@@ -775,10 +775,10 @@ void MacroAssembler::PushCallerSaved(SaveFPRegsMode fp_mode,
   }
   // R12 to r15 are callee save on all platforms.
   if (fp_mode == kSaveFPRegs) {
-    subp(rsp, Immediate(kSIMD128Size * XMMRegister::kMaxNumRegisters));
+    subp(rsp, Immediate(kDoubleSize * XMMRegister::kMaxNumRegisters));
     for (int i = 0; i < XMMRegister::kMaxNumRegisters; i++) {
       XMMRegister reg = XMMRegister::from_code(i);
-      movups(Operand(rsp, i * kSIMD128Size), reg);
+      Movsd(Operand(rsp, i * kDoubleSize), reg);
     }
   }
 }
@@ -791,9 +791,9 @@ void MacroAssembler::PopCallerSaved(SaveFPRegsMode fp_mode,
   if (fp_mode == kSaveFPRegs) {
     for (int i = 0; i < XMMRegister::kMaxNumRegisters; i++) {
       XMMRegister reg = XMMRegister::from_code(i);
-      movups(reg, Operand(rsp, i * kSIMD128Size));
+      Movsd(reg, Operand(rsp, i * kDoubleSize));
     }
-    addp(rsp, Immediate(kSIMD128Size * XMMRegister::kMaxNumRegisters));
+    addp(rsp, Immediate(kDoubleSize * XMMRegister::kMaxNumRegisters));
   }
   for (int i = kNumberOfSavedRegs - 1; i >= 0; i--) {
     Register reg = saved_regs[i];
@@ -2519,70 +2519,6 @@ void MacroAssembler::Test(const Operand& src, Smi* source) {
 
 // ----------------------------------------------------------------------------
 
-void MacroAssembler::absps(XMMRegister dst) {
-  static const struct V8_ALIGNED(16) {
-    uint32_t a;
-    uint32_t b;
-    uint32_t c;
-    uint32_t d;
-  } float_absolute_constant = {0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF};
-  Set(kScratchRegister, reinterpret_cast<intptr_t>(&float_absolute_constant));
-  andps(dst, Operand(kScratchRegister, 0));
-}
-
-void MacroAssembler::abspd(XMMRegister dst) {
-  static const struct V8_ALIGNED(16) {
-    uint64_t a;
-    uint64_t b;
-  } double_absolute_constant = {V8_UINT64_C(0x7FFFFFFFFFFFFFFF),
-                                V8_UINT64_C(0x7FFFFFFFFFFFFFFF)};
-  Set(kScratchRegister, reinterpret_cast<intptr_t>(&double_absolute_constant));
-  andpd(dst, Operand(kScratchRegister, 0));
-}
-
-void MacroAssembler::negateps(XMMRegister dst) {
-  static const struct V8_ALIGNED(16) {
-    uint32_t a;
-    uint32_t b;
-    uint32_t c;
-    uint32_t d;
-  } float_negate_constant = {0x80000000, 0x80000000, 0x80000000, 0x80000000};
-  Set(kScratchRegister, reinterpret_cast<intptr_t>(&float_negate_constant));
-  xorps(dst, Operand(kScratchRegister, 0));
-}
-
-void MacroAssembler::negatepd(XMMRegister dst) {
-  static const struct V8_ALIGNED(16) {
-    uint64_t a;
-    uint64_t b;
-  } double_absolute_constant = {V8_UINT64_C(0x8000000000000000),
-                                V8_UINT64_C(0x8000000000000000)};
-  Set(kScratchRegister, reinterpret_cast<intptr_t>(&double_absolute_constant));
-  xorpd(dst, Operand(kScratchRegister, 0));
-}
-
-void MacroAssembler::notps(XMMRegister dst) {
-  static const struct V8_ALIGNED(16) {
-    uint32_t a;
-    uint32_t b;
-    uint32_t c;
-    uint32_t d;
-  } float_not_constant = {0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF};
-  Set(kScratchRegister, reinterpret_cast<intptr_t>(&float_not_constant));
-  xorps(dst, Operand(kScratchRegister, 0));
-}
-
-void MacroAssembler::pnegd(XMMRegister dst) {
-  static const struct V8_ALIGNED(16) {
-    uint32_t a;
-    uint32_t b;
-    uint32_t c;
-    uint32_t d;
-  } int32_one_constant = {0x1, 0x1, 0x1, 0x1};
-  notps(dst);
-  Set(kScratchRegister, reinterpret_cast<intptr_t>(&int32_one_constant));
-  paddd(dst, Operand(kScratchRegister, 0));
-}
 
 void MacroAssembler::JumpIfNotString(Register object,
                                      Register object_map,
@@ -4544,7 +4480,7 @@ void MacroAssembler::EnterExitFrameEpilogue(int arg_stack_space,
 #endif
   // Optionally save all XMM registers.
   if (save_doubles) {
-    int space = XMMRegister::kMaxNumRegisters * kSIMD128Size +
+    int space = XMMRegister::kMaxNumRegisters * kDoubleSize +
                 arg_stack_space * kRegisterSize;
     subp(rsp, Immediate(space));
     int offset = -ExitFrameConstants::kFixedFrameSizeFromFp;
@@ -4552,7 +4488,7 @@ void MacroAssembler::EnterExitFrameEpilogue(int arg_stack_space,
     for (int i = 0; i < config->num_allocatable_double_registers(); ++i) {
       DoubleRegister reg =
           DoubleRegister::from_code(config->GetAllocatableDoubleCode(i));
-      movups(Operand(rbp, offset - ((i + 1) * kSIMD128Size)), reg);
+      Movsd(Operand(rbp, offset - ((i + 1) * kDoubleSize)), reg);
     }
   } else if (arg_stack_space > 0) {
     subp(rsp, Immediate(arg_stack_space * kRegisterSize));
@@ -4598,7 +4534,7 @@ void MacroAssembler::LeaveExitFrame(bool save_doubles, bool pop_arguments) {
     for (int i = 0; i < config->num_allocatable_double_registers(); ++i) {
       DoubleRegister reg =
           DoubleRegister::from_code(config->GetAllocatableDoubleCode(i));
-      movups(reg, Operand(rbp, offset - ((i + 1) * kSIMD128Size)));
+      Movsd(reg, Operand(rbp, offset - ((i + 1) * kDoubleSize)));
     }
   }
 
@@ -5105,27 +5041,6 @@ void MacroAssembler::AllocateHeapNumber(Register result,
   movp(FieldOperand(result, HeapObject::kMapOffset), kScratchRegister);
 }
 
-#define SIMD128_HEAP_ALLOCATE_FUNCTIONS(V) \
-  V(Float32x4, float32x4)                  \
-  V(Bool32x4, bool32x4)                    \
-  V(Int32x4, int32x4)
-
-#define DECLARE_SIMD_HEAP_ALLOCATE_FUNCTION(Type, type)                     \
-  void MacroAssembler::Allocate##Type(Register result, Register scratch1,   \
-                                      Register scratch2, Register scratch3, \
-                                      Label* gc_required) {                 \
-    /* Allocate SIMD128 object.*/                                           \
-    Allocate(Type::kSize, result, scratch1, no_reg, gc_required,            \
-             NO_ALLOCATION_FLAGS);                                          \
-                                                                            \
-    Heap::RootListIndex map_index = Heap::k##Type##MapRootIndex;            \
-                                                                            \
-    /* Set the map. */                                                      \
-    LoadRoot(kScratchRegister, map_index);                                  \
-    movp(FieldOperand(result, HeapObject::kMapOffset), kScratchRegister);   \
-  }
-
-SIMD128_HEAP_ALLOCATE_FUNCTIONS(DECLARE_SIMD_HEAP_ALLOCATE_FUNCTION)
 
 void MacroAssembler::AllocateTwoByteString(Register result,
                                            Register length,
diff --git a/src/x64/macro-assembler-x64.h b/src/x64/macro-assembler-x64.h
index 048eb6c4cf..b088c7d19c 100644
--- a/src/x64/macro-assembler-x64.h
+++ b/src/x64/macro-assembler-x64.h
@@ -771,15 +771,6 @@ class MacroAssembler: public Assembler {
   void Test(const Operand& dst, Smi* source);
 
 
-  // ---------------------------------------------------------------------------
-  // SIMD macros.
-  void absps(XMMRegister dst);
-  void abspd(XMMRegister dst);
-  void negateps(XMMRegister dst);
-  void negatepd(XMMRegister dst);
-  void notps(XMMRegister dst);
-  void pnegd(XMMRegister dst);
-
   // ---------------------------------------------------------------------------
   // String macros.
 
@@ -1334,19 +1325,6 @@ class MacroAssembler: public Assembler {
                           Label* gc_required,
                           MutableMode mode = IMMUTABLE);
 
-  // Allocate a float32x4, bool32x4  and int32x4 object in new space with
-  // undefined value.
-  // Returns tagged pointer in result register, or jumps to gc_required if new
-  // space is full.
-  void AllocateFloat32x4(Register result, Register scratch1, Register scratch2,
-                         Register scratch3, Label* gc_required);
-
-  void AllocateBool32x4(Register result, Register scratch1, Register scratch2,
-                        Register scratch3, Label* gc_required);
-
-  void AllocateInt32x4(Register result, Register scratch1, Register scratch2,
-                       Register scratch3, Label* gc_required);
-
   // Allocate a sequential string. All the header fields of the string object
   // are initialized.
   void AllocateTwoByteString(Register result,
diff --git a/test/cctest/test-disasm-ia32.cc b/test/cctest/test-disasm-ia32.cc
index 8f9bdfc797..5bd11bcf53 100644
--- a/test/cctest/test-disasm-ia32.cc
+++ b/test/cctest/test-disasm-ia32.cc
@@ -469,83 +469,6 @@ TEST(DisasmIa320) {
     __ punpckldq(xmm1, xmm6);
     __ punpckhdq(xmm7, xmm5);
   }
-  {
-    __ cvttss2si(edx, Operand(ebx, ecx, times_4, 10000));
-    __ cvtsi2sd(xmm1, Operand(ebx, ecx, times_4, 10000));
-    __ movsd(xmm1, Operand(ebx, ecx, times_4, 10000));
-    __ movsd(Operand(ebx, ecx, times_4, 10000), xmm1);
-    // 128 bit move instructions.
-    __ movdqa(xmm0, Operand(ebx, ecx, times_4, 10000));
-    __ movdqa(Operand(ebx, ecx, times_4, 10000), xmm0);
-    __ movdqu(xmm0, Operand(ebx, ecx, times_4, 10000));
-    __ movdqu(Operand(ebx, ecx, times_4, 10000), xmm0);
-
-    __ addsd(xmm1, xmm0);
-    __ mulsd(xmm1, xmm0);
-    __ subsd(xmm1, xmm0);
-    __ divsd(xmm1, xmm0);
-    __ ucomisd(xmm0, xmm1);
-    __ cmpltsd(xmm0, xmm1);
-
-    __ andpd(xmm0, xmm1);
-    __ psllq(xmm0, 17);
-    __ psllq(xmm0, xmm1);
-    __ psrlq(xmm0, 17);
-    __ psrlq(xmm0, xmm1);
-    __ por(xmm0, xmm1);
-
-    // new instruction introduced by SIMD
-    __ cvtdq2ps(xmm1, Operand(ebx, ecx, times_4, 10000));
-    __ cvtdq2ps(xmm1, xmm0);
-    __ cvtps2dq(xmm1, Operand(ebx, ecx, times_4, 10000));
-    __ cvtps2dq(xmm1, xmm0);
-    __ paddd(xmm1, Operand(ebx, ecx, times_4, 10000));
-    __ paddd(xmm1, xmm0);
-    __ psubd(xmm1, Operand(ebx, ecx, times_4, 10000));
-    __ psubd(xmm1, xmm0);
-    __ pmuludq(xmm1, Operand(ebx, ecx, times_4, 10000));
-    __ pmuludq(xmm1, xmm0);
-    __ punpackldq(xmm1, Operand(ebx, ecx, times_4, 10000));
-    __ punpackldq(xmm1, xmm0);
-    {
-      __ shufps(xmm1, xmm1, 0x0);
-      __ movups(xmm1, Operand(ebx, ecx, times_4, 10000));
-      __ movups(Operand(ebx, ecx, times_4, 10000), xmm1);
-
-      __ andps(xmm1, Operand(ebx, ecx, times_4, 10000));
-      __ andps(xmm1, xmm0);
-      __ xorps(xmm1, Operand(ebx, ecx, times_4, 10000));
-      __ xorps(xmm1, xmm0);
-      __ orps(xmm1, Operand(ebx, ecx, times_4, 10000));
-      __ orps(xmm1, xmm0);
-
-      __ addps(xmm1, Operand(ebx, ecx, times_4, 10000));
-      __ addps(xmm1, xmm0);
-      __ subps(xmm1, Operand(ebx, ecx, times_4, 10000));
-      __ subps(xmm1, xmm0);
-      __ mulps(xmm1, Operand(ebx, ecx, times_4, 10000));
-      __ mulps(xmm1, xmm0);
-      __ divps(xmm1, Operand(ebx, ecx, times_4, 10000));
-      __ divps(xmm1, xmm0);
-      __ minps(xmm1, Operand(ebx, ecx, times_4, 10000));
-      __ minps(xmm1, xmm0);
-      __ maxps(xmm1, Operand(ebx, ecx, times_4, 10000));
-      __ maxps(xmm1, xmm0);
-      __ rcpps(xmm1, Operand(ebx, ecx, times_4, 10000));
-      __ rcpps(xmm1, xmm0);
-      __ rsqrtps(xmm1, Operand(ebx, ecx, times_4, 10000));
-      __ rsqrtps(xmm1, xmm0);
-      __ sqrtps(xmm1, Operand(ebx, ecx, times_4, 10000));
-      __ sqrtps(xmm1, xmm0);
-
-      __ cmpeqps(xmm1, xmm0);
-      __ cmpltps(xmm1, xmm0);
-      __ cmpleps(xmm1, xmm0);
-      __ cmpneqps(xmm1, xmm0);
-      __ cmpnltps(xmm1, xmm0);
-      __ cmpnleps(xmm1, xmm0);
-    }
-  }
 
   // cmov.
   {
@@ -573,9 +496,6 @@ TEST(DisasmIa320) {
       __ pextrd(eax, xmm0, 1);
       __ pinsrd(xmm1, eax, 0);
       __ extractps(eax, xmm1, 0);
-      __ insertps(xmm1, xmm0, 0);
-      __ pmulld(xmm1, Operand(ebx, ecx, times_4, 10000));
-      __ pmulld(xmm1, xmm0);
     }
   }
 
